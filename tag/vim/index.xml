<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>vim on Bounded-Error Log</title>
    <link>//blog.vero.site/tag/vim</link>
    <description>Recent content in vim on Bounded-Error Log</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 13 Apr 2014 15:51:16 +0800</lastBuildDate>
    
	<atom:link href="//blog.vero.site/tag/vim/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Adventures in Cabal Installations</title>
      <link>//blog.vero.site/post/cabal</link>
      <pubDate>Sun, 13 Apr 2014 15:51:16 +0800</pubDate>
      
      <guid>//blog.vero.site/post/cabal</guid>
      <description>&lt;p&gt;First Google Code Jam!&lt;/p&gt;
&lt;p&gt;The format of this competition, allowing us to run programs on our own machines, brought up a very interesting issue for me: what programming language should I be using? (I had had similar considerations for IPSC 2013, but GCJ’s problems are closer to the traditional ACM-ICPC style.)&lt;/p&gt;
&lt;p&gt;The obvious choice is C++, the language I use for roughly every other competition, but its safety (or lack thereof) is not very appealing. I need speed, but not &lt;em&gt;that much&lt;/em&gt; speed. Unfortunately I still haven’t gotten around to learning any other friendlier mid-level languages (on the list: D, Go, or Rust), so I have no close substitutes for C++ right now.&lt;/p&gt;
&lt;p&gt;Python is certainly available for a reliable arbitrary-length integer type, if nothing else.&lt;/p&gt;
&lt;p&gt;As for non-candidates, Java has &lt;code&gt;BigInteger&lt;/code&gt; and memory safety, but all in all I decided the benefits are too minor and it’s too ugly without operator overloading. Scala is probably way too slow. So I don’t expect to be writing either language.&lt;/p&gt;
&lt;p&gt;The only difficult choice I have to make is, of course, Haskell — which can be quite fast, even while it’s ridiculously type-safe and expressive and referentially transparent and easy to reason about, once you’ve:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;figured out how to do the problem&lt;/li&gt;
&lt;li&gt;scrapped step 1 and &lt;em&gt;actually&lt;/em&gt; figured out how to do the problem &lt;em&gt;functionally&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;gotten the thing to compile&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Even if I can handle step 1, step 2 is by no means a simple task, as my struggle to implement a mere &lt;a href=&#34;//blog.vero.site/post/haskell&#34;&gt;Sieve of Eratosthenes&lt;/a&gt; efficiently shows. That is fun, but not at all intuitive; I am doubtful I can do this under contest conditions. It is extremely difficult to transfer my skills in learning how to implement, say, a segment tree or treap into this language.&lt;/p&gt;
&lt;p&gt;But! Google links to the &lt;a href=&#34;http://www.go-hero.net/jam/10/round/0&#34;&gt;programming language breakdown for 2010 Qualification Round&lt;/a&gt; as an example, and much to my surprise, Haskell ranks somewhere between sixth and tenth place in popularity (depending on what you sort by), so there are functional superprogrammers who can presumably do something like this.&lt;/p&gt;
&lt;p&gt;As it happens, I ended up implementing all four solutions to the qualification rounds in Haskell, because of the relaxed time limit and lack of any involved algorithms and data structures. I think it was worth it.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>