<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ctf on Bounded-Error Log</title>
    <link>//blog.vero.site/tag/ctf</link>
    <description>Recent content in Ctf on Bounded-Error Log</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 06 May 2018 13:52:52 -0400</lastBuildDate>
    
	<atom:link href="//blog.vero.site/tag/ctf/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Pupper/Doggo</title>
      <link>//blog.vero.site/post/doggo</link>
      <pubDate>Sun, 06 May 2018 13:52:52 -0400</pubDate>
      
      <guid>//blog.vero.site/post/doggo</guid>
      <description>We are presented with a big zip file of SML code, which implements an interpreter for a small ML-like language with a form of taint analysis in its type checker, called Wolf. Concretely, every type in Wolf’s type system has an associated secrecy: it is either “private” or “public”, and in theory, the type system makes it impossible to do any computation on private data to get a public result.</description>
    </item>
    
    <item>
      <title>Sakura</title>
      <link>//blog.vero.site/post/sakura</link>
      <pubDate>Sun, 12 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>//blog.vero.site/post/sakura</guid>
      <description>&lt;p&gt;(Okay, this post is backdated.)&lt;/p&gt;
&lt;p&gt;Disassembling the executable produces a huge amount of code. There are some basic obfuscations like a lot of trivial identity functions nested in each other, and a few functions that wrap around identity functions but just add some constant multiple of 16. Most of the meat is in one very large function, though. If you disassemble this function with IDA, you see a lot of variable initializations and then a lot of interesting loops that are quite similar:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Thoroughly Stripped</title>
      <link>//blog.vero.site/post/thoroughly-stripped</link>
      <pubDate>Sun, 12 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>//blog.vero.site/post/thoroughly-stripped</guid>
      <description>&lt;p&gt;Woo, first CTF writeup. I got the opportunity to participate in the 2017 CSAW CTF finals with Don’t Hack Alone.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dumped by my core, left to bleed out bytes on the heap, I was stripped of my dignity… The last thing I could do was to let other programs strip me of my null-bytes just so my memory could live on.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We are provided with a core dump. Examining the flavor-text and the dump, we notice that the dump has no null bytes; we conjecture that they have been stripped out.&lt;/p&gt;
&lt;p&gt;Next, we examine the hexdump and look for any clues. There are a bunch of ASCII strings, but they look like normal debugging symbols. One thing that jumps out is that there are a couple fairly convincing regular striped patterns that become vertically aligned if you display 20 bytes in each line. Once we do that, we notice the following section. (This dump is from &lt;a href=&#34;https://github.com/betaveros/xxb&#34;&gt;&lt;code&gt;xxb&lt;/code&gt;&lt;/a&gt; but &lt;code&gt;xxd -c 20 thoroughlyStripped&lt;/code&gt; is quite sufficient.)&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>