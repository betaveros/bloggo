<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ctf on Bounded-Error Log</title>
    <link>//blog.vero.site/tag/ctf</link>
    <description>Recent content in Ctf on Bounded-Error Log</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 06 May 2018 13:52:52 -0400</lastBuildDate>
    
	<atom:link href="//blog.vero.site/tag/ctf/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Pupper/Doggo</title>
      <link>//blog.vero.site/post/doggo</link>
      <pubDate>Sun, 06 May 2018 13:52:52 -0400</pubDate>
      
      <guid>//blog.vero.site/post/doggo</guid>
      <description>&lt;p&gt;We are presented with a big zip file of SML code, which implements an interpreter for a small ML-like language with a form of taint analysis in its type checker, called &lt;em&gt;Wolf&lt;/em&gt;. Concretely, every type in Wolf’s type system has an associated &lt;em&gt;secrecy&lt;/em&gt;: it is either “private” or “public”, and in theory, the type system makes it impossible to do any computation on private data to get a public result.&lt;/p&gt;
&lt;p&gt;Of course, this is a CTF, so the challenge is all about breaking the theoretical guarantees of the type system. When we submit code, it’s evaluated in a context with a private integer variable &lt;code&gt;flag&lt;/code&gt;; our code is typechecked, executed, and printed, but only if its type is public. The goal is to break the type system and write code that produces a public value that depends on &lt;code&gt;flag&lt;/code&gt;, so that we can exfiltrate &lt;code&gt;flag&lt;/code&gt; itself.&lt;/p&gt;
&lt;p&gt;In all, there are three progressively harder Wolf problems, named Pupper, Doggo, and Woofer. Doggo and Woofer are each encrypted with the flag of the challenge before it, so that you need to solve them in order (unless you can somehow blindly exploit servers running SML programs).&lt;/p&gt;
&lt;h3 id=&#34;wolf-overview&#34;&gt;Wolf Overview&lt;/h3&gt;
&lt;p&gt;Let’s first go over the Wolf syntax and semantics. (There are small differences between the three problems, but they’re syntactically identical and only semantically differ in cases that we’ll naturally get to.) The &lt;code&gt;examples&lt;/code&gt; folder has some examples of valid code:&lt;/p&gt;
&lt;pre class=&#34;sourceCode ml&#34;&gt;&lt;code class=&#34;sourceCode ocaml&#34;&gt;&lt;div class=&#34;sourceLine&#34; id=&#34;1&#34; href=&#34;#1&#34; data-line-number=&#34;1&#34;&gt;&lt;span class=&#34;kw&#34;&gt;let&lt;/span&gt; x = (&lt;span class=&#34;dv&#34;&gt;5&lt;/span&gt; :&amp;gt; &lt;span class=&#34;kw&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;int&lt;/span&gt;) &lt;span class=&#34;kw&#34;&gt;in&lt;/span&gt;&lt;/div&gt;
&lt;div class=&#34;sourceLine&#34; id=&#34;2&#34; href=&#34;#2&#34; data-line-number=&#34;2&#34;&gt;&lt;span class=&#34;dv&#34;&gt;6&lt;/span&gt;&lt;/div&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Sakura</title>
      <link>//blog.vero.site/post/sakura</link>
      <pubDate>Sun, 12 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>//blog.vero.site/post/sakura</guid>
      <description>&lt;p&gt;(Okay, this post is backdated.)&lt;/p&gt;
&lt;p&gt;Disassembling the executable produces a huge amount of code. There are some basic obfuscations like a lot of trivial identity functions nested in each other, and a few functions that wrap around identity functions but just add some constant multiple of 16. Most of the meat is in one very large function, though. If you disassemble this function with IDA, you see a lot of variable initializations and then a lot of interesting loops that are quite similar:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Thoroughly Stripped</title>
      <link>//blog.vero.site/post/thoroughly-stripped</link>
      <pubDate>Sun, 12 Nov 2017 00:00:00 -0500</pubDate>
      
      <guid>//blog.vero.site/post/thoroughly-stripped</guid>
      <description>&lt;p&gt;Woo, first CTF writeup. I got the opportunity to participate in the 2017 CSAW CTF finals with Don’t Hack Alone.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dumped by my core, left to bleed out bytes on the heap, I was stripped of my dignity… The last thing I could do was to let other programs strip me of my null-bytes just so my memory could live on.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We are provided with a core dump. Examining the flavor-text and the dump, we notice that the dump has no null bytes; we conjecture that they have been stripped out.&lt;/p&gt;
&lt;p&gt;Next, we examine the hexdump and look for any clues. There are a bunch of ASCII strings, but they look like normal debugging symbols. One thing that jumps out is that there are a couple fairly convincing regular striped patterns that become vertically aligned if you display 20 bytes in each line. Once we do that, we notice the following section. (This dump is from &lt;a href=&#34;https://github.com/betaveros/xxb&#34;&gt;&lt;code&gt;xxb&lt;/code&gt;&lt;/a&gt; but &lt;code&gt;xxd -c 20 thoroughlyStripped&lt;/code&gt; is quite sufficient.)&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>