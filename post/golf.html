<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8" />
<title>Introduction to Code Golf and Golflangs</title>

<meta name="author" content="betaveros" />
<meta name="description" content="Code golf is the recreational activity1 of trying to write programs that are as short as possible.2 Golfed programs still have to be correct, but brevity is prioritized above every other concern — e.g., robustness, performance, or legibility — which usually leads to really interesting code.
I think code golf is a lot of fun (although I think a lot of things are fun, so it’s one of those hobbies that I get really into roughly one month every year and then completely forget about for the remaining eleven). I wanted to write an introduction because I don’t know of any good general introductions to code golf, particularly ones that try to be language-agnostic and that cover the fascinating world of programming languages designed specifically for code golf, which I’ll call golflangs for short. But more on that later.
Note: If you are the kind of person who prefers to just dive in and try golfing some code without guidance, you should skip to the code golf sites section.
A simple example Of course, there’s a reason most code golf tutorials focus on a single language: most code golf techniques are language-specific. The Code Golf &amp;amp; Coding Challenges (CGCC) StackExchange community has a list of some golfing tips that apply to most languages, but there are far more tricks in just about any language-specific list, and most of the intrigue lies in knowing the language you’re golfing well. So to provide a taste of the code golf experience, let’s golf a simple problem, Anarchy Golf’s Factorial, in Python.
In this problem, we have to read a series of positive integers from standard input, one per line, and output the factorial of each, also one per line. Here’s a stab at a simple, direct implementation with no golfing at all:3
def factorial(n): if n &amp;lt;= 1: return 1 return n * factorial(n-1) try: while True: print(factorial(int(input()))) except EOFError: pass" /><meta name="generator" content="Hugo 0.102.0-DEV" />

<link rel="canonical" href="//blog.vero.site/post/golf" />
<link rel="alternative" href="/index.xml" title="Bounded-Error Log" type="application/atom+xml" />

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="format-detection" content="telephone=no,email=no,adress=no" />
<meta http-equiv="Cache-Control" content="no-transform" />

<meta name="robots" content="index,follow" />
<meta name="referrer" content="origin-when-cross-origin" />
<meta name="theme-color" content="#330000" />
<meta name="twitter:creator" content="@betaveros">

<link rel="icon" href="/favicon.ico" />

<link rel="stylesheet" href="/css/bundle.css" />
<link rel="stylesheet" href="/katex/katex.min.css" />

<!--[if lte IE 11]>
    <script src="//cdn.bootcss.com/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

</head>
<body>
<div id="wrapper">
<header class="site-header"><h2 class="title"><a href="/">Bounded-Error Log</a></h2><p class="subtitle">theoretical and applied randomness by <a href="https://beta.vero.site/">betaveros</a></p>
<button class="menu-toggle" type="button" aria-label="Toggle Menu">
	<span class="icon icon-menu" aria-hidden="true"></span>
</button>
<nav class="site-menu collapsed">
	<h2 class="offscreen">Main Menu</h2>
	<ul class="menu-list"><li class="menu-item "><a href="/about">About</a></li><li class="menu-item "><a href="/category/life">Life</a></li><li class="menu-item "><a href="/category/thoughts">Thoughts</a></li><li class="menu-item "><a href="/category/self-analysis">Self-Analysis</a></li><li class="menu-item "><a href="/category/math">Math</a></li><li class="menu-item "><a href="/category/cs">CS</a></li><li class="menu-item "><a href="/category/puzzles">Puzzles</a></li><li class="menu-item "><a href="/category/meta">Meta</a></li><li class="menu-item "><a href="/ref">References</a></li><li class="menu-item "><a href="/util">Utilities</a></li><li class="menu-item "><a href="/all">All Posts</a></li></ul>
</nav>
<nav class="social-menu collapsed">
	<h2 class="offscreen">Social Networks</h2>
	<ul class="social-list"><li class="social-item">
			<a href="//github.com/betaveros" title="GitHub" aria-label="GitHub"><span class="icon icon-github" aria-hidden="true"></span></a>

		</li><li class="social-item">
			<a href="/index.xml" title="RSS" aria-label="RSS"><span class="icon icon-rss" aria-hidden="true"></span></a>
		</li>
	</ul>
</nav>
</header>

<section class="main post-detail">
	<header>
		<h1 class="post-title">Introduction to Code Golf and Golflangs</h1>
		
		<p class="post-meta">
		
		2022-12-22
		(9290 words)
		
		<span class="post-categories">
			filed under
			<a href="/category/cs">CS</a>
		</span>
		
		</p>
	</header>
	<article><p>Code golf is the recreational activity<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> of trying to write programs that are as short as possible.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> Golfed programs still have to be correct, but brevity is prioritized above every other concern — e.g., robustness, performance, or legibility — which usually leads to really interesting code.</p>
<p>I think code golf is a lot of fun (although I think a lot of things are fun, so it’s one of those hobbies that I get really into roughly one month every year and then completely forget about for the remaining eleven). I wanted to write an introduction because I don’t know of any good general introductions to code golf, particularly ones that try to be language-agnostic and that cover the fascinating world of <em>programming languages designed specifically for code golf</em>, which I’ll call golflangs for short. But more on that later.</p>
<p>Note: If you are the kind of person who prefers to just dive in and try golfing some code without guidance, you should skip to the <a href="#code-golf-sites">code golf sites</a> section.</p>
<h3 id="a-simple-example">A simple example</h3>
<p>Of course, there’s a reason most code golf tutorials focus on a single language: most code golf techniques are language-specific. The Code Golf &amp; Coding Challenges (CGCC) StackExchange community has a list of some <a href="https://codegolf.stackexchange.com/questions/5285/tips-for-golfing-in-all-languages">golfing tips that apply to most languages</a>, but there are far more tricks in just about any language-specific list, and most of the intrigue lies in knowing the language you’re golfing well. So to provide a taste of the code golf experience, let’s golf a simple problem, Anarchy Golf’s <a href="http://golf.shinh.org/p.rb?Factorial">Factorial</a>, in Python.</p>
<p>In this problem, we have to read a series of positive integers from standard input, one per line, and output the factorial of each, also one per line. Here’s a stab at a simple, direct implementation with no golfing at all:<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">def</span> factorial(n):</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span>: <span class="cf">return</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="cf">return</span> n <span class="op">*</span> factorial(n<span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="cf">try</span>:</a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="cf">while</span> <span class="va">True</span>:</a>
<a class="sourceLine" id="cb1-6" title="6">        <span class="bu">print</span>(factorial(<span class="bu">int</span>(<span class="bu">input</span>())))</a>
<a class="sourceLine" id="cb1-7" title="7"><span class="cf">except</span> <span class="pp">EOFError</span>:</a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="cf">pass</span></a></code></pre></div>
<p>This comes out to <strong>157 bytes</strong>.</p>
<p>Feel free to stop reading here for a while and see how much you can shorten it!</p>
<p>Note that, in computing this byte count and all others in this post, I am assuming that the code does not have a newline at the very end, although many text editors will add one by default. (Also, I’m using Linux-style <code>\n</code> newlines rather than Windows-style <code>\r\n</code> newlines.) In Vim, I have to <code>:set binary noeol</code> to save a file without that final newline. If you copy this code into a text editor and get a slightly larger byte count, that might be why; and if you submit code to a golf site by uploading a file, you should almost always make sure the file doesn’t have a trailing newline to get the best possible score.</p>
<p>First we’ll golf this code in some straightforward ways. We’ll shorten the long name <code>factorial</code>, replace the <code>if</code> statement with a <a href="https://docs.python.org/3/reference/expressions.html#conditional-expressions">conditional expression</a>, replace <code>True</code> with <code>1</code> (since nonzero numbers <a href="https://docs.python.org/3/library/stdtypes.html#truth">test as true</a> in Python, sometimes less formally called being “truthy” in other languages), and remove all the error handling and unnecessary whitespace. Unlike, say, most programming competitions, having your program terminate with an error is typically accepted in code golf — as long as your program writes exactly the correct bytes to standard output, it doesn’t matter if it spews additional junk to standard error or exits with a nonzero code. This gets us down to <strong>68 bytes</strong>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">def</span> f(n):<span class="cf">return</span> 1if n<span class="op">&lt;=</span>1else n<span class="op">*</span>f(n<span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="cf">while</span> <span class="dv">1</span>:<span class="bu">print</span>(f(<span class="bu">int</span>(<span class="bu">input</span>())))</a></code></pre></div>
<p>Already, this reveals a corner of Python that I expect most nongolfers not to know: it’s legal to not put a space between an integer literal <code>1</code> and a subsequent <code>if</code> or <code>else</code>! Well, at least for now; Python 3.12 release notes list this syntactic feature as <a href="https://docs.python.org/3.12/whatsnew/3.12.html#pending-removal-in-future-versions">pending removal</a>, per <a href="https://github.com/python/cpython/issues/87999">GitHub issue</a>. And you can tell that the syntax is dicey just from how the syntax highlighter handles it incorrectly.</p>
<p>Trying a little harder: Firstly, it turns out using <code>def</code> to define a function is quite a bit more verbose than defining it as a <code>lambda</code> due to having to also explicitly <code>return</code> the result. Secondly, <code>n&lt;=1</code> could be replaced with <code>n&lt;2</code>. But we can do even better: we can choose to stop recursing when <code>n</code> is zero instead, so we can just test <code>n</code> itself, again because integers are truthy precisely when nonzero. This produces a solution with <strong>61 bytes</strong>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1">f<span class="op">=</span><span class="kw">lambda</span> n:n<span class="op">*</span>f(n<span class="dv">-1</span>)<span class="cf">if</span> n <span class="cf">else</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="cf">while</span> <span class="dv">1</span>:<span class="bu">print</span>(f(<span class="bu">int</span>(<span class="bu">input</span>())))</a></code></pre></div>
<p>There’s one more arcane<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a> trick we can use to save a byte off the conditional, which currently uses the rather verbose <code>if</code>/<code>else</code> keywords. When golfing Python, the best way to express a conditional is often treating a boolean as an integer and indexing into a two-element list: <code>[f,t][b]</code>, where <code>b</code> is a boolean, is <code>f</code> if <code>b</code> is <code>False</code> (which coerces<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> to 0) and <code>t</code> if <code>b</code> is <code>True</code> (which coerces to 1). Unfortunately, we can’t use that strategy here because it always evaluates both <code>f</code> and <code>t</code>, whereas we do need to short-circuit to prevent <code>f</code> from recursing infinitely, not to mention that we want to use <code>n</code>’s truthiness, which is not a boolean. However, because <code>f</code>’s output is always nonzero, we can still save 1 byte by replacing the conditional with an <code>and</code>/<code>or</code> pair, producing this solution with <strong>60 bytes</strong>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1">f<span class="op">=</span><span class="kw">lambda</span> n:n <span class="kw">and</span> n<span class="op">*</span>f(n<span class="dv">-1</span>)<span class="kw">or</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="cf">while</span> <span class="dv">1</span>:<span class="bu">print</span>(f(<span class="bu">int</span>(<span class="bu">input</span>())))</a></code></pre></div>
<p>Actually… do we even need a conditional with two branches? If we had an expression <code>g(n)</code> that’s 1 when <code>n</code> is 0 and 0 otherwise, we could just write <code>g(n)or n*f(n-1)</code>. Using <code>not n</code> for that expression almost works, but not quite: it’s <code>True</code> when <code>n</code> is 0, and even though <code>True</code> is equal to 1, it gets printed as “<code>True</code>” when 0 is in the input, which isn’t the correct output. <code>int(not n)</code> would work, but that’s much too long. After some brainstorming, we realize that <code>n&lt;1</code> is shorter than <code>not n</code> and unary plus is shorter than <code>int</code>, so we end up with the following solution, with <strong>59 bytes</strong>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1">f<span class="op">=</span><span class="kw">lambda</span> n:<span class="op">+</span>(n<span class="op">&lt;</span><span class="dv">1</span>)<span class="kw">or</span> n<span class="op">*</span>f(n<span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="cf">while</span> <span class="dv">1</span>:<span class="bu">print</span>(f(<span class="bu">int</span>(<span class="bu">input</span>())))</a></code></pre></div>
<p>Hmm, the fact that the unary <code>+</code> and <code>&lt;</code> don’t have the precedence we want sure is annoying. Is there any way to get rid of those parentheses? There actually is: we can just move the <code>+</code> to <code>f</code>’s call site. This produces a solution with <strong>57 bytes</strong>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1">f<span class="op">=</span><span class="kw">lambda</span> n:n<span class="op">&lt;</span>1or n<span class="op">*</span>f(n<span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="cf">while</span> <span class="dv">1</span>:<span class="bu">print</span>(<span class="op">+</span>f(<span class="bu">int</span>(<span class="bu">input</span>())))</a></code></pre></div>
<p>Whew!</p>
<p>We’ve been golfing off one or two bytes at a time for a while now, so this is a good time to step back and reconsider our entire strategy. Perhaps a recursive function was never the best way to compute a factorial, and we should have used an imperative loop instead? Trying that out, we find a solution that’s… <em>also</em> <strong>57 bytes</strong>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1"><span class="cf">while</span> <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb7-2" title="2"> p<span class="op">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb7-3" title="3"> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">int</span>(<span class="bu">input</span>())):p<span class="op">*=</span>i<span class="op">+</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb7-4" title="4"> <span class="bu">print</span>(p)</a></code></pre></div>
<p>Having to spend three additional bytes on indentation is unfortunate, but it’s necessary to get the nested loop syntactically right.</p>
<p>Is there any other way to compute factorials? Yes: making the standard library do it. It turns out that ever since Python 2.6, the math module has had a <code><a href="https://docs.python.org/3/library/math.html?highlight=factorial#math.factorial">factorial</a></code> built-in. Even though we have to spend a bunch of characters importing it, the result just barely edges out all our solutions so far, coming in at <strong>55 bytes</strong>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1"><span class="im">import</span> math</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="cf">while</span> <span class="dv">1</span>:<span class="bu">print</span>(math.factorial(<span class="bu">int</span>(<span class="bu">input</span>())))</a></code></pre></div>
<p>(You can check for yourself that directly grabbing the <code>math</code> module in an expression with <code>__import__('math')</code> does not help and actually costs 2 extra bytes.)</p>
<p>But actually, if we go back to the imperative loop, we can improve it even more by radically adapting it to apply an even more arcane Python golf trick: looping by repeating a string containing source code and passing it to <code>exec</code>, which is a Python function that just takes a string and executes it as Python source code. (You may be more familiar with <code>exec</code>’s sibling <code>eval</code>; they differ in that <code>exec</code> executes statements and doesn’t return anything, while <code>eval</code> only evaluates expressions but returns the result of the evaluation.) As a bonus, we also pull out the obscure trick that you can <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements">assign</a> the same value to more than one variable with <code>a=b=1</code>. The result of this approach clocks in at… <strong>54 bytes</strong>, a <em>single byte</em> shorter than the standard library solution:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" title="1"><span class="cf">while</span> <span class="dv">1</span>:p<span class="op">=</span>x<span class="op">=</span><span class="dv">1</span><span class="op">;</span><span class="bu">exec</span>(<span class="st">&quot;p*=x;x+=1;&quot;</span><span class="op">*</span><span class="bu">int</span>(<span class="bu">input</span>()))<span class="op">;</span><span class="bu">print</span>(p)</a></code></pre></div>
<p>But <em>actually</em> actually, as of Python 3.8, the math module has a slightly shorter <code><a href="https://docs.python.org/3/library/math.html?highlight=factorial#math.perm">perm</a></code> built-in<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>, which counts <a href="https://en.wikipedia.org/wiki/Permutation#k-permutations_of_n">“partial permutations”</a>, i.e. the value often denoted <span class="math inline">\(_nP_k\)</span> in high school combinatorics textbooks… but <code>perm</code>’s second argument is optional, and if it isn’t passed, this function also computes the factorial of its argument. Which gives us a solution with <strong>51 bytes</strong>! (Although Anarchy Golf’s Python version is too old to accept this solution.)</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" title="1"><span class="im">import</span> math</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="cf">while</span> <span class="dv">1</span>:<span class="bu">print</span>(math.perm(<span class="bu">int</span>(<span class="bu">input</span>())))</a></code></pre></div>
<p>This is the best solution I’m aware of, but it’s possible that there are a few more bytes to be shaved off somewhere, and hopefully it provided an illuminating glimpse into what code golf is like. Sometimes you spend a long time applying local optimizations, slightly rewriting expressions to squeeze out individual bytes. Sometimes you have to throw away your approach and all of your code. Disturbingly often, you completely rewrite your program and produce something one or two bytes off from what you started with, and then you spend a while golfing two or more totally different approaches in parallel, unsure which one will ultimately produce a shorter program after you apply all the local optimizations you can find. Finally, although this pedagogical beat was a bit ruined by <code>math.perm</code>, many well-golfed programs are both incomprehensible and slow. Our <code>exec</code> solution has to create, parse, and execute a length-<span class="math inline">\(10n\)</span> snippet of code anew for each calculation.</p>
<p>Of course, there are a lot of aspects of code golf that I wasn’t able to demonstrate in this short example. Here are just two general categories of tasks a code golfer might encounter in a more difficult challenge:</p>
<ul>
<li><p>Monitoring when it becomes more efficient to extract a repeated constant, function or string into a helper variable. If you call <code>print</code> <span class="math inline">\(n\)</span> times in your Python program, prepending the line <code>p=print</code> and then replacing all those calls with calls to <code>p</code> will save <span class="math inline">\(4n - 8\)</span> bytes, so the replacement is byte-neutral when <span class="math inline">\(n = 2\)</span> and beneficial when <span class="math inline">\(n \geq 3\)</span>. More extremely, if you have a Python program with a lot of lambdas, at some point it becomes more efficient to replace each <code>lambda</code> with some character, say <code>!</code>, and surround it with <code>exec('your code'.replace('!','lambda '))</code>. (You also have to pay an additional cost if your code contains string literals, especially ones with escape sequences, so the math gets complicated quickly.) You can consult some CGCC answers that do the math for <a href="https://codegolf.stackexchange.com/a/61/19857">Python built-ins</a> and <a href="https://codegolf.stackexchange.com/a/97/19857">Python lambdas</a>, though the idea generalizes to other languages.</p>
<p>This might sound simple: you just try each replacement independently, and keep it if it saves bytes. But replacements can interfere with each other and interact with other optimizations in ways that are hard to foresee. For example, maybe your code currently has three <code>print</code> calls, but you found and are contemplating an optimization that combines all three calls into one. That might or might not save bytes compared to putting <code>print</code> in a helper variable. So these optimizations can add some backtracking to what would otherwise be a linear process of slowly golfing off bytes.</p></li>
<li><p>Finding unintuitive but short formulas for things, often by taking advantage of a restricted domain. A very simple example similar to things we saw in the factorial problem: if <code>n</code> is known to be a nonnegative integer, then <code>n&lt;1</code> is shorter than <code>n==0</code>. A more interesting example is the <a href="https://twitter.com/chordbug/status/1374134354864177161">criterion for leap years</a> <span class="math display">\[\text{gcd}(80, y) &gt; \text{gcd}(50, y).\]</span> (Think about it and see if you can understand why it works!) This isn’t often useful in code golf because few languages provide easy access to GCD, and of those that do, many are golflangs in which some alternative strategy is even terser; but it does <a href="https://codegolf.stackexchange.com/a/182535/19857">happen with e.g. Haskell</a><a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>, and I think it’s a cool fact on its own.</p>
<p>Finally, to provide a realistic example from deep inside an actual golf challenge, in a certain <a href="https://blog.h25.io/Advent-of-Golf-2018/">2018 Advent of Code golf contest</a>, I found and used the following formula: if <code>x</code> and <code>y</code> are single uppercase letters from the set {N, E, S, W}, then they represent opposite compass directions iff <span class="math display">\[\text{xor}(\text{ord}(x), \text{ord}(y)) \equiv 7 \bmod 11.\]</span> There’s nothing special about those numbers; it’s just that when the domain of arguments that your formula has to work on is small enough, you can often devise a short formula with small constants, if not by just making tables of the results of a bunch of common mathematical operators, then simply by brute force (see e.g. <a href="https://github.com/lynn/pysearch">pysearch</a><a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>).</p></li>
</ul>
<p>Incidentally, code golf is one metric along which Python 3 is quite a bit worse than Python 2. Our <code>exec</code>-based solution naturally translates to a Python 2 solution with <strong>46 bytes</strong>, even shorter than the <code>math.perm</code> solution:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" title="1"><span class="cf">while</span> <span class="dv">1</span>:p<span class="op">=</span>x<span class="op">=</span><span class="dv">1</span><span class="op">;</span>exec<span class="st">&quot;p*=x;x+=1;&quot;</span><span class="op">*</span><span class="bu">input</span>()<span class="op">;</span><span class="bu">print</span> p</a></code></pre></div>
<p>The differences:</p>
<ul>
<li><code>exec</code> is a statement instead of a function, so you can remove the pair of parentheses used to call it, for −2 bytes.</li>
<li><code>input</code> evaluates its input, so the <code>int()</code> call can be removed entirely for −5 bytes. In Python 2, it’s actually more verbose to read input without evaluating it.</li>
<li><code>print</code> is also a statement instead of a function, but after removing its parentheses, you have to add a space back to separate it from the identifier it’s called with, so this only gives −1 byte.</li>
</ul>
<p>I think these are all good language changes! The more language features that can be implemented as standard built-ins rather than ad hoc syntax, the better. Code golf shouldn’t usually be a consideration when designing a general purpose programming language.</p>
<h3 id="code-golf-sites">Code golf sites</h3>
<p>If the example has inspired you to try code golf yourself, there are three reasonably active code golf websites/communities where I can recommend, each with a fairly distinctive “style”: <a href="http://golf.shinh.org">Anarchy Golf</a>, <a href="https://codegolf.stackexchange.com/">Code Golf and Coding Challenges</a>, and <a href="https://code.golf/">code.golf</a>. (There are many more that I just don’t know enough about to recommend, e.g. <a href="https://codegolf.codidact.com/">Code Golf Codidact</a> or various sites <a href="https://code.golf/wiki/other-sites">linked from code.golf</a>, but they still might be good!) I’ll go over each in turn.</p>
<h4 id="anarchy-golf">Anarchy Golf</h4>
<p><a href="http://golf.shinh.org">Anarchy Golf</a>, occasionally shortened to “anagol”, might just be the longest-running code golf site.<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a> It’s the source of the Factorial problem and some of the solutions for it that we’ve seen. Judging by the first Hello World submission, Anarchy Golf began in January 2007. Its purpose is, by its own admission, “not serious competition”:</p>
<blockquote>
<p>Joke problems are welcomed and you can speak freely about problems and can release spoilers.</p>
</blockquote>
<p>Anarchy Golf is quite old school in the way its challenges work: all programs read from standard input and are expected to output to standard output. Also, Anarchy Golf challenges can have only three test cases, so it’s more common for optimal solutions to take advantage of the exact test cases, or even ignore the inputs entirely — in fact, this is sometimes required, with I think the simplest example being <a href="http://golf.shinh.org/p.rb?123">123</a>. The site is very simple — it doesn’t even have logins or any kind of authentication; you simply write your name every time you submit a program, and that’s the name your program will go in the leaderboard under. But it works and its simplicity probably contributes to its incredible longevity. I participated a bunch in Anarchy Golf in 2010, though I don’t have any of my files from then and don’t see a particularly good way to look up my submissions. Also, I was really bad at golf in 2010.</p>
<figure>
<a href="/img/anagol-leaderboard.png"><img src="/img/anagol-leaderboard.png" alt="An Anarchy Golf leaderboard showing betaveros in last place with a 3-character program, while nearly every other submission has length 1." /></a>
<figcaption>
Apparently 2010 me could not find the single-character GolfScript program to solve <a href="http://golf.shinh.org/p.rb?sort+characters#GolfScript">this challenge</a> and instead submitted something 200% longer</a>
</figure>
<p>Anarchy Golf challenges can either be “endless” or have a deadline. Solutions to endless challenges are never revealed (they’re not even saved by the site). For challenges with a deadline, each user’s best submitted solution becomes public afterwards, although you can still keep submitting solutions after the deadline; they’ll just be indicated as such by appearing in red.</p>
<h4 id="code-golf-stack-exchange">Code Golf Stack Exchange</h4>
<p>The <a href="https://codegolf.stackexchange.com/">Code Golf and Coding Challenges</a> (CGCC)<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a> StackExchange began in January 2011.<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a> It’s an atypical StackExchange that isn’t really used for questions and answers per se; instead, CGCC users post challenges as “questions” and programs that solve the challenges as “answers”. Although code golf isn’t the only kind of programming challenge that fits this community’s bill, it is by far the most popular, at least in terms of day-to-day activity. There’s a <a href="https://codegolf.meta.stackexchange.com/questions/23834/cgcc-blog-post-2-the-history-of-ppcg-and-cgcc">blog post on the SE’s meta exchange</a> with a pretty good rundown of the site’s history, including its “multiple cultural shifts” and drastic changes, which I won’t rehash; in brief, although the site encompassed many kinds of coding challenges for many years, surges of low-quality activity related to subjective challenge types led to a community consensus that questions/challenges should have an “objective scoring criterion”, and “shortest code” is one of the most versatile criteria that challenges can be posed for.</p>
<p>Interestingly, you’d get a drastically different sense of the community if you looked at, say, the top questions by score. Of the all-time top ten, only three are code golf–related. (The top question asks for an <a href="https://codegolf.stackexchange.com/questions/11880/build-a-working-game-of-tetris-in-conways-game-of-life">implementation of Tetris in Conway’s Game of Life</a> — and received one, a joint effort from ten contributors over 1½ years. Other cool feats include a program for <a href="https://codegolf.stackexchange.com/a/22326">generating cool images with all colors</a>, which would probably no longer fly under the “objective scoring criterion” rule, and an <a href="https://codegolf.stackexchange.com/a/236630">extremely optimized implementation of FizzBuzz</a>.)</p>
<p>The biggest differentiator of CGCC among code golf sites is that, because submissions are judged by the community through votes rather than by an automated system that would need to explicitly support the submitted program’s language, you can golf in any programming language you want.<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a> And people do! The result is substantially more representation from golflangs and even non-golf esoteric programming languages among submitted solutions, as well as just in the culture at large. This aspect of the site has been contentious for some time, with users <a href="https://codegolf.meta.stackexchange.com/questions/10127/how-can-we-help-users-who-are-put-off-by-the-use-of-golfing-languages">semiregularly expressing</a> that golflangs <a href="https://codegolf.meta.stackexchange.com/questions/286/j-and-golfscript-suck-all-the-enjoyment-out-of-code-golf">make code golf less fun</a> because non-golf languages have no shot at winning, i.e., producing the shortest possible solution. A popular response is that programs in different languages shouldn’t be considered to be competing with each other in this way; programs should be upvoted based on perceived cleverness, with sheer byte count only being used to compare submissions in the same language. In particular, a golf language submission that’s short due to the challenge being a good match for the language built-ins, rather than algorithmic cleverness, shouldn’t be (excessively) upvoted. I have sympathy for both sides, but, as you can probably tell from this post, I tend to gravitate towards the latter just because I think golflangs are very neat.</p>
<p>Another point worth mentioning is that CGCC challenges often simply ask you to “define a function” that accomplishes a task, rather than worrying about input and output or string parsing and formatting. Often, challenges will go as far as explicitly offering flexibility to choose the most convenient input/output format for your language to work with, which tends to even the playing field a bit for programming languages (as we saw above, some programming languages require much more boilerplate than others just to read and print an integer). Another side effect is that golflangs designed by CGCC users sometimes don’t even bother to have any facilities for handling input/output.</p>
<p>Finally, because of the Q&amp;A nature of the underlying site, solutions on CGCC are public from the moment they’re submitted. Discussing solutions, suggesting small optimizations in comments, and collaborating in other ways are all common and encouraged.</p>
<h4 id="code.golf">code.golf</h4>
<p>The last site on my list, <a href="https://code.golf/">code.golf</a>, is also the most modern. It has a pretty front page, automated judgment, lots of statistics and achievements, and an active Discord server. Based on the first commit on the <a href="https://github.com/code-golf/code-golf">GitHub repo</a>, code.golf first came into existence October 2016.</p>
<p>I actually struggle to write a lot about this website; despite being much newer than the other two sites, it fits my “default” conception of how a code golf site should look and work the best. Unlike Anarchy Golf, you can make an account and log in! The website has a decent in-browser code editor and even saves your shortest solutions for each challenge in each language, so you can do a lot of golfing without leaving your browser.</p>
<p>Input and output for challenges on code.golf also work a bit differently from either of the above sites; programs receive input from command line arguments instead of stdin, which usually means slightly less code is required to parse input. (One exception is that the site supports GolfScript, a golflang we’ll discuss very soon, by putting the arguments directly on its “stack”.)</p>
<p>Another special aspect of code.golf is that it has separate leaderboards for golfing the number of bytes and the number of characters. As a result, among code golf sites, “packers” are uniquely relevant on code.golf.<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a> A “packer” is a technique for “compressing” a (typically ASCII) string as a string with more bytes but fewer characters, such that the string can be tersely decompressed and then used in the program, typically by being <code>eval</code>ed. The site’s guides include many packers for different programming languages, and its users are developing more all the time.</p>
<p>Finally, unlike the other two sites, code.golf solutions are never revealed, although sometimes golfers exchange tips in the associated Discord server, and adding challenges for which solutions are revealed after some set amount of time <i>a la</i> Anarchy Golf have been proposed in the past.</p>
<h3 id="how-to-design-a-golflang">How to design a golflang</h3>
<p>Writing short programs is cool and all, but some code golf enthusiasts had an idea to push the frontier of the sport even further: what if you designed a programming language for code golf? What if you took all the tradeoffs code golfers make in pursuit of shorter code — sacrificing simplicity, legibility, maintainability, robustness, performance — and introduced them <em>into the language design process</em>?</p>
<p>As a preview, here’s a solution to the factorial problem from the first section, written in what is almost certainly the first golflang, GolfScript. It’s <strong>14 bytes</strong>:</p>
<pre><code>~]{,1\{)*}/n}/</code></pre>
<p>It’s easier to explain how this program works after we’ve encountered some more general golflang concepts, so I’ve <a href="#appendix-golfscript-factorial-breakdown">deferred an explanation to an appendix</a>. GolfScript was first created in 2007 and, though it still usually beats non-golflangs, it is also usually far surpassed by more modern golflangs. (You can see for youself that the shortest program on Anarchy Golf’s Factorial page is <strong>2 bytes</strong>.)</p>
<p>Also before we continue discussing this, a disclaimer: it’s entirely reasonable to play code golf without learning or thinking about any golflangs (much less designing or implementing one), and some golfers think golflangs make the code golf less fun. For example, some of the fun from golfing in a “real programming language” comes from the transgressiveness of doing things you’re “not supposed to do” in pursuit of shorter code (like using string repetition and <code>exec</code> to loop), whereas golfing in a golflang is often just using it as designed. Also, golfing in a language often teaches you obscure facts about it, which tend to be more interesting or relevant if you also use the language in non-golf contexts (here’s one blog post about <a href="http://lbrandy.com/blog/2008/09/what-code-golf-taught-me-about-python/">what code golf taught the author about Python</a>). On the other hand, one might argue that golfing in a well-designed golflang strips away concerns about “trivia” like the lengths of names your programming language happens to give various operations (see GolfScript’s author <a href="http://www.golfscript.com/nibbles/why.html">discuss this</a> with reference to his newer golflang, Nibbles), and lets you focus on the purer challenge of finding the “simplest” algorithm to solve a problem. And personally, I just think programming language design is fun.</p>
<p>Anyway: let’s look at the last two factorial programs we came up with, which I’ve reproduced below, and think about how Python prevents us from making either much shorter.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb13-1" title="1"><span class="cf">while</span> <span class="dv">1</span>:p<span class="op">=</span>x<span class="op">=</span><span class="dv">1</span><span class="op">;</span><span class="bu">exec</span>(<span class="st">&quot;p*=x;x+=1;&quot;</span><span class="op">*</span><span class="bu">int</span>(<span class="bu">input</span>()))<span class="op">;</span><span class="bu">print</span>(p)</a></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb14-1" title="1"><span class="im">import</span> math</a>
<a class="sourceLine" id="cb14-2" title="2"><span class="cf">while</span> <span class="dv">1</span>:<span class="bu">print</span>(math.perm(<span class="bu">int</span>(<span class="bu">input</span>())))</a></code></pre></div>
<p>An obvious one is names and tokenization: Python has many keywords and built-ins that are long (by code golf standards), like <code>while</code>, <code>input</code>, and <code>print</code>; plus it often forces you to separate them from adjacent keywords, identifiers, or literals with spaces. Python also doesn’t have that many built-ins that are immediately accessible. If <code>perm</code> were a default built-in rather than in the <code>math</code> module, we could delete the import from our standard library solution and immediately get a 33-byte solution.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb15-1" title="1"><span class="cf">while</span> <span class="dv">1</span>:<span class="bu">print</span>(perm(<span class="bu">int</span>(<span class="bu">input</span>())))</a></code></pre></div>
<p>There are many languages that aren’t usually much terser than Python, but do better on this problem just because they happen to have easily accessible built-ins that are a good fit. For example, Haskell has a <a href="http://golf.shinh.org/reveal.rb?Factorial/notogawa_1195219722&amp;hs">41-byte solution</a> because it comes with <code>product</code> and the inclusive range syntax <code>[1..n]</code>. More starkly, Common Lisp, which is normally not that competitive, has a <a href="http://golf.shinh.org/reveal.rb?Factorial/kozima_1195135047&amp;l">30-byte solution</a> because it (specifically CLisp) has <a href="https://clisp.sourceforge.io/impnotes/num-concepts.html#int-func-ext"><code>!</code>, a single-character factorial builtin</a> (!). You could imagine designing a golflang that’s basically Python, but with single-character names for all its keywords and built-ins, and it would be reasonably effective. (If you travel down that path far enough, you might get something similar to <a href="https://github.com/isaacg1/pyth">Pyth</a>.) And in general, one easy way to make your programming language better at golf is just to add lots of single-character built-ins.</p>
<p>If you do this naively, though, you’ll quickly run out of printable ASCII characters to allocate, which is why golflangs also often use heavy <em>overloading</em>: having a built-in function or operator behave in more than one way depending on how it’s used. Most programmers are used to some overloading, like how <code>+</code> might either add numbers or concatenate strings/lists, or how <code>*</code> might either multiply numbers or repeat a string/list some number of times, but golflangs typically take this much further. For example, GolfScript overloads <code>*</code> in three more ways: it can be used to repeat a “block” (approximately, call a function) some number of times, join a string/list by another string/list, or fold a list with a function. Many modern golflangs also use a custom character encoding that’s more compact than ASCII/UTF-8 to maximize the number of built-ins they can offer, most simply through a custom <a href="https://en.wikipedia.org/wiki/Code_page">code page</a> that assigns a character to each of the 256 possible bytes.</p>
<p>A lot could be written about choosing built-ins for your golflang, but I don’t think it’s a particularly “deep” subject, or at least, I lack the insight to systematize it, so I’ll just make some brief observations.</p>
<ul>
<li>Most golflangs will benefit from a lot of built-ins that perform basic “data manipulation” tasks that just involve receiving and outputting numbers/strings/lists, from “repeat a string some number of times” to “list all prime factors of an integer”; but it’s also important to have common <a href="https://en.wikipedia.org/wiki/Higher-order_function">higher-order functions</a>, from map, filter, and reduce to “find the fixed point of iterating this function” or “group the items in this list into buckets based on what this function maps them to”, which are often useful for composing your data manipulation built-ins.</li>
<li>When most of your names are single characters, there is quite an art in choosing and overloading names for built-ins that don’t overlap while making as much sense as possible. (Just because we’re prioritizing brevity over usability doesn’t mean we should completely disregard the latter.) For example, because <code>$</code> looks like an S, GolfScript overloads it to either access the “Stack” or to “Sort” a list. If you want to make good use of the entire alphabet or code page of your choice, you sometimes have to get creative with mnemonics — when naming things for my own language, <a href="https://github.com/betaveros/paradoc">Paradoc</a>, I decided that <code>Ã</code> took the m<strong>a</strong>ximum/l<strong>a</strong>rger of two values and <code>Õ</code> took the minimum/sm<strong>o</strong>ller. Or you can give up and assign some names arbitrarily. Another way to get around this is to develop a language that’s more verbose, but easier to read and write, and a compiler/transpiler from that language to a terser one.</li>
</ul>
<p>A different source of verbosity is most languages’ need for grouping, typically with parentheses. We saw this briefly in our worked Python example, where we had to add parentheses to the expression <code>+(n&lt;1)</code>, because <code>+n&lt;1</code> would be parsed as <code>(+n)&lt;1</code>. We later found a way to omit them, but it’s not always possible, and when you are forced to use parentheses or similar delimiters to specify the precedence or grouping of various expressions, you can waste a lot of bytes. However, there are pretty standard ways around this. If your language uses either <a href="https://en.wikipedia.org/wiki/Polish_notation">prefix notation</a>, where operators always precede their operands, or <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">postfix notation</a>, where operators always follow their operands, then the order of operators and operands suffices to imply all grouping. For example, an expression like <code>(x+y)*z</code> would be <code>* + x y z</code> in prefix notation and <code>x y + z *</code> in postfix notation, whereas <code>x+(y*z)</code> would be <code>+ x * y z</code> in prefix notation and <code>x y z * +</code> in postfix notation. I won’t go into this more here since the Wikipedia articles have more detailed examples and these will naturally come up again later.</p>
<p>But let’s say we have a language that uses heavily-overloaded single bytes to represent all these keywords and built-ins, as well as either prefix or postfix notation to eliminate the need for most delimiters. There would remain, I think, one more subtle and particularly interesting source of byte inefficiency: we have to <em>name our variables</em>. In our <code>exec</code>-based Python solution, we used the variable names <code>p</code> and <code>x</code> each three times, i.e. we spent six bytes referring to variables. We can tell that there is definitely some redundancy here because those variable names could been replaced with any two distinct letters and the program would still work. By comparison, observe that the <code>math.factorial</code> and <code>math.perm</code> solutions do not name any argument or variable — both are just four functions, each one passing its return value to the next. Wouldn’t it be nice if we could write more code that way?</p>
<h3 id="how-to-avoid-variable-names">How to avoid variable names</h3>
<p>The term for this style of programming is <a href="https://en.wikipedia.org/wiki/Tacit_programming">tacit programming</a>: instead of naming your arguments, just compose functions in a way that implicitly defines how data flows in and out of them.</p>
<p>To put this into focus, let’s consider two trivial arithmetic tasks and how we might implement them in various languages:</p>
<ol type="1">
<li>Read an integer <span class="math inline">\(n\)</span> and output <span class="math inline">\(n^3 + 6\)</span>.</li>
<li>Read an integer <span class="math inline">\(n\)</span> and output <span class="math inline">\(n^3 + n\)</span>.</li>
</ol>
<p>(We’ll assume that the entirety of standard input just has the single integer, to smooth over differences between languages as much as possible. There isn’t any significance to 3 and 6, except that if they were smaller, some languages might allow some trivial optimizations that would distract us.) Task 1 is very easy in Python. This is 24 bytes:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb16-1" title="1"><span class="bu">print</span>(<span class="bu">int</span>(<span class="bu">input</span>())<span class="op">**</span><span class="dv">3</span><span class="op">+</span><span class="dv">6</span>)</a></code></pre></div>
<p>Despite being almost identical, Task 2 takes 4 extra bytes, because Python doesn’t have a neat way to read <span class="math inline">\(n\)</span> and then use it twice in an expression. We just have to go through an explicitly declared variable, which costs a lot of extra bytes.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb17-1" title="1">n<span class="op">=</span><span class="bu">int</span>(<span class="bu">input</span>())<span class="op">;</span><span class="bu">print</span>(n<span class="op">**</span><span class="dv">3</span><span class="op">+</span>n)</a></code></pre></div>
<p>The goal of tacit programming here, then, is to express the function that maps <span class="math inline">\(n \mapsto n^3 + n\)</span> without giving <span class="math inline">\(n\)</span> a name: to directly describe this composition of exponentiation, addition, and the constant 3 without identifying the parameter they apply to. I’ll cover three major approaches to doing this.</p>
<h4 id="stack-based-programming-languages">Stack-Based Programming Languages</h4>
<p>Roughly, <em>stack-based programming languages</em> like Forth and GolfScript work as follows: at all times during the program’s execution, there’s a global “data stack” holding various objects, and when a function is called, it usually pops some number of objects from the stack, performs some computation on them, and then pushes the result back onto the stack. Thus, each function’s arguments are implicitly “the top K elements of the stack when the function is called”, so those operands don’t need to be named. (This is also a very natural way to implement postfix notation, which also allows stack-based languages to avoid the need for grouping delimiters.)</p>
<p>In GolfScript, task 1 takes <strong>5 bytes</strong>:</p>
<pre><code>~3?6+</code></pre>
<p>For this problem as described, GolfScript has a huge golf advantage in that it does implicit input and output. Specifically, when a GolfScript program starts, the entirety of standard input is read and put onto the stack, and when it ends, whatever contents remain on the stack are printed. (While convenient for the vast majority of golf challenges, this means that you can’t write interactive programs in GolfScript.) The step-by-step breakdown of this program is:</p>
<ul>
<li>(Implicit input: the contents of stdin are placed on the stack as a string.)</li>
<li><code>~</code> evaluates that string, converting it to an integer; call it <span class="math inline">\(n\)</span>.</li>
<li><code>3</code> pushes the integer 3 onto the stack, above <span class="math inline">\(n\)</span>.</li>
<li><code>?</code> performs exponentiation: it pops two integers (for us, 3 and then <span class="math inline">\(n\)</span>), raises the bottom integer to the power of the top integer, and pushes it back onto the stack.</li>
<li><code>6</code> pushes the integer 6 onto the stack, above <span class="math inline">\(n^3\)</span>.</li>
<li><code>+</code> pops two integers (for us, <span class="math inline">\(n^3\)</span> and 6) and pushes their sum.</li>
<li>(Implicit output: the contents of the stack are automatically printed.)</li>
</ul>
<p>Task 2 also only takes <strong>5 bytes</strong>:</p>
<pre><code>~.3?+</code></pre>
<ul>
<li>As before, input is implicitly read and then evaluated with <code>~</code>.</li>
<li>The key new built-in is <code>.</code>, which duplicates the top element of the stack, so now the stack comprises two copies of the input integer.</li>
<li>As before, <code>3</code> and <code>?</code> cube the top integer, but they don’t affect the lower number in the stack, so now the stack has <span class="math inline">\(n^3\)</span> on top of <span class="math inline">\(n\)</span>.</li>
<li>As before, <code>+</code> sums the top two integers.</li>
<li>Finally, the program ends and prints that sum because it’s still on the stack.</li>
</ul>
<p>The stack obviates the need to name variables; instead, variables can be “identified” by their position in the stack, and being able to duplicate values on the stack means that inputs to a computation can be used in multiple places. Still, when you need to juggle a lot of inputs or intermediate values in a computation, the stack-based approach can quickly become annoying because manipulating elements that are buried under a few others in the stack is often difficult. Figuring out the optimal order in which to keep your data on the stack is one important part of golfing GolfScript programs. (GolfScript also does let you assign to variables with <code>:</code>; this is usually more verbose than alternatives, but it can be useful.)</p>
<h4 id="functional-programming-languages">Functional Programming Languages</h4>
<p>In functional golflangs, functions take arguments and produce return values as is more typical. Tacit data flow is enabled just by providing lots of higher-order functions (functions that take other functions as arguments) that combine functions in the exact way you want.</p>
<p>As a baseline to see how this might work in a non-golf language, let’s look at a tacit solution to Task 2 in Haskell:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1">main<span class="ot">=</span>interact<span class="op">$</span>show<span class="op">.</span>((<span class="op">^</span><span class="dv">3</span>)<span class="op">&gt;&gt;=</span>(<span class="op">+</span>))<span class="op">.</span><span class="fu">read</span></a></code></pre></div>
<p>The important part is just <code>(^3)&gt;&gt;=(+)</code>; everything outside is just formalities for handling input/output. <code>^3</code> is exponentiation partially applied<a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a> with a right argument of 3, so <code>(^3)</code> is a function that cubes something; and <code>+</code> is, naturally, addition. Most interestingly, <code>&gt;&gt;=</code> is “bind” of monad fame, which we are using here in the function monad, sometimes also called the reader monad; it’s the crucial higher-order function that lets us feed our input into two subcomputations. Without getting into the weeds too much, this instantiation of <code>&gt;&gt;=</code> takes two functions <code>f</code> and <code>g</code> and produces the function <code>\x -&gt; g x (f x)</code> , which roughly translates as e.g. <code>lambda x: g(x, f(x))</code> in Python. Here, because <code>g</code> is addition and <code>f</code> is the cubing function we got from partial application, the part we singled out is a function that takes an integer <span class="math inline">\(n\)</span> and outputs <span class="math inline">\(n^3 + n\)</span>, exactly as desired; and it doesn’t name <span class="math inline">\(n\)</span> explicitly!</p>
<p>Unfortunately, due to the need for parentheses and the length of the <code>&gt;&gt;=</code> operator, this Haskell solution is slightly longer than it would be if we just wrote a lambda:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1">main<span class="ot">=</span>interact<span class="op">$</span>show<span class="op">.</span>(\x<span class="ot">-&gt;</span>x<span class="op">^</span><span class="dv">3</span><span class="op">+</span>x)<span class="op">.</span><span class="fu">read</span></a></code></pre></div>
<p>Still, it illustrates how a golfing languages might achieve the same effect. In the functional golfing language <a href="https://github.com/barbuz/Husk">Husk</a>, the analogue of <code>&gt;&gt;=</code> is just called <code>S</code> (with flipped arguments); and because Husk uses prefix notation for everything, we don’t need parentheses, so the same function actually be written with only <strong>4 bytes</strong>:</p>
<pre><code>S+^3</code></pre>
<p>This is also a full Husk program that can be run, but this byte count is not technically directly comparable with our other programs since Husk always receives input from command-line arguments; it has no way to read from stdin.</p>
<h3 id="apl-like-programming-languages">APL-Like Programming Languages</h3>
<p>Finally, let’s look at <a href="https://en.wikipedia.org/wiki/APL_%28programming_language%29">APL</a> and its descendants. This might be argued to be a variant of the functional golfing language approach, but instead of using explicit combinators to express data flow, APL-style languages rely more on syntax and the arrangement of component functions and operands. The line is blurry, but I think in practice this approach is distinctive and popular enough to deserve its own section.</p>
<p>Here’s a solution in J to Task 2 in <strong>19 bytes</strong>:</p>
<pre><code>(+^&amp;3)&amp;.&quot;.&amp;.stdin&#39;&#39;</code></pre>
<p>J is <em>not</em>, by my definition, a golflang — it is designed to be good for serious mathematical and statistical data analysis. It is, however, (in)famously terse, and has been a popular language for golfing since before GolfScript existed. As in the Haskell example, most of this program deals with input and output; the function <span class="math inline">\(n \mapsto n^3 + n\)</span> is simply the part in the parentheses, <code>+^&amp;3</code>. That’s also four bytes!</p>
<p>How it works:</p>
<ul>
<li>Of the four characters, <code>&amp;</code> is what J calls a “conjunction” and has the highest precedence. It performs a partial application on <code>^</code> (exponentiation) and <code>3</code> to produce a function (or “verb”, in J terminology) that takes a single argument and cubes it, much like in the Haskell example.</li>
<li><code>+</code> is also a verb, and performs addition.</li>
<li>The interesting thing is when the two verbs <code>+</code> and <code>^&amp;3</code> are juxtaposed with no other operands. This forms a syntactic construct called a “<a href="https://www.jsoftware.com/help/primer/hook.htm">hook</a>”. When this hook is then called with a single argument <span class="math inline">\(n\)</span>, it calls the right verb <code>^&amp;3</code> with <span class="math inline">\(n\)</span> as its only argument, and then calls the left verb <code>+</code> with <span class="math inline">\(n\)</span> as its first argument and the result of calling the right verb as its second argument. Thus, this hook implements the formula in Task 2 exactly.</li>
</ul>
<p>Interestingly, this J solution is actually one byte shorter than the closest J solution to Task 1! That solution builds a “<a href="https://www.jsoftware.com/help/primer/fork.htm">fork</a>”<a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a> from these three components: the noun <code>6</code>, the verb <code>+</code>, and the same partially-applied verb <code>^&amp;3</code> as before; I won’t break it down here, but the idea is very similar.</p>
<pre><code>(6+^&amp;3)&amp;.&quot;.&amp;.stdin&#39;&#39;</code></pre>
<p>In J, most verbs are overloaded so that you can call them with either one argument (“monadically”) or two arguments (“dyadically”), and they’ll perform different, but usually related, behaviors. For example, we’ve seen that dyadic <code>^</code> performs exponentiation; monadic <code>^</code> computes the exponential function, raising <span class="math inline">\(e\)</span> to the power of the sole argument. How many arguments a verb receives depends on the syntax surrounding its call. You can combine verbs into hooks and forks, and even longer “trains” thereof, just by juxtaposing them.</p>
<p>To see this approach taken even further, let’s look at Jelly, probably the most established APL-style golflang. The Jelly program that directly competes with our Husk example, i.e. that defines a function without worrying about input/output, is only <strong>3 bytes</strong>:</p>
<pre><code>*3+</code></pre>
<p>(In Jelly, <code>*</code> is exponentiation; <code>×</code> is multiplication. You can’t tell from this example, but Jelly relies heavily on a <a href="https://github.com/DennisMitchell/jellylanguage/wiki/Code-page">completely custom code page</a>.) How it works:</p>
<ul>
<li>Because we’re calling this with a single argument <span class="math inline">\(n\)</span>, we evaluate the three characters as a <a href="https://github.com/DennisMitchell/jellylanguage/wiki/Tutorial#42monadic-chains">“monadic chain”</a> of three “atoms” on <span class="math inline">\(n\)</span>, and track an accumulator <span class="math inline">\(v := n\)</span>.</li>
<li>Looking at the first two atoms in the chain: <code>*</code> is “dyadic” and <code>3</code> is “niladic”, which matches the <code>+ 1</code> pattern, so we update <span class="math inline">\(v := v^3\)</span>.</li>
<li>There’s only one atom left, which matches the <code>+</code> pattern, so we update <span class="math inline">\(v := v + n\)</span>.</li>
<li>Now we’re done and have calculated <span class="math inline">\(v = n^3 + n\)</span>. Hooray!</li>
</ul>
<p>One important difference between Jelly and APL/J is that Jelly does <em>not</em> overload its built-ins by number of arguments, or arity. <code>*</code>, for example, is always dyadic, and when you invoke (the analogue of) a function you previously defined, the arity is specified in the invocation itself rather than the surrounding syntax. This allows the syntax rules to take into account the arities of each atom when deciding how they should compose.</p>
<p>Also, unlike Husk, Jelly does have standard input facilities, and a single extra byte is enough to make it read from standard input and output to standard output:</p>
<pre><code>Ɠ*3+</code></pre>
<p>The point is that in these languages, the complicated ways in which data flows through functions are shunted into the language syntax (J’s hooks and forks, Jelly’s rules for how sequenced nilads/monads/dyads are evaluated) rather than into built-ins you explicitly invoke.</p>
<p>However, one key assumption that allows these syntactic rules to be so expressive that in these APL-likes, all functions take <strong>at most two parameters</strong>. You literally can’t define a “function that takes three or more parameters” in these languages. (Of course, it’s always possible to implement “equivalent” versions that have only one or two parameters by saying that you have to bundle up a bunch of arguments into a list and pass that as a single argument.) I thought this was a critical limitation at first, but after mulling it over more I found that operations that “naturally” take more than two parameters, that can’t be decomposed into reasonable two-parameter functions, are surprisingly rare. Simple examples include:</p>
<ul>
<li>String substitution: in string X, replace Y with Z.</li>
<li>String padding: pad a string X to width at least Y with character Z.</li>
<li>Dictionary update: given a dictionary D, set <code>D[X] = Y</code>.</li>
</ul>
<p>And… that’s actually all I was able think of. (There are a lot of very complicated functions that might make the most sense with a lot of arguments, like “make an HTTP request”, but they’re rare in code golf challenges.)</p>
<p>Furthermore, I’m being a bit loose with terminology here: the two-parameter restriction concerns only non-higher-order functions, what J calls “verbs” and Jelly calls “links”. All of these APL descendants have syntax for modifying a function into a new function that can then be called with up to two parameters. Although a functional programmer might want to describe such a “function modifier” as a three-parameter function, it is expressible in APLs; it’s just that “functions” are fundamentally different from these “function modifiers” in these languages’ semantics. (APL calls them “operators”; J calls these “adverbs” and “conjunctions”; Jelly calls them “quicks”.<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a>)</p>
<h4 id="summary-of-approaches-to-tacit-programming">Summary of approaches to tacit programming</h4>
<ul>
<li>In stack-based programming languages, nearly all data is stored and manipulated in a global data stack, so data can be implicitly identified by its location in the stack. These languages are most effective at manipulating data on top of the stack, and can theoretically work with arbitrarily many data items as long as there’s some built-in to access lower parts of the stack, but may require substantial additional code for “stack juggling” if the data flow graph has a lot of parallel pieces.</li>
<li>In functional programming languages, programmers use explicit combinators to specify how data flows in and out of built-in functions. This can versatilely handle a lot of data flow graphs, but may require the language to provide many different explicit combinators.</li>
<li>In APL-style programming languages, programmers arrange built-in functions into syntactic constructs specified by the language in order to control how data flows through them. In order to make these languages’ syntax expressive, they tend to distinguish functions and data more rigidly and restrict how many parameters a function can have.</li>
</ul>
<p>This is not an exclusive or exhaustive trichotomy; many languages blend ideas from these approaches or are hard to classify. For example, Jelly has what might be described as a stack-based language atop its APL-style links that I haven’t discussed. Pyth doesn’t provide tacit programming exactly as I’ve described it, but is still an effective golflang because it has a lot of magic variables that are automatically initialized or implicitly named/manipulated by various control flow constructs.</p>
<h3 id="a-short-survey-of-golflangs">A short survey of golflangs</h3>
<p>Having discussed some general principles about how golflangs typically work, let’s look more closely at specific golflangs and how they evolved, both to help orient readers if they encounter some of the popular ones “in the wild”, and simply to appreciate the variety of ideas and approaches people have taken.</p>
<p>As we’ve already encountered, <a href="http://www.golfscript.com/golfscript/">GolfScript</a> (Darren Smith, 2007), a stack-based golflang, is probably the first language designed primarily for code golfing. I think GolfScript has held up remarkably well as a introductory code golf language, though it’s clear that it was not optimized as relentlessly for golf as its successors: for example, it supports arbitrarily long alphanumeric identifiers, and it gives a bunch of its built-ins names that are as long as five letters: <code>print</code>, <code>while</code>, and <code>until</code>. Later programming languages have pulled fairly intense tricks to optimize the byte counts of their programs, but those tricks have also made them that much harder to learn and use.</p>
<p>We’ve already discussed how stack-based programming languages work abstractly and touched on GolfScript’s built-ins, so the main other thing I think is worth touching on is how GolfScript supports higher-order functions by having “blocks” of code be first-class objects that can be pushed on the stack in its data model. When code is written in curly brackets, which can nest, it gets pushed onto the stack as a block like everything else; then, when a built-in pops some data items from the stack and sees that one of them is a block, it typically performs some higher-order function. For example, in our GolfScript factorial solution, almost no computation technically happens until the final character:</p>
<pre><code>~]{,1\{)*}/n}/</code></pre>
<p>When the code <code>{,1\{)*}/n}</code> is executed, all it does is push a code block onto the stack. The ending <code>/</code> is what pops that code block and runs it, once per input.</p>
<p>GolfScript spawned several descendant golflangs that are also stack-based. I think the most immediate one that’s somewhat notable is <a href="https://esolangs.org/wiki/FlogScript">FlogScript</a> (Zzo38, 2008), although maybe it’s not actually that similar?</p>
<blockquote>
<p>[FlogScript is] similar to GolfScript but it is different. No documentation yet, read the examples and source code to try to figure it out.</p>
</blockquote>
<p>It would take a few years after GolfScript for golflang design to really take off as a hobby, but take off it did. <a href="https://github.com/nooodl/gs2">gs2</a> (nooodl/maurisvh, 2013?) and <a href="https://sourceforge.net/p/cjam/wiki/Home/">CJam</a> (aditsu, 2014) are descendants of GolfScript that stay closer to it; <a href="https://github.com/isaacg1/pyth">Pyth</a> (isaacg, 2014) is based on Python and uses prefix notation. CGCC comparisons of the latter two and GolfScript from their era suggest that it’s <a href="https://codegolf.stackexchange.com/questions/54385/golfscript-cjam-or-pyth">complicated but Pyth has the advantage</a>, while gs2 holds the top rank on Anarchy Golf to this day.</p>
<p>I believe the next two most notable golflangs after those two are <a href="https://esolangs.org/wiki/05AB1E">05AB1E</a> (Adnan, 2015) and <a href="https://github.com/DennisMitchell/jellylanguage">Jelly</a> (DennisMitchell, 2015). 05AB1E is not directly related to GolfScript, but it’s also stack-based and has 400+ built-ins; also, instead of having functions exist on the stack, it supports higher-order functions through special syntax where you write code inside certain delimiters, which does tend to be more concise at the cost of complicating the syntax relative to the built-ins. Jelly, as we’ve already seen, is inspired by J/APL. We’ve briefly looked at how atoms compose chains and are consumed based on specific rules concerning their arities; atop that, Jelly provides one roughly stack-based layer of grouping/manipulation for building a chain of chains, called a link, followed by ways for links to refer to other links.</p>
<p>But then, there is a really long tail of other golflangs that are varying degrees of less well-known, the vast majority of which arose from the CGCC community. (As far as I’m aware, nobody other than me has programmed in the golflang I wrote, <a href="https://github.com/betaveros/paradoc">Paradoc</a>. This is unremarkable because I myself tend to forget about it eleven months out of twelve.) One well-researched CGCC meta answer found and computed <a href="https://codegolf.meta.stackexchange.com/a/8891">Elo ratings for a few hundred languages</a>; a small handful of these, selected subjectively by myself based on a combination of diversity and popularity:</p>
<ul>
<li><a href="https://github.com/JCumin/Brachylog">Brachylog</a>, a declarative logic programming language, is based on Prolog.</li>
<li><a href="https://github.com/barbuz/Husk">Husk</a>, which we’ve already seen, is based on Haskell.</li>
<li><a href="https://github.com/lmendo/MATL">MATL</a> is based on MATLAB. It’s mainly stack-based but has some vaguely APL-style “meta-functions”.</li>
<li><a href="https://github.com/Mego/Seriously">Seriously</a>, also referred to as Actually as of v2.0, is also stack-based and has the gimmick that “all strings are valid programs”.</li>
<li><a href="https://github.com/Vyxal/Vyxal">Vyxal</a> is also primarily stack-based, but also has more familiar features like variables, functions, and control flow, and keeps them easily accessible.</li>
</ul>
<p>(The <em>worst</em> golfing language on the list, which amusingly also has the longest name, is <a href="https://en.wikipedia.org/wiki/Shakespeare_Programming_Language">Shakespeare Programming Language</a>.)</p>
<p>Finally, a language that’s so new that it doesn’t make that particular list, but that I’m compelled to mention due to its philosophy: <a href="http://www.golfscript.com/nibbles/">Nibbles</a> (2021), by the creator of GolfScript, is a golflang that resists the urge to just keep adding built-in functions while still trying to be competitive (pretty effectively). The flagship feature is a “literate form” that can be compiled into a “binary form” where most characters correspond to single nibbles (half bytes). I think Nibbles is best characterized as a functional golflang, but it has a lot of really interesting choices; for example, built-ins have fixed arities that are used to determine the “parse tree”, but after parsing, expressions can be treated as functions of any arity depending on the context.</p>
<h3 id="further-reading">Further reading</h3>
<p>There is a lot of overlap between code golf and the “esoteric programming languages”, or esolangs, community; Hillel Wayne has a nice <a href="https://www.hillelwayne.com/talks/esolangs/">introduction to esolangs</a> that also spends some time on code golf and GolfScript, via which I found an informative <a href="https://esoteric.codes/blog/martin-ender">interview with Martin Ender</a>.</p>
<p>Another adjacent scene I don’t know much about is <a href="https://js1k.com/">JS1k</a>, a more open-ended competition where the goal is just “make something cool in 1KB of JavaScript”, with an optional yearly theme. It <a href="https://twitter.com/js1k/status/1111942943328387077">stopped running as of 2020</a> but I think <a href="https://js1024.fun/">js1024</a> is the successor.</p>
<p>For those of you who want to go further down the golflang rabbit hole, there are many more useful answers to a CGCC question about <a href="https://codegolf.stackexchange.com/questions/198446/tips-for-creating-maintaining-a-golfing-language">creating/maintaining a golflang</a>.</p>
<p>Happy golfing!</p>
<p><i>Thanks to the many members of the code.golf Discord and CGCC chat room who reviewed and gave suggestions, especially xnor and JoKing for particularly consequential comments and Lydxn for the −3 bytes on the flagship example.</i></p>
<h3 id="appendix-golfscript-factorial-breakdown">Appendix: GolfScript Factorial breakdown</h3>
<pre class="small"><code>~       # Evaluate the input to get a bunch of integers.
]       # Collect them into a list.
{       # For each integer in that list:
  ,       # Make the range of integers from 0 to that number exclusive.
  1       # Push a 1, which will be an accumulator.
  \       # Move it beneath the list on the &quot;stack&quot;.
  {       # For each integer in the range:
    )       # Increase it by 1.
    *       # Multiply the accumulator by it.
  }       # The brackets just delimit a code block...
  /       # the / is the actual &quot;for each&quot;.
          # After that loop, we&#39;ve computed the factorial.
  n       # Push a newline after each factorial.
}       # The brackets just delimit a code block;
/       # the / is the actual &quot;for each&quot;.</code></pre>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I’m considering code golf as a pursuit for its own sake, rather than something a programmer might (but shouldn’t) do in code they’re writing for other purposes. Sure, shorter code is simpler and easier to maintain up to a point just because there’s less of it, but good code will generally have descriptive variable names, comments, and some amount of common sense in deciding how to do things. Code golf is all about consciously ignoring all those other concerns. Variable names are basically never more than one character. Comments don’t exist, at least in the “final product”. And more often than not, well-golfed code will bend over backwards to do things in seemingly obtuse ways because the obtuse way happens to be one byte shorter.</p>
<p>I’m not really sure anybody needs to read this disclaimer, but Googling “code golf” shows at least some articles warning about trying to write unnecessarily short code, so I thought a footnote on it might make sense.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Sometimes code golf is described with the “cute” analogy: whereas in golf you want to use as few strokes as possible, in code golf you want to use as few <em>key</em>strokes as possible. While cute, this is not very accurate; program length is usually measured in bytes and occasionally in number of Unicode characters, where lowercase letters, uppercase letters, digits, symbols, and sometimes even non-ASCII characters in your code page of choice all count equally, even though some might require you to hit more modifier keys than others.<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>Though, when I think too much about code golf, my interpretation of “no golfing at all” tends to become a bit warped, so please pardon any ways in which this is still unnecessarily short. I had to reread this post several times to remember that Pythonistas don’t normally use <code>1</code> as the condition in an infinite loop.<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>I say “arcane” from the perspective of a non-golfer, but all the tricks I’m using here are very well-known in code golf communities; you can find them in any of CGCC’s evergreen <a href="https://codegolf.stackexchange.com/questions/54/tips-for-golfing-in-python">Tips for golfing in Python</a> question, Anarchy Golf’s accompanying <a href="https://sites.google.com/site/codegolfingtips/python">Python code golfing tips</a>, and <a href="https://code.golf/wiki/langs/python">code.golf’s Python wiki</a>.<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>“Coerce” is not technically the right verb; in Python, “<a href="https://docs.python.org/3/library/stdtypes.html#typesnumeric">Booleans are a subtype of integers</a>” and “<a href="https://docs.python.org/3/library/stdtypes.html#boolean-values">behave like the integers 0 and 1</a>” in numeric contexts.<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>Thanks to Lydxn for pointing this out. I CTRL-F’ed “factorial” on the math module’s documentation and assumed that this would locate every built-in that could be used to compute the factorial, but the correct strategy was to CTRL-F “!”. Or just read it top to bottom.<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>Thanks to xnor for the pointer.<a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p>Thanks to emanresu A for the pointer.<a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p>It and several other sites reference <code>codegolf.com</code>, which I think probably began in mid-2006; but judging by the Wayback Machine, that site died in early to mid-2014.<a href="#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p>Formerly known as Programming Puzzles and Code Golf (PPCG); the <a href="https://codegolf.meta.stackexchange.com/questions/17612/what-should-this-site-be-called-now-that-its-getting-a-design">new name was chosen</a> during a site redesign.<a href="#fnref10" class="footnote-back">↩</a></p></li>
<li id="fn11"><p>This is implied by a <a href="https://stackoverflow.blog/2021/08/19/celebrating-the-stack-exchange-sites-that-turned-10-years-old/">2021 StackOverflow blog post</a> and the blog post immediately after this footnote. There are questions that seem to be asked earlier, e.g. the <a href="https://codegolf.stackexchange.com/questions/4244/code-golf-christmas-edition-how-to-print-out-a-christmas-tree-of-height-n">earliest question</a> I was able to get from the search engine dates to 2008, but closer inspection reveals that it was migrated from StackOverflow proper.<a href="#fnref11" class="footnote-back">↩</a></p></li>
<li id="fn12"><p>Well, subject to <a href="https://codegolf.meta.stackexchange.com/questions/1061/loopholes-that-are-forbidden-by-default">standard loopholes</a> — no <a href="https://codegolf.meta.stackexchange.com/a/1071">inventing</a> or <a href="https://codegolf.meta.stackexchange.com/a/5076">specifying through a “side channel”</a> a post-hoc language where an incredibly short “program” simply happens to do exactly what the challenge asks for. This is somewhat subjective, but in practice it’s pretty obvious when somebody is trying to do one of these things.<a href="#fnref12" class="footnote-back">↩</a></p></li>
<li id="fn13"><p>Some packers were developed before code.golf for posting JavaScript demos to certain sites with character limits, like Twitter and <a href="https://www.dwitter.net/">dwitter.net</a>. <a href="https://xem.github.io/codegolf/obfuscatweet.html">Obfusc-a-tweet</a> is a tool first developed in 2014 that packs 190 characters of JavaScript into a 140-character tweet; since then, it’s been expanded to take advantage of other Twitter features. Thanks to Irratix for the pointer.<a href="#fnref13" class="footnote-back">↩</a></p></li>
<li id="fn14"><p><a href="https://en.wikipedia.org/wiki/Partial_application">Partial application</a> is just when you provide some, but not all, arguments to a function in order to produce a new function that can be called with the remaining arguments.<a href="#fnref14" class="footnote-back">↩</a></p></li>
<li id="fn15"><p>This page does not actually cover an additional fact we use, which is that the left verb in a fork can be replaced with a noun, which is treated as the constant function that always returns that noun. See e.g. documentation on <a href="https://www.jsoftware.com/help/dictionary/dictf.htm">trains</a> for that specification.<a href="#fnref15" class="footnote-back">↩</a></p></li>
<li id="fn16"><p>One more subtlety: APL supports user-defined operators and J supports user-defined adverbs/conjunctions, but Jelly doesn’t support user-defined quicks, at least for now. (Thanks to Unrelated String for the explanation.)<a href="#fnref16" class="footnote-back">↩</a></p></li>
</ol>
</section></article>
	<footer class="post-footer">
		
		<ul class="post-tags">
			
		</ul>
		
	</footer>
	<script data-isso="//node.vero.site/isso/" data-isso-css="false" src="//node.vero.site/isso/js/embed.min.js"></script>
	<section id="isso-thread"></section>
	<p class="comments-meta">(note: the commenting setup here is experimental and I may not check my comments often; if you want to tell <em>me</em> something instead of the world, email me!)</p>
	
	
	
	<footer class="post-footer">
		<nav class="pagination">
			
			<a class="pagination-previous" href="//blog.vero.site/post/flexbox-fun">← Flexbox Fun Facts</a>
			
			
		</nav>
	</footer>
</section>
</div>
<footer class="site-footer">
	<p>© 2017-2022 betaveros, Bounded-Error Log</p>
	<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />Except where otherwise noted, content on this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
	<p>Powered by <a href="https://gohugo.io/">Hugo</a>, <a href="http://pandoc.org/">pandoc</a>,
	<a href="https://www.goatcounter.com/">GoatCounter</a>,
	<a href="https://posativ.org/isso/">Isso</a>,
	<a href="https://pages.github.com/">GitHub Pages</a>, and
	<a href="https://www.cloudflare.com/">CloudFlare</a>.
	</p>
	<p>Opinions are mine and not of any employer, past or present.</p>
</footer>

<script src="/katex/katex.min.js"></script>
<script src="/katex/contrib/auto-render.min.js"></script>
<script>renderMathInElement(document.body);</script>
<script src="/js/bundle.js"></script>
<script>window.goatcounter = { path: function(p) { return '/blog' + p; } }</script>
<script data-goatcounter="https://node.vero.site:8073/count" async src="https://node.vero.site:8073/count.js"></script>
<script src="/js/jquery-3.2.1.min.js"></script>


</body>
</html>
