<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8" />
<title>C&#43;&#43; Rvalue References: The Unnecessarily Detailed Guide</title>

<meta name="author" content="betaveros" />
<meta name="description" content="By a strange quirk of fate, I have started writing C&#43;&#43; for a living.
Learning C&#43;&#43; was about as complicated as I think I expected it to be. By line count, I’ve written a lot of C&#43;&#43; for programming competitions, but I knew that I had only ever used a small cross-section of the language: basic control flow and variables, STL containers and algorithms, structs on which you mechanically define bool operator&amp;lt;(const T&amp;amp; other) const so STL algorithms can order them, and the very occasional macro or templated helper function. There were many features I wasn’t even aware existed.
In the process of learning C&#43;&#43; professionally, one rabbit hole I fell into quickly was C&#43;&#43;11’s defining feature, the rvalue reference, and how it can be used to implement move semantics and perfect forwarding. By poring over a copy of the widely recommended book Effective Modern C&#43;&#43;, by Scott Meyers, and a few dozen StackOverflow answers and blog posts, I roughly understood it after a few days, but still had a sort of blind-men-feeling-the-elephant feeling. I was confused about what lay under some of the abstractions I had been using, unsure of the full shape of the pitfalls that some of the guides had pointed out to me, and generally uncomfortable that there were still many small variations of the code I had seen that I couldn’t predict the behavior of. It took many more days to work myself out of there, and I wished I had had a guide that explained rvalue references and their applications to a bit more depth than what might be necessary for day-to-day use. So here’s my attempt to explain rvalue references in my own fundamental I-want-to-know-how-things-work-no-really style.
(If this vision doesn’t resonate with you, there are many other posts explaining rvalue references out there that you might prefer. Feel free to just skim the executive summary and/or check out some of the linked articles in the Background section.)
Executive Summary I got… pretty carried away when writing this post, and a lot of it is just for my own understanding, which may or may not be useful to readers. Here’s a much more concise rundown (assuming you know basic C&#43;&#43; already):
" /><meta name="generator" content="Hugo 0.88.0-DEV" />

<link rel="canonical" href="//blog.vero.site/post/rvalue-references" />
<link rel="alternative" href="/index.xml" title="Bounded-Error Log" type="application/atom+xml" />

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="format-detection" content="telephone=no,email=no,adress=no" />
<meta http-equiv="Cache-Control" content="no-transform" />

<meta name="robots" content="index,follow" />
<meta name="referrer" content="origin-when-cross-origin" />
<meta name="theme-color" content="#330000" />
<meta name="twitter:creator" content="@betaveros">

<link rel="icon" href="/favicon.ico" />

<link rel="stylesheet" href="/css/bundle.css" />
<link rel="stylesheet" href="/katex/katex.min.css" />

<!--[if lte IE 11]>
    <script src="//cdn.bootcss.com/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

</head>
<body><div id="wrapper">
<header class="site-header"><h2 class="title"><a href="/">Bounded-Error Log</a></h2><p class="subtitle">theoretical and applied randomness by <a href="https://beta.vero.site/">betaveros</a></p>
<button class="menu-toggle" type="button" aria-label="Toggle Menu">
	<span class="icon icon-menu" aria-hidden="true"></span>
</button>
<nav class="site-menu collapsed">
	<h2 class="offscreen">Main Menu</h2>
	<ul class="menu-list"><li class="menu-item "><a href="/about">About</a></li><li class="menu-item "><a href="/category/life">Life</a></li><li class="menu-item "><a href="/category/thoughts">Thoughts</a></li><li class="menu-item "><a href="/category/self-analysis">Self-Analysis</a></li><li class="menu-item "><a href="/category/math">Math</a></li><li class="menu-item "><a href="/category/cs">CS</a></li><li class="menu-item "><a href="/category/puzzles">Puzzles</a></li><li class="menu-item "><a href="/category/meta">Meta</a></li><li class="menu-item "><a href="/util">Utilities</a></li><li class="menu-item "><a href="/all">All Posts</a></li></ul>
</nav>
<nav class="social-menu collapsed">
	<h2 class="offscreen">Social Networks</h2>
	<ul class="social-list"><li class="social-item">
			<a href="//github.com/betaveros" title="GitHub" aria-label="GitHub"><span class="icon icon-github" aria-hidden="true"></span></a>

		</li><li class="social-item">
			<a href="/index.xml" title="RSS" aria-label="RSS"><span class="icon icon-rss" aria-hidden="true"></span></a>
		</li>
	</ul>
</nav>
</header>

<section class="main post-detail">
	<header>
		<h1 class="post-title">C&#43;&#43; Rvalue References: The Unnecessarily Detailed Guide</h1>
		
		<h2 class="post-subtitle">Move semantics, perfect forwarding, and... everything else</h2>
		
		<p class="post-meta">
		
		2020-11-16
		(12004 words)
		
		<span class="post-categories">
			filed under
			<a href="/category/cs">CS</a>
		</span>
		
		</p>
	</header>
	<article><p>By a strange quirk of fate, I have started writing C++ for a living.</p>
<p>Learning C++ was about as complicated as I think I expected it to be. By line count, I’ve written a lot of C++ for programming competitions, but I knew that I had only ever used a small cross-section of the language: basic control flow and variables, STL containers and algorithms, structs on which you mechanically define <code>bool operator&lt;(const T&amp; other) const</code> so STL algorithms can order them, and the very occasional macro or templated helper function. There were many features I wasn’t even aware existed.</p>
<p>In the process of learning C++ professionally, one rabbit hole I fell into quickly was C++11’s defining feature, the <em>rvalue reference</em>, and how it can be used to implement <em>move semantics</em> and <em>perfect forwarding</em>. By poring over a copy of the widely recommended book <a href="https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996"><cite>Effective Modern C++</cite></a>, by Scott Meyers, and a few dozen StackOverflow answers and blog posts, I roughly understood it after a few days, but still had a sort of blind-men-feeling-the-elephant feeling. I was confused about what lay under some of the abstractions I had been using, unsure of the full shape of the pitfalls that some of the guides had pointed out to me, and generally uncomfortable that there were still many small variations of the code I had seen that I couldn’t predict the behavior of. It took many more days to work myself out of there, and I wished I had had a guide that explained rvalue references and their applications to a bit more depth than what might be necessary for day-to-day use. So here’s my attempt to explain rvalue references in my own fundamental I-want-to-know-how-things-work-no-<em>really</em> style.</p>
<p>(If this vision doesn’t resonate with you, there are many other posts explaining rvalue references out there that you might prefer. Feel free to just skim the executive summary and/or check out some of the linked articles in the Background section.)</p>
<h3 id="executive-summary">Executive Summary</h3>
<p>I got… pretty carried away when writing this post, and a lot of it is just for my own understanding, which may or may not be useful to readers. Here’s a much more concise rundown (assuming you know basic C++ already):</p>
<ul>
<li>Every C++ expression is either an lvalue or rvalue. Roughly, it’s an lvalue if you can “take its address”, and an rvalue otherwise. For example, if you’ve declared a variable <code>int x;</code>, then <code>x</code> is an lvalue, but <code>253</code> and <code>x + 6</code> are rvalues. If you can assign to it, it’s definitely an lvalue.</li>
<li>Rvalue references are a new kind of reference in C++11, declared with two <code>&amp;&amp;</code>s instead of one, e.g. <code>int&amp;&amp; x;</code> The old single-<code>&amp;</code> kind are now called lvalue references. Lvalue references and rvalue references differ only in the rules surrounding their initialization, which includes when a function has a reference parameter and the compiler determines whether a certain argument is acceptable for that parameter. In particular, they do not differ when you use them in an expression: both kinds of references will be lvalues!</li>
<li>The rules for initializing a reference are: You can only initialize a non-const lvalue reference to an lvalue, which makes sense since the reference has to refer to something. However, you can initialize a const lvalue reference to either an lvalue or an rvalue; if you provide an rvalue, it will implicitly declare a new variable, initialize it to that rvalue, and produce a const reference to that variable instead. And you can <em>only</em> initialize an rvalue reference to an rvalue, which will do the same thing. Also, you must be careful of the lifetime of the implicitly declared variable; if it expires too quickly, you end up with a dangling reference.</li>
<li>However, you can call <code>std::move</code> on an lvalue to produce an rvalue that can be “smuggled” into an rvalue reference. If you do so, no new implicit variable will be created; the rvalue reference will actually refer to the lvalue passed into <code>std::move</code>.</li>
<li><p>Sometimes, you want to write a function taking an argument that can be implemented in one of two ways: a slow way that treats its argument as read-only, perhaps making a new copy, and returns something new, or an efficient way that clobbers its argument and reuses its resources to produce a return value. Loosely speaking, the latter type of behavior or the ability to offer it as an option is referred to as “moving” or <strong>move semantics</strong>. A popular way to support move semantics that automatically works with many types of client code is to overload the function as follows:</p>
<ul>
<li><p>One overload will have an lvalue reference parameter and do the slow, argument-preserving thing; it’ll be called if the argument is an lvalue.</p></li>
<li><p>The other overload will have an rvalue reference parameter and do the efficient, argument-clobbering thing; it’ll be called if the argument is an rvalue.</p></li>
</ul>
This automatically does the right thing for most clients, but the standard library function <code>std::move</code> gives you an escape hatch whereby a caller can deliberately invoke the efficient, argument-clobbering overload on an lvalue that it’s OK with being clobbered. But if there aren’t function overloads that are “paying attention”, <code>std::move</code> doesn’t do anything by itself.</li>
<li><p>Although you can’t write such a type directly, the new reference collapsing rules in C++11 states that a reference to a reference is just a reference. In particular, <code>T&amp; &amp;&amp; = T&amp;</code>. So if <code>T</code> is a type variable, <code>T&amp;&amp;</code> can be either an lvalue reference or an rvalue reference, and if a templated function has a parameter type <code>T&amp;&amp;</code>, a natural value for <code>T</code> can be inferred for any argument depending on if it’s an lvalue or an rvalue. This enables you to write a templated function that can be called with any arguments, is aware of whether its arguments are lvalues and rvalues, and can forward those arguments to another function while preserving both their type and their lvalue/rvalue-ness. However, you will need to call <code>std::forward</code> to reconstruct the lvalue/rvalue-ness. This is called <strong>perfect forwarding</strong> and typically looks like this:</p></li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">template</span>&lt;<span class="kw">typename</span>... Ts&gt; <span class="dt">void</span> g(Ts&amp;&amp;... v) {</a>
<a class="sourceLine" id="cb1-2" title="2">    f(<span class="bu">std::</span>forward&lt;Ts&gt;(v)...);</a>
<a class="sourceLine" id="cb1-3" title="3">}</a></code></pre></div>
<p>Read on for the long, detailed version with (way) more examples and links.</p>
<h3 id="background">Background</h3>
<p>I assume you know simple C++, understand and are comfortable with pointers and in particular how pointers can dangle, and understand references, templates, classes, and constructors on at least a basic level. If you understand why the below function doesn’t work, how to fix it, and how to change it so it also applies to vectors that hold any numeric type, you should be good.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">void</span> addSixToAll(vector&lt;<span class="dt">int</span>&gt; vec) {</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="cf">for</span> (<span class="dt">int</span> x : vec) {</a>
<a class="sourceLine" id="cb2-3" title="3">        x += <span class="dv">6</span>;</a>
<a class="sourceLine" id="cb2-4" title="4">    }</a>
<a class="sourceLine" id="cb2-5" title="5">}</a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="co">// usage:</span></a>
<a class="sourceLine" id="cb2-8" title="8">vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">3</span>};</a>
<a class="sourceLine" id="cb2-9" title="9">addSixToAll(v);</a>
<a class="sourceLine" id="cb2-10" title="10"><span class="co">// v should now contain {8, 11, 9}</span></a></code></pre></div>
<p>In addition, this post will make the most sense if you already understand, on a high level, why move semantics and perfect forwarding are nice features to have in C++; I will discuss them briefly but not try particularly hard to motivate them. Some other posts that cover overlapping material and do motivate them:</p>
<ul>
<li><p>For motivating move semantics:</p>
<ul>
<li>Triangles, of InternalPointers, <a href="https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners">C++ rvalue references and move semantics for beginners</a>, motivates move semantics with a standard managed-<code>int[]</code> class. The predecessor <a href="https://www.internalpointers.com/post/understanding-meaning-lvalues-and-rvalues-c">Understanding the meaning of lvalues and rvalues in C++</a> also covers some of the same material.</li>
<li>Eli Bendersky, <a href="https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c/">Understanding lvalues and rvalues in C and C++</a>, motivates move semantics with the standard int vector example.</li>
</ul></li>
<li><p>For motivating perfect forwarding:</p>
<ul>
<li>Eli Bendersky, <a href="https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/">Perfect forwarding and universal references</a>, motivates perfect forwarding through vector “emplacement” and variants.</li>
<li>oopscene, <a href="https://oopscenities.net/2014/02/01/c11-perfect-forwarding/">C++11: Perfect forwarding</a>, motivates perfect forwarding through a higher-order function and variants.</li>
</ul></li>
<li><p>For both:</p>
<ul>
<li>Thomas Becker, <a href="http://thbecker.net/articles/rvalue_references/section_01.html">C++ Rvalue References Explained</a>, motivates move semantics with a generic resource-holding class and perfect forwarding with a generic factory function.</li>
</ul></li>
</ul>
<p>We’re also going to do the pretentious language-lawyer thing where we differentiate parameters from arguments, because the difference will matter. <strong>Parameters</strong> are the variables that a function is declared as taking and that it can use in its function body; <strong>arguments</strong> are the expressions that you actually pass into a function to call it. Below, <code>param1</code> and <code>param2</code> are the parameters to <code>f</code>, and <code>arg1</code> and <code>arg2_1 + arg2_2</code> are the arguments it’s called with. Note already from this example that that parameters are variables, but arguments are expressions that can be variables or can be more complicated.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">int</span> f(<span class="dt">int</span> param1, <span class="dt">int</span> param2) {</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="cf">return</span> param1 + param2;</a>
<a class="sourceLine" id="cb3-3" title="3">}</a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="co">// ...</span></a>
<a class="sourceLine" id="cb3-6" title="6">f(arg1, arg2_1 + arg2_2);</a></code></pre></div>
<p>Finally, we’ll be using C++11. If you choose to compile along at home, make sure to pass <code>-std=c++11</code> or otherwise specify the C++ edition to your compiler! I didn’t and was really confused when certain code snippets didn’t do what I expected them to do. Shows how narrow my C++ knowledge was until now.</p>
<p>Without further ado:</p>
<h3 id="lvalues-and-rvalues">Lvalues and Rvalues</h3>
<p>The names “lvalues” and “rvalues” come from early C and are named after the following rather poor approximation to what they are now, which I mention mostly just to help you remember which one is which:</p>
<ul>
<li>Lvalues are expressions that can be assigned to, i.e. they can be on the <em>left</em> side of an <code>=</code> sign in an assignment;</li>
<li>Rvalues are all other expressions, which you will typically find on the <em>right</em> side of an assigmnent.</li>
</ul>
<p>For example, if <code>x</code> is an <code>int</code> variable, the statement <code>x = 6;</code> makes sense, so the expression <code>x</code> is an lvalue. But <code>4 = x;</code> doesn’t make sense — you can’t assign to <code>4</code>; what would that do, change the meaning of <code>4</code> everywhere else it appears in the program?<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> — so the expression <code>4</code> is an rvalue, as are all other numeric literals. Some other familiar examples of lvalues include <code>a[i]</code> if <code>a</code> is an array variable and <code>s.f</code> if <code>s</code> is a variable holding a struct with a field called <code>f</code>. Some other familiar examples of rvalues are arithmetic expressions between primitive numeric types, for example something like <code>x + 4</code>.</p>
<p>While easy to remember, this breaks down quickly in modern C++ (and modern C too): <code>x</code> is still an lvalue even if it’s <code>const</code>, but <code>const</code> variables can no longer be assigned to. Also, surprisingly, <a href="https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value">string literals are lvalues</a>. A better rule of thumb is that <strong>lvalues are expressions you can take the address of</strong>. And since lvalues can actually also go on the right side of an assignment, the name is sometimes retconned to be short for “locator value”. As far as I’m aware, though, nobody has come up with a good retcon for “rvalue”. And it is still the case that lvalues and rvalues form a perfect dichotomy of all expressions: every expression is exactly one of the two. So <strong>rvalues are expressions you can’t take the address of</strong>.</p>
<p>In C++11, the category of “rvalues” was further subdivided into “xvalues” (sometimes “eXpiring values”, though this is also a retcon) and “prvalues” (“pure rvalues”). These categories are called <strong>value categories</strong>, by the way, and they still form a perfect trichotomy of all expressions: every expression is exactly one of an lvalue, an xvalue, and a prvalue. The term “glvalue” (“generalized l-value”) refers to simply “either an lvalue or an xvalue”. cppreference.com has a very <a href="https://en.cppreference.com/w/cpp/language/value_category">detailed explanation of value categories</a>, and there’s a classic StackOverflow question <a href="https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues">What are rvalues, lvalues, xvalues, glvalues, and prvalues</a> with many good answers that are worth reading. But at a high level, I think the difference between xvalues and prvalues is less important to know than the difference between lvalues and rvalues. xvalues are pretty rare and you have to write somewhat tricky code to produce an xvalue. On the other hand, the innovative bits of C++11 that we’re here to discuss are exactly those that enable that tricky code. On the gripping hand, the goal of that tricky code is often simply to produce any kind of rvalue rather than specifically an xvalue.</p>
<p>One thing I want to make sure gets across is that <strong>a value category is a property of an expression, and not of a variable</strong>. This is confusing because expressions can consist of a single variable and will thus have a value category, but later we’ll see why we want to distinguish variables from expressions consisting of a single variable.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> To be clear when this comes up, I’ll call such an expression that just consists of a single variable a “variable expression”, although I don’t think this is established terminology (cppreference <a href="https://en.cppreference.com/w/cpp/language/expressions">calls them “id-expressions”</a>).</p>
<h3 id="references">References</h3>
<p>As I mentioned in the introduction, I’m assuming you understand pointers, so, well, a reference is like a pointer. The C++ FAQ says <a href="https://isocpp.org/wiki/faq/references#overview-refs">not to think of a reference as a funny pointer</a>, but I think the comparison is useful in the sense that given a pointer to some data and a reference to some data, the things you can learn about that data and the ways you can modify it are basically the same. You can assign to it and modify it directly; you’ll be affecting exactly the same data, not a copy of it. You can get the address. You can convert between a pointer and a reference easily.</p>
<p>One way I think about references is that they’re pointers where when you first initialize them, there’s an implicit <code>&amp;</code> (reference operator) applied to the expression you use to initialize them with, and whenever you use them in an expression (no matter if they’re on the left or right side of an assignment!), there’s an implicit <code>*</code> (dereference operator) applied to them. These implicit operators cannot be circumvented, which limits some of the ways you can manipulate references compared to pointers. Unlike pointers, references can’t be null<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>, because you have to initialize each reference to the <code>&amp;</code> of some expression; also, pointers can change to point at something else, but references can’t change to refer to something else, because to change where a pointer <code>p</code> points (as opposed to changing the data at the location where it points), you have to directly assign to it without dereferencing it: <code>p = ...;</code>. So a reference is basically another name for a variable that exists somewhere else. Finally, although you can have pointers to pointers (and pointers to pointers to pointers, and so on), and you can have references to pointers, you can’t have a reference to a reference or a pointer to a reference. There can only be one level of “reference-of-ness” in a type and (ignoring templated types) it can only be at the outermost edge of the type.</p>
<p>The presence of the implicit <code>&amp;</code> when you initialize a reference also immediately implies that <strong>you must initialize a (non-const) reference to a (non-const) lvalue</strong>. (We’ll see how that’s not true for const references later. Also, variables and references can also be volatile, which often affects types in a way similar to but orthogonal to const-ness; but for simplicity, I’m not even going to touch that for the rest of the post.) That’s why these references are more precisely called “<strong>lvalue references</strong>”, to differentiate them from the rvalue references that are the main target of this post, and which we’ll see soon. So, you can write the following, because <code>x</code> is an lvalue expression:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="dt">int</span> x;</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="dt">int</span>&amp; y = x;</a></code></pre></div>
<p>But you can’t write</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1"><span class="dt">int</span>&amp; y = <span class="dv">253</span>;  <span class="co">// doesn&#39;t compile</span></a></code></pre></div>
<p>because that would involve taking the address of “253”, which doesn’t make sense; it’s a constant that could be produced by hardcoded assembly instructions and isn’t necessarily ever stored anywhere. You also can’t write, for example,</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="dt">int</span>&amp; y = x + <span class="dv">6</span>;  <span class="co">// doesn&#39;t compile</span></a></code></pre></div>
<p>because <code>x + 6</code> is an intermediate expression. It isn’t necessarily stored anywhere, certainly not in a way that is guaranteed to persist after the statement, and so likely doesn’t have an address.</p>
<p>However, in a sense, this isn’t fundamentally impossible. You could imagine that C++ might have been designed to accept the code above and just treat it as syntax sugar for code like the following, which declares a plain non-reference-type variable in the same scope and takes a reference to it:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1"><span class="dt">int</span> implicitly_created_temp_y = <span class="dv">253</span>;</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="dt">int</span>&amp; y = implicitly_created_temp_y;</a></code></pre></div>
<p>There wouldn’t be any way to access the variable <code>implicitly_created_temp_y</code> other than through <code>y</code>, but this code could still make sense and <code>y</code> might still behave the way you’d expect it to behave. And in fact, <strong>you can initialize a const lvalue reference to an rvalue expression</strong> (<em>or</em> an lvalue expression), which produces code that works basically exactly as I described:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" title="1"><span class="at">const</span> <span class="dt">int</span>&amp; t = <span class="dv">253</span>;</a></code></pre></div>
<p>behaves just like</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" title="1"><span class="dt">int</span> <span class="dt">implicitly_created_temp_t</span> = <span class="dv">253</span>;</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="at">const</span> <span class="dt">int</span>&amp; t = <span class="dt">implicitly_created_temp_t</span>;</a></code></pre></div>
<p>The lifetime of this new temporary value is the same as the lifetime of the reference.</p>
<p>Similar things happen with calling a function with a parameter that’s a reference type. If you have a function <code>f</code> declared as <code>f(int&amp; arg)</code>, you can call it with the expression <code>f(x)</code>, but not <code>f(253)</code>. On the other hand, if you have a function <code>f(const int&amp; arg)</code>, you <em>can</em> call it with <code>f(253)</code>; this implicitly creates a variable initialized to 253, takes a const reference to it, and calls the function with that. As a result, even before C++11, it was quite idiomatic for functions that only needed read-only versions of their arguments to be declared with <code>const</code> reference parameters, as those would be more efficient than non-reference parameters on lvalue arguments by avoiding needing to copy them, but would still work on rvalue arguments. However, note that the lifetime of any such implicitly created variable only lasts as long as the “full expression” containing the function call, so it’ll be gone by the following statement and you need to make sure you don’t still have dangling references to it. A contrived example to illustrate this:<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb14-1" title="1"><span class="at">const</span> <span class="dt">int</span>&amp; silly(<span class="at">const</span> <span class="dt">int</span>&amp; x) {</a>
<a class="sourceLine" id="cb14-2" title="2">    <span class="cf">return</span> x;</a>
<a class="sourceLine" id="cb14-3" title="3">}</a>
<a class="sourceLine" id="cb14-4" title="4"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb14-5" title="5">    <span class="at">const</span> <span class="dt">int</span>&amp; x = silly(<span class="dv">253</span>);</a>
<a class="sourceLine" id="cb14-6" title="6">    <span class="at">const</span> <span class="dt">int</span>&amp; y = silly(<span class="dv">492</span>);</a>
<a class="sourceLine" id="cb14-7" title="7">    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">&quot;</span>, y, x);</a>
<a class="sourceLine" id="cb14-8" title="8">}</a></code></pre></div>
<p>This compiles with no warnings, but when I run it, it prints <code>492 492</code>. The issue is that <code>x</code> is a reference to a temporary variable initialized to <code>253</code> that only lives as long as the expression it’s initialized it, which is <code>silly(253)</code> (and in particular, not as long as <code>x</code> itself). So, whatever memory location <code>x</code> refers to, it’s freely overwriteable by the time we finish its definition and get to the definition of <code>y</code>, and certainly by the time we <code>printf</code> it. It’s undefined behavior (and would be even if we deleted the definition of <code>y</code>). The term “full expression” is a formal one but it roughly means “an expression that’s not part of another expression”. If you see a semicolon, that’s almost certainly the end of a full expression.</p>
<p>Finally, if you’re implementing a function whose return type is a <code>const</code> reference, you can also write a <code>return</code> statement that returns an rvalue… but you should never do this because this particular case never extends the lifetime of the temporary variable. You are guaranteed to produce a dangling reference. Consistent with this observation, the C++ compilers I tested actually warn if you try to return a const reference to a local variable from a function, whereas they didn’t warn about <code>silly</code> above.</p>
<p>For the interested, cppreference.com documents the nitty-gritty details of <a href="https://en.cppreference.com/w/cpp/language/reference_initialization#Lifetime_of_a_temporary">extending the lifetime of a temporary</a>. In general, given a fixed reference type <code>T</code> (which might or might not be const, and might be an lvalue reference or an rvalue reference as we’re about to see) and an expression <code>/* some expression */</code> with a fixed type and value category, the rules for whether these three snippets will typecheck and compile are the same:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" title="1">T variable = <span class="co">/* some expression */</span>;</a>
<a class="sourceLine" id="cb15-2" title="2"></a>
<a class="sourceLine" id="cb15-3" title="3"><span class="dt">void</span> f(T parameter) {}</a>
<a class="sourceLine" id="cb15-4" title="4">f(<span class="co">/* some expression */</span>);</a>
<a class="sourceLine" id="cb15-5" title="5"></a>
<a class="sourceLine" id="cb15-6" title="6">T f() { <span class="cf">return</span> <span class="co">/* some expression */</span>; }</a></code></pre></div>
<p>These rules are documented in the <a href="https://en.cppreference.com/w/cpp/language/reference_initialization">full page on reference initialization</a>. In fact, I find it kind of useful to try imagining manually inlining function calls, that is, temporarily ignore scoping issues and mentally translate function calls like this</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" title="1">ReturnType f(ParamType param) {</a>
<a class="sourceLine" id="cb16-2" title="2">    <span class="co">/* code here */</span></a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="cf">return</span> <span class="co">/* return expr */</span>;</a>
<a class="sourceLine" id="cb16-4" title="4">}</a>
<a class="sourceLine" id="cb16-5" title="5"></a>
<a class="sourceLine" id="cb16-6" title="6">VarType v = f(<span class="co">/* arg expr */</span>);</a></code></pre></div>
<p>to</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" title="1">ParamType param = arg;</a>
<a class="sourceLine" id="cb17-2" title="2"><span class="co">/* code here */</span></a>
<a class="sourceLine" id="cb17-3" title="3">ReturnType ret = <span class="co">/* return expr */</span>;</a>
<a class="sourceLine" id="cb17-4" title="4">VarType v = ret;  <span class="co">// we will see later that this line is fake</span></a></code></pre></div>
<p>Note the imaginary variable <code>ret</code> with type <code>ReturnType</code>, which we never named and can be a reference. I think this may be a mental model you build early on when learning programming and then stop thinking about because it’s too obvious, but when there are references involved, the exact semantics can become nonobvious.</p>
<p>Although I think the above mental inlining helps you reason about whether some expressions that replace <code>/* return expr */</code> or <code>/* arg expr */</code> will compile, it doesn’t necessarily represent the operations that actually happen, because of <strong>return value optimization</strong>, or RVO. The above code suggests that if <code>ReturnType</code> and <code>VarType</code> are classes with a nontrivial constructor, the constructor will be called twice, once to initialize <code>ret</code> and once to initialize <code>v</code>. (In case you haven’t encountered this before: yes, despite appearances, <code>T x = y;</code> calls a single-argument constructor of <code>T</code> because it’s a variable definition; it has nothing to do with <code>operator=</code>.<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> But after that declaration, <code>x = y;</code> would call <code>operator=</code>.) Even worse, <code>/* return expr */</code> might just be an expression that calls the constructor — that’s the natural way to write it, since there’s no syntax to directly construct into <code>ret</code> — and then we’d be calling the constructor three times. However, if <code>ReturnType</code> and <code>VarType</code> are the same class and you actually compile and run such code, you will likely find that the constructor is only called once, simply because the compiler can tell where the constructed object will end up. This optimization is so common that it’s named. There are other ways constructors can be elided from the above inlined version; <a href="https://shaharmike.com/cpp/rvo/">Shahar Mike’s article on Return Value Optimization</a> goes into more depth on this phenomenon.</p>
<p>Here I will put another important note to mirror the one I concluded the last section with: Variables (including function parameters) can be either references or not, as can function return types; but <strong>expressions</strong> (including function arguments) <strong>can never be reference types</strong>! Whether you end up taking a reference to any given expression or not depends on how the expression is used. (Don’t be confused by the many ways the word “reference” has popped up in this post. You can apply the reference operator to some expressions to get new expressions, whose types are pointer types; and you can apply the dereference operator to an expression if its type is a pointer type to get another expression. None of these expressions are necessarily reference types.)</p>
<h3 id="rvalue-references">Rvalue References</h3>
<p>So what is an rvalue reference? It’s just a slightly different kind of reference introduced in C++11. The differences are actually smaller than I expected when I started learning about them. An rvalue reference still has to refer to something you can take the address of, and every time you use it in an expression, it still gets implicitly dereferenced in an uncircumventable way.</p>
<p>You declare a variable, parameter, or function return type with an rvalue reference type just like you would for an lvalue reference type, except with two <code>&amp;</code>s instead of one: <code>int&amp;&amp; y;</code> Note that the two ampersands <code>&amp;&amp;</code> are a single syntactic unit. It does not mean, and there is no confusion with, a “reference to a reference to” something.</p>
<p>The key difference lies in how you <em>initialize</em> rvalue references: you can <strong>only initialize an rvalue reference with an rvalue</strong>. You cannot initialize it to an lvalue! This might seem bizarre because, of course, you can’t take the address of an rvalue, which is what we need to produce a reference. But as I described earlier, you could imagine treating such an initialization as syntax sugar that implicitly defines a variable that is initialized to the rvalue and then takes a reference to that, and similar syntax sugar already exists and has well-defined semantics for const lvalue references. That sort of implicit variable-declaration-and-reference-taking is often, but not necessarily, what happens. The two lines that do compile below are simple examples of where it does happen: they behave as if they create variables that last as long as <code>t</code> and <code>z</code> and then take reference to those variables.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" title="1"><span class="dt">int</span> x;</a>
<a class="sourceLine" id="cb18-2" title="2"><span class="dt">int</span>&amp;&amp; y = x;      <span class="co">// won&#39;t compile</span></a>
<a class="sourceLine" id="cb18-3" title="3"><span class="dt">int</span>&amp;&amp; t = <span class="dv">253</span>;    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb18-4" title="4"><span class="dt">int</span>&amp;&amp; z = x + <span class="dv">6</span>;  <span class="co">// OK</span></a></code></pre></div>
<p>The same rule applies when you’re calling a function that has a parameter with an rvalue reference:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb19-1" title="1"><span class="dt">void</span> f(<span class="dt">int</span>&amp;&amp; p) {}</a></code></pre></div>
<p>You can call this function as <code>f(253)</code>. If <code>x</code> is an <code>int</code> variable, you <em>cannot</em> call <code>f(x)</code> because the expression <code>x</code> is an lvalue, but you can call <code>f(x + 6)</code>. The rules defining the lifetime of the implicitly defined variable are the same as before: it lasts until the end of the full expression with the function call. (And for completeness, in a function <code>int&amp;&amp; f() { ... }</code>, you could <code>return</code> an rvalue and it would compile, but just as it was with const lvalue references, doing this would always produce a dangling reference, so you shouldn’t.)</p>
<p>Given that the above works, it may be a little surprising that defining <code>int&amp;&amp; y = x;</code> or calling <code>f(x)</code> doesn’t work, because it’s even easier to imagine the syntax sugar that it could expand to — you just initialize an implicit variable in the same way, but with the expression <code>x</code>. Sure, it’s an lvalue, but lvalues can be on the right side of an assignment too. However, it doesn’t work because making it hard for yourself to do that is sort of the point of having rvalue references. We’ll see how you could nevertheless force it to happen soon.</p>
<p>Another thing I should mention is that, like lvalue references, rvalue references can be const, and a non-const rvalue reference can only be initialized to a non-const rvalue. None of the rvalues we’ve seen so far have been non-const, and the idea of a non-const rvalue might even seem paradoxical — the point of an rvalue that it doesn’t have an address, so doesn’t that mean nobody else has a way to access it, so nobody will care or even notice if we modify an rvalue we got a reference to? We’ll see later how that’s false, so just keep this at the back of your mind for now.</p>
<p>But perhaps the most important thing to understand is that these are the rules for <em>initializing</em> an rvalue reference, not for <em>using</em> an rvalue reference in expressions. Even if the variable <code>y</code> is an rvalue reference to an <code>int</code>, the variable expression <code>y</code> will still be an lvalue — it has an address, which is the same as the address of the <code>int</code> it refers to. This is the number one confusing thing that every tutorial about rvalue references will invariably point out specifically,<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a> and I still had to read like five of these tutorials to really understand why, so let me try to spell it out as explicitly as possible.</p>
<p>If we have this variable declaration,</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb20-1" title="1"><span class="dt">int</span>&amp;&amp; v;</a></code></pre></div>
<p>the <strong>variable <code>v</code> has type rvalue reference <code>int&amp;&amp;</code></strong>, but you cannot describe it as an lvalue or rvalue. The <strong>variable expression <code>v</code> is an lvalue</strong> of type <code>int</code>. And in general, <strong>every variable expression</strong> — that’s every expression that consists solely of a single identifier of a variable — is <strong>always an lvalue</strong>, no matter whether that variable’s type is non-reference, lvalue reference, or rvalue reference. You should think of “lvalue reference” and “rvalue reference” as compound words that cannot be naively analyzed as the combination of the two words inside them, like how the compound word “hot dog” refers to something that is neither necessarily “hot” nor a “dog”. The first parts of those compound words refer to the rules surrounding their initialization, but have nothing to do with how they get used in expressions. After you’ve initialized a reference, it’s actually quite hard to tell whether it’s an lvalue reference or rvalue reference — every time you use it, you’ll just get an lvalue.<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a></p>
<p>Some concrete consequences are that you cannot initialize another rvalue reference to <code>v</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb22-1" title="1"><span class="dt">int</span>&amp;&amp; vv = v;  <span class="co">// won&#39;t compile</span></a></code></pre></div>
<p>Even though the variables <code>v</code> and <code>vv</code> have the same type, the variable <code>vv</code> can’t be initialized with the variable expression <code>v</code> because <code>vv</code>’s reference type doesn’t match <code>v</code>’s value category. For the exact same reason, if you have a function <code>f</code> that has an rvalue reference as a parameter, like the one defined above, you still can’t call <code>f(v)</code>.</p>
<p>More interesting than the value categories of variable expressions are the value categories of function call expressions. Here, the rules are as follows. If you write a function call expression that calls a function, and the function has a return type that is…</p>
<ul>
<li>a non-reference type <code>T</code>, then the function call expression is an rvalue, specifically a prvalue.</li>
<li>an lvalue reference type <code>T&amp;</code>, then the function call expression is an lvalue.</li>
<li>an rvalue reference type <code>T&amp;&amp;</code>, then the function call expression is an rvalue, specifically an xvalue. (These functions are quite rare, but the fact that they can now exist in C++11 is the entire reason this post exists and has, like, 11,000 words.)</li>
</ul>
<p>C++ operators are kind of like function calls — on instances of classes, they literally are calls to the special <code>operator+</code> functions and company, but even on primitives, you can basically think of arithmetic operators as like functions that return non-reference types, and assignment operators as like functions that return lvalue reference types. So if you are comfortable with the above list of understanding functions, you should be comfortable with determining the value category of quite a lot of expressions. However, you should be aware of implicit conversions secretly turning lvalues into rvalues and making them assignable to rvalue references. For example:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb23-1" title="1"><span class="dt">int</span> x = <span class="dv">6</span>;</a>
<a class="sourceLine" id="cb23-2" title="2"><span class="dt">float</span>&amp;&amp; y = x;  <span class="co">// this compiles! you&#39;re really assigning &quot;x, but cast to a float&quot;</span></a></code></pre></div>
<p>By the way, the value category of the function call expression is where the “mental inlining” I proposed earlier fails: if <code>ReturnType</code> and <code>VarType</code> are both rvalue references, the below compiles:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb24-1" title="1">ReturnType f() { <span class="cf">return</span> <span class="co">/* return expr */</span>; }</a>
<a class="sourceLine" id="cb24-2" title="2"></a>
<a class="sourceLine" id="cb24-3" title="3">VarType v = f();</a></code></pre></div>
<p>whereas the below does not:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb25-1" title="1">ReturnType ret = <span class="co">/* return expr */</span>;</a>
<a class="sourceLine" id="cb25-2" title="2">VarType v = ret; <span class="co">// the expression `ret` is always an lvalue :(</span></a></code></pre></div>
<p>We’ll see how to patch this mental inlining in a few sections.</p>
<h3 id="stdmove"><code>std::move</code></h3>
<p>We can now understand the standard library function <a href="https://en.cppreference.com/w/cpp/utility/move"><code>std::move</code></a> and resolve some earlier questions with it. The second most popular thing for rvalue reference tutorials to say is that <code>std::move</code> is kind of a misnomer. It doesn’t “move” anything. (“move” is not an idea with a strict technical definition anyway — it just loosely describes destructively operating on an object to move its data to another object.) All <code>std::move</code> does is cast its argument to an rvalue reference type and return it. It’s not a complicated function — you can find simple definitions of it all over the place, with varying degrees of pedagogical simplification<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a> — but when first trying to really understand it, I thought even the few lines of templating were kind of gross. What I found really illuminating was trying to write out the specializations of <code>std::move</code> that would work with a specific non-reference type, say, only <code>int</code>s. They’re very short.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb26-1" title="1"><span class="dt">int</span>&amp;&amp; move(<span class="dt">int</span>&amp;&amp; x) { <span class="cf">return</span> <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&amp;&amp;&gt;(x); }</a>
<a class="sourceLine" id="cb26-2" title="2"><span class="dt">int</span>&amp;&amp; move(<span class="dt">int</span>&amp; x) { <span class="cf">return</span> <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&amp;&amp;&gt;(x); }</a></code></pre></div>
<p><code>move</code> is nothing more than a punchily-named function that performs a typecast. (<code>static_cast</code> isn’t in the list of things I assume you understand, but it’s just the modern C++ way to cast expressions to types. And even in this case, appearances notwithstanding, the expression resulting from the <code>static_cast</code> isn’t a reference type; the reference-ness of the type just affects the value category of the resulting expression. Here, <code>static_cast</code> turns an lvalue into an rvalue, so that an rvalue reference can be initialized to it.) In the first instantiation, it doesn’t even do anything (but you would still need the <code>static_cast</code> to compile, because again, the variable expression <code>x</code> is an lvalue and <code>return x;</code> wouldn’t work in a function whose return type is an rvalue reference). But in the second instantiation, it does change the value category, which is exactly what we need. By calling it on an lvalue, you get an expression that’s an rvalue but refers to the same data.</p>
<p>Now, we know how to fix our code, where we tried to initialize an rvalue reference to an lvalue, that wouldn’t compile earlier (although whether we should is of course another question):</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb27-1" title="1"><span class="dt">int</span> x;</a>
<a class="sourceLine" id="cb27-2" title="2"><span class="dt">int</span>&amp;&amp; y = x;  <span class="co">// won&#39;t compile</span></a></code></pre></div>
<p>We just apply <code>std::move</code> to the expression we’re initializing the variable with:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb28-1" title="1"><span class="dt">int</span> x;</a>
<a class="sourceLine" id="cb28-2" title="2"><span class="dt">int</span>&amp;&amp; y = <span class="bu">std::</span>move(x);</a></code></pre></div>
<p>Note that this doesn’t implicitly declare a new variable and take a reference to it. <code>y</code> is actually truly a reference to <code>x</code>, so assigning to <code>y</code> will assign to <code>x</code> and vice versa.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb29-1" title="1"><span class="dt">int</span>&amp;&amp; y = <span class="bu">std::</span>move(x);</a>
<a class="sourceLine" id="cb29-2" title="2">y = <span class="dv">6</span>;  <span class="co">// also sets x to 6</span></a></code></pre></div>
<p>It’s almost exactly as if you had defined it as an lvalue reference instead:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb30-1" title="1"><span class="dt">int</span>&amp; y = x;</a></code></pre></div>
<p>We’ll see why this behavior is desirable in the next section. By contrast, if you had defined <code>y</code> with even a trivial expression that’s equal to <code>x</code>, you would have gotten a reference to something else, an implicit temporary variable. With the following definition of <code>y</code>, the variables <code>x</code> and <code>y</code> now refer to distinct <code>int</code> variables and can be assigned to without affecting each other.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb31-1" title="1"><span class="dt">int</span>&amp;&amp; y = x + <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb31-2" title="2">y = <span class="dv">6</span>;  <span class="co">// doesn&#39;t affect x</span></a></code></pre></div>
<p>There’s one more thing I haven’t mentioned: <code>std::move</code> preserves const-ness from its input type to its output type, so there are two more instantiations that are useful to know about:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb32-1" title="1"><span class="at">const</span> <span class="dt">int</span>&amp;&amp; move(<span class="at">const</span> <span class="dt">int</span>&amp;&amp; x) { <span class="cf">return</span> <span class="kw">static_cast</span>&lt;<span class="at">const</span> <span class="dt">int</span>&amp;&amp;&gt;(x); }</a>
<a class="sourceLine" id="cb32-2" title="2"><span class="at">const</span> <span class="dt">int</span>&amp;&amp; move(<span class="at">const</span> <span class="dt">int</span>&amp; x) { <span class="cf">return</span> <span class="kw">static_cast</span>&lt;<span class="at">const</span> <span class="dt">int</span>&amp;&amp;&gt;(x); }</a></code></pre></div>
<p>So calling <code>move</code> on a const lvalue will produce a const rvalue, which is something that you wouldn’t be able to initialize a non-const rvalue reference with:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb33-1" title="1"><span class="at">const</span> <span class="dt">int</span> x = <span class="dv">253</span>;</a>
<a class="sourceLine" id="cb33-2" title="2"><span class="dt">int</span>&amp;&amp; y = <span class="bu">std::</span>move(x);  <span class="co">// won&#39;t compile</span></a></code></pre></div>
<p>You should rarely need to write code that uses such an instantiation, but their existence will have consequences later.</p>
<h3 id="move-semantics">Move Semantics</h3>
<p>We can finally fully understand <strong>move semantics</strong> and how they’re implemented and used. As a reminder, I won’t spend much time motivating why move semantics are desirable; I linked some posts in the introduction of this post that do that instead. But the one-sentence goal of move semantics is that if you’re writing a function that does something with an object and might benefit from modifying it in-place or stealing its resources to use elsewhere (i.e. moving it), you’d want to know whether you’re allowed to do that.</p>
<p>To make things fully concrete, suppose you’re working with <code>vector&lt;int&gt;</code>s and you want to write a function <code>sorted</code> that takes a <code>vector&lt;int&gt;</code> and returns a sorted version of that vector. It would be nice to distinguish callers that don’t want their original vector to be modified from callers that don’t care, because in the latter case, you can sort the vector you received in-place for more efficiency and less memory allocation and return the same vector, and the caller won’t notice. That is, you’d want to write a function that works correctly for this caller:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb34-1" title="1">vector&lt;<span class="dt">int</span>&gt; x = {<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">9</span>};</a>
<a class="sourceLine" id="cb34-2" title="2"></a>
<a class="sourceLine" id="cb34-3" title="3"><span class="co">// shouldn&#39;t modify x, so it has to allocate a new vector</span></a>
<a class="sourceLine" id="cb34-4" title="4">vector&lt;<span class="dt">int</span>&gt; y = sorted(x);</a>
<a class="sourceLine" id="cb34-5" title="5"></a>
<a class="sourceLine" id="cb34-6" title="6"><span class="co">// x should still be {3, 1, 4, 1, 5, 9} here</span></a></code></pre></div>
<p>but is still efficient when called like this:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb35-1" title="1"><span class="co">// assuming this allocates a massive vector,</span></a>
<a class="sourceLine" id="cb35-2" title="2">vector&lt;<span class="dt">int</span>&gt; generateTestVector() { <span class="co">/* ... */</span> }</a>
<a class="sourceLine" id="cb35-3" title="3"></a>
<a class="sourceLine" id="cb35-4" title="4"><span class="co">// `sorted` shouldn&#39;t allocate an additional vector</span></a>
<a class="sourceLine" id="cb35-5" title="5">vector&lt;<span class="dt">int</span>&gt; y = sorted(generateTestVector());</a></code></pre></div>
<p>Okay, so you still can’t write a single (non-overloaded, non-templated) function that does this. But what you can do, as of C++11, is write two overloads of the same function that do accomplish this. The two overloads have parameters that are a const lvalue reference and a non-const rvalue reference, respectively:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb36-1" title="1">vector&lt;<span class="dt">int</span>&gt; sorted(<span class="at">const</span> vector&lt;<span class="dt">int</span>&gt;&amp; vec) { <span class="co">/* ... */</span> }</a>
<a class="sourceLine" id="cb36-2" title="2">vector&lt;<span class="dt">int</span>&gt; sorted(vector&lt;<span class="dt">int</span>&gt;&amp;&amp; vec) { <span class="co">/* ... */</span> }</a></code></pre></div>
<p>The first overload should copy the vector and allocate a new one; the second overload can modify the one it received. The first client above would call the first overload, because <code>x</code> is an lvalue; the second client above would call the second overload, because <code>generateTestVector()</code> is an rvalue. More often, this kind of overloading is used to write constructors and assignment operators (<code>operator=</code>), since you can’t rename those and there are many syntaxes that use them. All in all, this is a big improvement: you make a copy when you need to and don’t when you don’t.</p>
<p>However, if you’re a client of this function, you might sometimes find that you want to call it with an lvalue, say the variable expression <code>x</code>, as an argument, but you don’t want to preserve <code>x</code>. That is, you want the more efficient implementation of the function that won’t make a copy of <code>x</code>, at the cost of it potentially clobbering the contents of <code>x</code>. So you’d want a way to deliberately invoke the second overloading. Furthermore, note that you do not in fact want to do this by declaring a new variable <code>vector&lt;int&gt; xx = x;</code> and then somehow getting <code>sorted</code>’s parameter to be an rvalue reference to <code>xx</code>; nor do you want syntax that implicitly translates to code like that, because then <code>xx</code> would have to be a copy of <code>x</code>, and copying <code>x</code> is precisely the inefficiency you want to avoid. No, you want to convince <code>sorted</code> to have its rvalue reference refer to your variable <code>x</code>, even though the expression <code>x</code> is an lvalue.</p>
<p>That is precisely the setting for which <code>std::move</code> is designed. If you call <code>std::move</code> on the lvalue that you want to pass in as an argument, it makes the argument an rvalue, causing the second overload of <code>sorted</code> to be called instead of the first. However, crucially, when the second overload initializes its rvalue reference to that rvalue, it will refer to the same lvalue you supplied — no copy will occur.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb37-1" title="1">vector&lt;<span class="dt">int</span>&gt; x = {<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">9</span>};</a>
<a class="sourceLine" id="cb37-2" title="2"></a>
<a class="sourceLine" id="cb37-3" title="3"><span class="co">// `sorted` can only tell that you passed an rvalue, but in fact its</span></a>
<a class="sourceLine" id="cb37-4" title="4"><span class="co">// parameter will be an rvalue reference to `x`.</span></a>
<a class="sourceLine" id="cb37-5" title="5">vector&lt;<span class="dt">int</span>&gt; y = sorted(<span class="bu">std::</span>move(x));</a>
<a class="sourceLine" id="cb37-6" title="6"></a>
<a class="sourceLine" id="cb37-7" title="7"><span class="co">// Depending on how `sorted` is implemented, `x` may be destroyed here;</span></a>
<a class="sourceLine" id="cb37-8" title="8"><span class="co">// it likely will be if `sorted` is implemented efficiently.</span></a></code></pre></div>
<p>If you’d like to see this in a full program, we can use the <code>vector&lt;int&gt;</code> constructor, which is overloaded just like this:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb38-1" title="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb38-2" title="2"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a>
<a class="sourceLine" id="cb38-3" title="3"></a>
<a class="sourceLine" id="cb38-4" title="4"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb38-5" title="5">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; a = {<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">9</span>};</a>
<a class="sourceLine" id="cb38-6" title="6">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; b(a);  <span class="co">// copy b from a</span></a>
<a class="sourceLine" id="cb38-7" title="7">    <span class="bu">std::</span>cout &lt;&lt; a.size() &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb38-8" title="8">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c(<span class="bu">std::</span>move(a));  <span class="co">// move c from a</span></a>
<a class="sourceLine" id="cb38-9" title="9">    <span class="bu">std::</span>cout &lt;&lt; a.size() &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb38-10" title="10">}</a></code></pre></div>
<p>When I run this, it prints <code>6 0</code>. The first number must be <code>6</code> because we called the <code>vector&lt;int&gt;</code> constructor with an lvalue, so we would have called the overload with a const lvalue reference parameter, which is called the “copy constructor”<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a>. But intuitively, there’s no guarantee what the second number printed will be at all, because by passing <code>std::move(a)</code> into the <code>vector&lt;int&gt;</code> constructor when initializing <code>c</code>, we’re deliberately passing an rvalue to invoke the overload with a rvalue reference parameter, which is called the “move constructor”. Intuitively, that’s a way of saying, “do whatever you want with <code>a</code>, I don’t care about it any more.”<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a></p>
<p>So in terms of its relation to move semantics, <code>std::move</code> just sort of adds a flag to your lvalue expression saying, “Hey, I’m okay with being clobbered or otherwise moved out of”. (If you call <code>std::move</code> with an rvalue for an argument, it doesn’t really do anything.) But it’s up to the function receiving such an argument to notice that type-level flag and handle it by actually performing efficient move-semantics actions. If you didn’t overload <code>sorted</code> and only defined the version with the <code>const vector&lt;int&gt;&amp;</code> parameter, client code could still call it by passing an rvalue, possibly produced by calling <code>std::move</code> on an lvalue, and your code would work, but it would copy the vector once unnecessarily<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a> and no moving would occur. So <code>std::move</code> doesn’t necessarily imply moving at all; it’s just a suggestion to the function that it can be moved for efficiency, a suggestion that could be heeded, ignored, or even willfully misinterpreted.</p>
<p>One way it could be ignored is if you try to <code>std::move</code> a const lvalue. Consider this slight modification of our above program:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb39-1" title="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb39-2" title="2"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a>
<a class="sourceLine" id="cb39-3" title="3"></a>
<a class="sourceLine" id="cb39-4" title="4"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb39-5" title="5">    <span class="at">const</span> <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; a = {<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">9</span>};</a>
<a class="sourceLine" id="cb39-6" title="6">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; b(a);  <span class="co">// copy b from a</span></a>
<a class="sourceLine" id="cb39-7" title="7">    <span class="bu">std::</span>cout &lt;&lt; a.size() &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb39-8" title="8">    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c(<span class="bu">std::</span>move(a));  <span class="co">// still copy c from a!</span></a>
<a class="sourceLine" id="cb39-9" title="9">    <span class="bu">std::</span>cout &lt;&lt; a.size() &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb39-10" title="10">}</a></code></pre></div>
<p>This compiles fine, but it prints <code>6 6</code>: <code>c</code> was not able to move the data out of <code>a</code>. That’s because even though <code>std::move(a)</code> is still an rvalue, this time it’s a const rvalue, and can’t be used to initialize a non-const rvalue reference. But it can be used to initialize a const lvalue reference, so the compiler silently picks the overload of the constructor with that as its parameter, i.e. the copy constructor, instead. The overload with a non-const rvalue reference parameter will only be called on non-const rvalues, not all rvalues.</p>
<p>Even more dramatically: if you wanted, you could overload <code>sorted</code>, or any other constructor or assignment method, in a way such that it treats lvalues and rvalues exactly oppositely for move semantics! That is, you could write overloads of <code>sorted</code> that steal the resources from its argument if you pass in an lvalue argument via an lvalue reference parameter (although it would have to be non-const), but perform a shallow copy and allocate a new vector if you pass in an rvalue argument via an rvalue reference parameter (which could be const). The first behavior would likely break your clients’ code and the second behavior would be obtusely inefficient in most cases, but there’s no technical reason you couldn’t write this code. And if you did, then whenever one of your clients tries to pass an lvalue to your function as an argument, they would have to call <code>std::move</code> on it only if they <em>didn’t</em> want it to be moved. Hopefully that thought experiment really drives home how <code>std::move</code>, on its own, doesn’t do any moving at all.</p>
<p>Still, if you ever find yourself passing an lvalue into a function supporting move semantics and you don’t care about the lvalue any more, <code>std::move</code> may save you a copy. However, I must caution here that there’s one place you might think of using it immediately, in the <code>return</code> statement of a function returning an object it constructed, that you almost always shouldn’t.</p>
<p>The logic is compelling, to be sure. As we’ve discussed before, mentally inlining this</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb40-1" title="1">Thing make_thing() {</a>
<a class="sourceLine" id="cb40-2" title="2">    Thing inner_thing;</a>
<a class="sourceLine" id="cb40-3" title="3">    <span class="co">// maybe do stuff with inner_thing</span></a>
<a class="sourceLine" id="cb40-4" title="4">    <span class="cf">return</span> inner_thing;</a>
<a class="sourceLine" id="cb40-5" title="5">}</a>
<a class="sourceLine" id="cb40-6" title="6"></a>
<a class="sourceLine" id="cb40-7" title="7">Thing thing = make_thing();</a></code></pre></div>
<p>results in this code:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb41-1" title="1">Thing inner_thing;</a>
<a class="sourceLine" id="cb41-2" title="2"><span class="co">// maybe do stuff with inner_thing</span></a>
<a class="sourceLine" id="cb41-3" title="3">Thing ret = inner_thing;</a>
<a class="sourceLine" id="cb41-4" title="4">Thing thing = ret;</a></code></pre></div>
<p>That’s one constructor call and two copy constructor calls, because <code>inner_t</code> and <code>ret</code> are both lvalues. If we replaced <code>return Thing();</code> with <code>return std::move(Thing());</code>, then in the inlined version, we’d be able to invoke the move constructor rather than the copy constructor for <code>ret</code>. Assuming <code>Thing</code> implements move semantics sensibly, isn’t that better?</p>
<p>Actually, like I mentioned earlier, without the <code>std::move</code>, most compilers will already elide both copy constructor calls and directly construct the <code>Thing</code> into <code>t</code> because of return value optimization, or RVO. There’s a section in the RVO article I linked earlier on <a href="https://shaharmike.com/cpp/rvo/#returning-by-std-move">why returning by std::move() is an anti-pattern</a> and can even actively make things worse. Part of <cite>Effective Modern C++</cite>’s Item 25 also discusses this. I won’t belabor the details.</p>
<p>To sum up:</p>
<ul>
<li>Lvalue and rvalue references enable you to write functions or overloads of functions that can only be called with lvalues or rvalues as arguments.</li>
<li>This is useful because many functions can be implemented more efficiently if they know they can clobber or steal their argument’s resources (“moving”), which is strongly but not perfectly correlated with the argument being an rvalue.</li>
<li>If a caller has a variable that they are OK with being clobbered or stolen from, they might want to deliberately break the correlation above by casting their variable to an rvalue and passing that into a function. They can do that casting by calling <code>std::move</code>. However, whether the called function will recognize this and do any moving depends on its implementation and is purely a matter of convention, albeit a very strong one.</li>
</ul>
<h3 id="aside-reference-qualifiers">Aside: Reference Qualifiers</h3>
<p>Incidentally, class methods can also have <em>reference qualifiers</em> constraining whether they can be called on lvalues or rvalues, which look like <code>&amp;</code> or <code>&amp;&amp;</code> at the end of the signature:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb42-1" title="1"><span class="kw">class</span> Thing {</a>
<a class="sourceLine" id="cb42-2" title="2">  <span class="dt">void</span> method() &amp;; <span class="co">// only callable on lvalues</span></a>
<a class="sourceLine" id="cb42-3" title="3">  <span class="dt">void</span> method() &amp;&amp;; <span class="co">// only callable on rvalues</span></a>
<a class="sourceLine" id="cb42-4" title="4">};</a></code></pre></div>
<p>These notations turn the “implicit object parameter” into an lvalue reference or an rvalue reference, sort of as if <code>method</code> was declared as below, and if it were an operator or if C++ supported <a href="https://en.wikipedia.org/wiki/Uniform_function_call_syntax">Uniform Function Call Syntax</a> like D or Nim:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb43-1" title="1"><span class="dt">void</span> method(Thing&amp; thing);</a>
<a class="sourceLine" id="cb43-2" title="2"><span class="dt">void</span> method(Thing&amp;&amp; thing);</a></code></pre></div>
<p>You could use this feature to implement move semantics in methods in terms of the expression they’re invoked on. However, the convention for doing so is not as strong and this isn’t used in the standard library much (if at all?).</p>
<h3 id="reference-collapsing-universal-references-and-perfect-forwarding">Reference Collapsing, Universal References, and Perfect Forwarding</h3>
<p>Now that we understand move semantics, we turn to the second application of rvalue references in C++11: allowing <strong>perfect forwarding</strong>. Again, I won’t try to motivate this very hard, but it might be useful to understand the problem of perfect forwarding with the precise terminology we’ve worked out in this post so far. Let’s keep our setup simple: say you have a function <code>f</code>, which might have overloads and which you can’t change, and you want to write a function <code>g</code> so that calling <code>g</code> with some arguments behaves exactly like calling <code>f</code> with the same arguments. (Defining such a <code>g</code> could be useful if <code>g</code> also does something else additionally or postprocesses the return value of <code>f</code>.) So <code>g</code> would be “forwarding” calls it received to <code>f</code> instead. Let’s even make things easy and say we know <code>f</code> has a single parameter and we know its return type is <code>void</code>. Then a first attempt at implementing <code>g</code> would be:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb44-1" title="1"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="dt">void</span> g(T x) {</a>
<a class="sourceLine" id="cb44-2" title="2">    <span class="co">// maybe do other stuff here</span></a>
<a class="sourceLine" id="cb44-3" title="3">    f(x);  <span class="co">// very imperfect forwarding</span></a>
<a class="sourceLine" id="cb44-4" title="4">}</a></code></pre></div>
<p>This seems okay because <code>T</code> can be deduced to any type, including a reference type, so the parameter of <code>g</code> should be inferred to be the same type as the parameter of <code>f</code>. But, by applying what we’ve learned so far, we can see that that actually isn’t true because we lose the information of the value category of the argument. The argument <code>g</code> was called with might have been an lvalue or an rvalue, but the argument that <code>f</code> was called with, which is the variable expression <code>x</code>, is always an lvalue.</p>
<p>Concretely, if <code>f</code>’s parameter’s type is an rvalue reference, then we could have called <code>f</code> with an rvalue as an argument; but trying to call <code>g</code> with an rvalue as an argument will cause it to try to call <code>f</code> with an lvalue as an argument, which won’t work. Even worse, if <code>f</code> has two overloads that have an lvalue reference parameter and an rvalue reference parameter, respectively, our attempt at forwarding will silently always call the former overload even if passed an rvalue, and then <code>g</code> will not behave like <code>f</code> even though replacing a call to <code>f</code> with a call to <code>g</code> still resulted in code that compiles.</p>
<p>Before we get to how “universal references” resolve this issue, we need to talk about <strong>reference collapsing</strong>. Much earlier, I said that “you can’t have a reference of a reference”. This is sort of a half-truth. You can’t write <code>int&amp; &amp; y;</code> — it won’t compile, and you have no reason to, as we’ll see very soon. But you can get into a situation where you write something equivalent, with things like typedefs and template expansion. This code compiles:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb45-1" title="1"><span class="kw">typedef</span> <span class="dt">int</span>&amp; int_ref;</a>
<a class="sourceLine" id="cb45-2" title="2"><span class="dt">void</span> f(int_ref&amp; p) {}</a></code></pre></div>
<p>What is the type of the parameter <code>p</code>? Is it a reference to a reference to an <code>int</code>? Well, it turns out that taking a reference to a reference to a type <em>collapses</em> to just taking a reference to that type directly. The resulting type is an lvalue reference if either level of reference was an lvalue-reference; it’s an rvalue reference if both levels of reference were rvalue references. As a list:</p>
<ul>
<li><code>&amp; &amp;</code> = <code>&amp;</code></li>
<li><code>&amp; &amp;&amp;</code> = <code>&amp;</code></li>
<li><code>&amp;&amp; &amp;</code> = <code>&amp;</code></li>
<li><code>&amp;&amp; &amp;&amp;</code> = <code>&amp;&amp;</code></li>
</ul>
<p>It’s binary AND where <code>&amp;&amp;</code> is true. You can read more about <a href="https://en.cppreference.com/w/cpp/language/reference#Reference_collapsing">reference collapse on cppreference.com</a>. But, in any case, the trichotomy that every type is exactly one of a non-reference, lvalue reference, and rvalue reference remains complete. You can’t write <code>int&amp; &amp; y;</code> not because there’s no sensible definition, but because, in a rare instance of C++ preventing yourself from shooting yourself in the foot, you wouldn’t gain anything — that would be exactly equivalent to <code>int&amp; y;</code>.</p>
<p>With that in mind, a prototypical universal reference, useful for forwarding, is the type <code>T&amp;&amp;</code> of <code>v</code> in this templated function:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb46-1" title="1"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="dt">void</span> g(T&amp;&amp; v) {</a>
<a class="sourceLine" id="cb46-2" title="2">}</a></code></pre></div>
<p>As we learned about when we first met rvalue references, if you have a function <code>f(int&amp;&amp; x)</code> that has a parameter of type <code>int&amp;&amp;</code>, you can only call it with an argument that’s an rvalue. And in fact, if you had a function <code>g2</code> that was declared to take <code>T&amp;</code> (an lvalue reference to <code>T</code>) like so,</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb47-1" title="1"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="dt">void</span> g2(T&amp; v) {</a>
<a class="sourceLine" id="cb47-2" title="2">}</a></code></pre></div>
<p>you could only call <code>g2</code> with an argument that’s an lvalue. However, because of reference collapsing, you can pass either an lvalue or an rvalue as an argument to <code>g</code>!</p>
<ul>
<li>If you pass an lvalue of, say, type <code>int</code>, then <code>T</code> can be inferred to be <code>int&amp;</code>, so that the parameter is of type <code>int&amp; &amp;&amp; = int&amp;</code> (by reference collapsing).</li>
<li>If you pass an rvalue of type <code>int</code>, then <code>T</code> can be inferred to be <code>int</code> so that the parameter is of type <code>int&amp;&amp;</code>. (Passing an <code>int</code> rvalue would also work if <code>T</code> were inferred to be <code>int&amp;&amp;</code> and the parameter’s type would be <code>int&amp;&amp; &amp;&amp; = int&amp;&amp;</code>, and you could explicitly specify that <code>T</code> be <code>int&amp;&amp;</code> if you wanted, but that just turns out to not be how the template type inference rules are written.)</li>
</ul>
<p>This is why <code>T&amp;&amp;</code> is called a universal reference: it’s a reference, but it can be initialized to any argument, lvalue or rvalue, and for that matter, const or non-const.</p>
<p>Does that mean we’re done? Not at all: if we wrote,</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb48-1" title="1"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="dt">void</span> g(T&amp;&amp; v) {</a>
<a class="sourceLine" id="cb48-2" title="2">    f(v);  <span class="co">// just as imperfect</span></a>
<a class="sourceLine" id="cb48-3" title="3">}</a></code></pre></div>
<p>we would still always be passing an lvalue as an argument to <code>f</code>, and no amount of fiddling with the type of the parameter <code>v</code> or other aspects of the templating will fix this, because the variable expression <code>v</code> we’re passing as an argument is always an lvalue. To have a chance of passing an rvalue to <code>f</code>, we must pass it some other kind of expression. The best candidate (the only one we’ve really looked at in this post) would be a function call expression. And one function that will solve our problem neatly is the function <code>std::forward</code>.</p>
<p>Here’s how <code>std::forward</code>, which is a templated function taking one type variable <code>T</code>, works:</p>
<ul>
<li>If <code>T</code> is a non-reference (or rvalue reference, but this case won’t really be relevant), <code>std::forward&lt;T&gt;</code>’s return type is the rvalue reference <code>T&amp;&amp;</code> and its parameter type is the lvalue reference <code>T&amp;</code>. So the argument to <code>std::forward&lt;T&gt;</code> must be an lvalue and the result of calling <code>std::forward&lt;T&gt;(...)</code> will be an rvalue (specifically an xvalue).</li>
<li>If <code>T</code> is an lvalue reference, <code>std::forward&lt;T&gt;</code>’s return type is <code>T</code> itself, which is an lvalue reference, and its parameter type is also <code>T</code> itself, which is an lvalue reference. So the argument to <code>std::forward&lt;T&gt;</code> must be an lvalue and the result of calling <code>std::forward&lt;T&gt;(...)</code> will also be an lvalue.</li>
</ul>
<p>More briefly, the <code>int</code> specializations of <code>std::forward</code> are:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb49-1" title="1"><span class="dt">int</span>&amp;&amp; forward(<span class="dt">int</span>&amp; v) {} <span class="co">// forward&lt;int&gt; (and forward&lt;int&amp;&amp;&gt;)</span></a>
<a class="sourceLine" id="cb49-2" title="2"><span class="dt">int</span>&amp; forward(<span class="dt">int</span>&amp; v) {}  <span class="co">// forward&lt;int&amp;&gt;</span></a></code></pre></div>
<p>In particular, all specializations of <code>forward</code> have a parameter of lvalue reference type, so you can’t expect the desired reference-ness of <code>T</code> to be inferred solely based on the argument passed to <code>std::forward</code>. You will need to specify <code>T</code> yourself in order to get <code>forward</code> to do anything interesting. And that is exactly what we do to accomplish perfect forwarding:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb50-1" title="1"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="dt">void</span> g(T&amp;&amp; v) {</a>
<a class="sourceLine" id="cb50-2" title="2">    <span class="cf">return</span> f(<span class="bu">std::</span>forward&lt;T&gt;(v));  <span class="co">// &quot;perfect&quot; forwarding</span></a>
<a class="sourceLine" id="cb50-3" title="3">}</a></code></pre></div>
<p>It may help to imagine the <code>int</code> specializations of <code>g</code> as well. They simplify down to:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb51-1" title="1"><span class="dt">void</span> g(<span class="dt">int</span>&amp; v)  { f(v); }</a>
<a class="sourceLine" id="cb51-2" title="2"><span class="dt">void</span> g(<span class="dt">int</span>&amp;&amp; v) { f(<span class="bu">std::</span>move(v)); }</a></code></pre></div>
<p>The argument we supply to <code>forward</code> in <code>g</code> is always an lvalue, which tracks with the fact that <code>forward</code>’s parameter is always an lvalue reference. But you can work out how the forwarding occurs now:</p>
<ul>
<li>if <code>g</code> is called with an lvalue argument of type <code>A</code> (which must be non-reference — expressions aren’t reference types), then <code>T</code> will be inferred to be <code>A&amp;</code>, so <code>std::forward&lt;A&amp;&gt;</code> will have return type <code>A&amp;</code>. Thus, calling it will give an lvalue, so <code>f</code> will be called with an lvalue argument;</li>
<li>if <code>g</code> is called with an rvalue argument of type <code>A</code> (which, again, must be non-reference), then <code>T</code> will be inferred to be <code>A</code>, so <code>std::forward&lt;A&gt;</code> will have return type <code>A&amp;&amp;</code> and thus calling it will give an rvalue, so <code>f</code> will be called with an rvalue argument. What’s more, the argument is always passed by reference, so <code>f</code>’s parameter will be an rvalue reference to the exact same thing that <code>g</code>’s parameter references.</li>
</ul>
<p>That was a mouthful, but the result is perfect forwarding: <code>g</code> will call <code>f</code> with the same arguments it receives as the same value categories, so it behaves partially just as if you had called <code>f</code>.</p>
<p>For completeness, I’ll quickly mention that you can do perfect forwarding even without knowing how many arguments you’re trying to forward, by using a template <a href="https://en.cppreference.com/w/cpp/language/parameter_pack">parameter pack</a>. But in terms of the types and value categories involved, nothing fundamentally different is going on here. It would look like this, and is likely how you’ll actually see perfect forwarding in the wild or implement it in practice:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb52-1" title="1"><span class="kw">template</span>&lt;<span class="kw">typename</span>... Ts&gt; <span class="dt">void</span> g(Ts&amp;&amp;... v) {</a>
<a class="sourceLine" id="cb52-2" title="2">    f(<span class="bu">std::</span>forward&lt;Ts&gt;(v)...);</a>
<a class="sourceLine" id="cb52-3" title="3">}</a></code></pre></div>
<p>Perfect forwarding appears in the standard library in places such as the data structure “emplace” functions (e.g. <a href="https://en.cppreference.com/w/cpp/container/vector/emplace_back">vector::emplace_back</a> and <a href="https://en.cppreference.com/w/cpp/container/map/emplace">map::emplace</a>), smart pointer construction functions (e.g. <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique">std::make_unique</a> and <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared">std::make_shared</a>), <a href="https://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple">std::forward_as_tuple</a>, and probably others.</p>
<p>(Unsurprisingly, there are actually quite a few ways in which “perfect forwarding” is still imperfect: for some suitably crafted functions <code>f</code> and some arguments, the above <code>g</code> will not behave like <code>f</code>. If you want to learn about them, you may actually want to buy <cite>Effective Modern C++</cite> and read Item 30, because wowzers, there are some crazy corner cases and there’s no way I know enough C++ to cover them more effectively.)</p>
<p>Incidentally, <code>std::forward</code> also lets us patch the “manual inlining” model of understanding how functions return values. Ignoring scoping issues and lifetimes, this</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb53-1" title="1">ReturnType f() { <span class="cf">return</span> <span class="co">/* return expr */</span>; }</a>
<a class="sourceLine" id="cb53-2" title="2"></a>
<a class="sourceLine" id="cb53-3" title="3">VarType v = f();</a></code></pre></div>
<p>should be equivalent to this:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb54-1" title="1">ReturnType ret = <span class="co">/* return expr */</span>;</a>
<a class="sourceLine" id="cb54-2" title="2">VarType v = <span class="bu">std::</span>forward&lt;ReturnType&gt;(ret);</a></code></pre></div>
<p>The expression <code>std::forward&lt;ReturnType&gt;(ret)</code> has the same value category as a call expression to a function with return type <code>ReturnType</code>.<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a> Admittedly, we introduced another (templated!) function call with this patch, so if we’re trying to strictly simplify the rules we have to remember, we didn’t gain any ground, but I mentioned it in case it helps with intuition anyway.</p>
<h3 id="if-perfect-forwarding-is-so-good-why-isnt-there-a-perfect-forwarding-2">If perfect forwarding is so good why isn’t there a perfect forwarding 2</h3>
<p>A question to think about: Can you write a function that perfectly forwards two disjoint argument lists to two different functions?</p>
<p>That is, if you have two functions <code>f1</code> and <code>f2</code>, and you don’t know how many parameters either takes or what types they are, can you write a templated function <code>g</code> such that any caller of <code>g</code> can specify two lists of arguments, and <code>g</code> will behave just as if <code>f1</code> were called with the first list and <code>f2</code> were called with the second list?</p>
<p>It’s not easy, but <a href="https://en.cppreference.com/w/cpp/utility/pair/pair">std::pair has a constructor overload</a> that does it, which you have to invoke by prepending a <code>piecewise_constructor</code> argument and then packing things into a tuple. Honestly, though, I don’t understand this deeply and this post is already far too long, so I’ll leave it at that.</p>
<h3 id="some-unanswered-questions">Some unanswered questions</h3>
<p>We now understand deeply how C++11 uses rvalue references to achieve move semantics and perfect forwarding, but I don’t know if you have this mathematician’s unease that we made some arbitrary choices along the way about exactly how rvalue references work. In particular, are the reference collapse rules really “canonical”?</p>
<p>It seems that the most direct impetus for the choice of reference collapse rules is just to allow perfect forwarding by allowing universal references to exist — specifically to make it so that, under <code>template&lt;typename T&gt;</code>, the type <code>T&amp;&amp;</code> can be either an lvalue reference or an rvalue reference, but not a non-reference. What’s more, note that you do want the expression-in-terms-of-T to be simple and probably have direct syntax support, because you want to be able to infer <code>T</code> from the type and value category of your argument by following canonical, unsurprising rules when possible. It’s not sufficient to just say your parameter’s type is an unadorned type variable <code>T</code> and require that it be a reference through type utilities through other parts of the templating. That’s already possible with <a href="https://en.cppreference.com/w/cpp/types/enable_if">enable_if</a>:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb55-1" title="1"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;</a>
<a class="sourceLine" id="cb55-2" title="2"><span class="kw">typename</span> <span class="bu">std::</span>enable_if&lt;<span class="bu">std::</span>is_reference&lt;T&gt;, <span class="dt">void</span>&gt; f(T t) {</a>
<a class="sourceLine" id="cb55-3" title="3">}</a></code></pre></div>
<p>This does produce a function where <code>T</code> must be either an lvalue reference type or an rvalue reference type, and, depending on what <code>T</code> is, can either only be called with lvalues or only be called with rvalues. Unfortunately, <code>T</code> isn’t correctly inferred in calls. Given an argument, the compiler infers its non-reference type for <code>T</code>, which would have worked and would be the most sensible choice without the <code>enable_if</code>, but then finds that it fails to substitute because of the <code>enable_if</code> and doesn’t try to backtrack.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb56-1" title="1"><span class="dt">int</span> x = <span class="dv">6</span>;</a>
<a class="sourceLine" id="cb56-2" title="2">f(x);  <span class="co">// doesn&#39;t compile, infers T = int</span></a>
<a class="sourceLine" id="cb56-3" title="3">f(<span class="dv">6</span>);  <span class="co">// doesn&#39;t compile, infers T = int</span></a></code></pre></div>
<p>It does work if you explicitly specify <code>T</code>, but of course, that defeats the purpose of type inference entirely:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb57-1" title="1">f&lt;<span class="dt">int</span>&amp;&gt;(x);</a>
<a class="sourceLine" id="cb57-2" title="2">f&lt;<span class="dt">int</span>&amp;&amp;&gt;(<span class="dv">6</span>);</a></code></pre></div>
<p>So not only do we want a simple type-level expression in terms of <code>T</code> that can be either an lvalue reference or an rvalue reference but not a non-reference, the expression has to be “canonical” enough that we can standardize how to infer <code>T</code> given what kind of reference the expression is. And although we could make <code>T&amp;</code> that expression if we made references collapse the other way (so a reference of a reference would be an lvalue reference only if both original reference operations were lvalue references), we probably wouldn’t want to for backwards-compatibility. So choosing <code>T&amp;&amp;</code> and adopting the direction of reference collapsing to make it universal is a plausible choice.</p>
<p>Still, to the best of my knowledge, I suspect a version of C++ where references didn’t collapse (i.e. taking a reference of a reference would just fail to compile, whether or not there was a <code>typedef</code> or <code>using</code> in the way) and we found a different way to represent universal references would still hold up. One thing to observe is that, even if reference collapse were gone, it’s sufficient to implement perfect forwarding for a single argument with two overloads that take <code>T&amp;</code> and <code>T&amp;&amp;</code>. But we really want something more uniform so we can handle varargs (and so that, even for a finite, known number of arguments <i>n</i>, we don’t need 2<sup><i>n</i></sup> overloads). It’s possible to try to make the <code>enable_if&lt;is_reference&gt;</code> mess earlier work, because it sort of already means the right thing, but I don’t see a compelling way.</p>
<ul>
<li>One strategy to make it work is giving the compiler the intelligence to change its inference rules after seeing such a template expression, but that seems too much of a brittle special case.</li>
<li>Or we could make the compiler backtrack, trying both the non-reference type and the reference type for <code>T</code>, but that threatens exponential blow-up in compilation time with many parameters.</li>
</ul>
<p>Perhaps we could have chosen some brand new syntax that forces <code>T</code> to be a reference without affecting it, and causes <code>T</code> to be inferred to be either an lvalue reference or an rvalue reference. For example, the natural syntax extension I’m the most confident wouldn’t affect any other part of the syntax would be:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb58-1" title="1"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="dt">void</span> f(T&amp;&amp;&amp; p) {}  <span class="co">// made-up syntax</span></a></code></pre></div>
<p>It even seems useful if we could find a way to make this work with non-type-variables, something like:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb59-1" title="1"><span class="dt">void</span> f(<span class="dt">int</span>&amp;&amp;&amp; p) {}  <span class="co">// made-up syntax</span></a></code></pre></div>
<p>This would be a function that can take any <code>int</code> argument (in particular, causes arguments to be implicitly converted to <code>int</code>s), but takes it by reference and knows whether the argument was an lvalue or an rvalue. But there’s no obvious way or syntax for the function to access that knowledge. Perhaps we could make it so, if a variable’s type is an rvalue reference, its variable expressions is an rvalue? And to allow us to do everything with rvalue references we could do before, we might have an additional <code>std</code> function that casts rvalue references to lvalue references. But this is also doomed because you can’t wait until <code>f</code> is actually called to know if <code>p</code> is an lvalue or an rvalue — if you turn around and call another function with it, you might be calling different overloads with radically different behavior — so then you’d have to template the function twice, which is extremely suspicious if our made-up syntax doesn’t have any template variables in it.<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a> Attempting to retrofit other type machinery to dig the information out of <code>p</code>, for example with <code>decltype</code>, seems doomed to failure for the same reasons. Oh well.</p>
<p>Still, there are other ways reference collapse feels like a somewhat arbitrary consequence of trying to achieve a goal while maintaining backwards compatibility. For example, it’s quite annoying to write a templated function that can take arguments of any type, but only if they’re rvalues. That is, you’d want the function’s parameter type to be any rvalue reference, but not an lvalue reference or a non-reference. <a href="https://stackoverflow.com/questions/7863603/how-to-make-template-rvalue-reference-parameter-only-bind-to-rvalue-reference">StackOverflow shows it’s possible</a>, but it’s tough. Compare to how easy it is to write a templated function that can take arguments of any type, but only if they’re lvalues: <code>template&lt;typename T&gt; void f(T&amp; x)</code>, end of story. No matter whether <code>T</code> is an lvalue reference, an rvalue reference, or a non-reference, <code>T&amp;</code> will be an lvalue reference type (possibly via reference collapse), and given the type that <code>T&amp;</code> is equal to, the type that <code>T</code> should be inferred to be is obvious.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Rvalue references are a new type of variable or parameter in C++11 that can only be initialized to rvalues. Firstly, this lets you write functions or overloads of functions that only accept rvalues as arguments, which turns out to usually be a great way to detect whether you have permission to clobber your argument or take resources from it. In addition, <code>std::move</code> lets you explicitly give permission to such a function or overload of a function in a call where it would normally not detect it. Secondly, in conjunction with reference collapsing, rvalue references let you write a templated function that can tell whether its argument was an lvalue or an rvalue and make templating decisions accordingly. This enables you to write functions that preserve the value category of their arguments when calling other functions with them, an ability called perfect forwarding. These abilities make C++11 a much more powerful language than its predecessor, <s>just like your C++ skills are probably much more powerful than when you started reading this post</s> <s>which I guess justifies why they incremented the version number so much</s> <s>but Rust’s lifetimes are actually both better and simpler and nobody can convince me otherwise</s> why am I even bothering to write a conclusion, this isn’t an AP exam.</p>
<h3 id="changelog">Changelog</h3>
<ul>
<li>New footnote about <code>decltype</code> and its distinguishing variables from expressions. Edited other footnotes to refer to it.</li>
<li>New footnote on constructors.</li>
<li>New section on reference qualifiers.</li>
<li>New footnote on generic lambdas and potential implications.</li>
</ul>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>It may be more likely than you think. You can do it in <a href="https://kate.io/blog/2017/08/22/weird-python-integers/">Python</a>, you can do it in <a href="https://pedrorijo.com/blog/java-integer-cache/">Java</a>…<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Although this is a bit out of the way, one place this does make a visible difference in C++ is with <code>decltype</code>. If <code>x</code> is a variable or has a similarly simple form (I won’t list this out; refer to <a href="https://en.cppreference.com/w/cpp/language/decltype">cppreference.com on decltype</a>), <code>decltype(x)</code> gives the type of the variable, reference-ness and all. But on any more complicated expression, even <code>(x)</code>, <code>decltype</code> gives a type derived from the value category of the expression: lvalue reference for lvalue, rvalue reference for xvalue, and non-reference for prvalue. Here’s a program to show that:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="pp">#include </span><span class="im">&lt;utility&gt;</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co">// Undefined class template to elicit error with type (Item 4 of</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co">// Effective Modern C++)</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="kw">class</span> Elicit;</a>
<a class="sourceLine" id="cb4-5" title="5"></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="dt">int</span> x;</a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="co">// x is int, decltype(x) = int</span></a>
<a class="sourceLine" id="cb4-9" title="9">    Elicit&lt;<span class="kw">decltype</span>(x)&gt; t1;</a>
<a class="sourceLine" id="cb4-10" title="10">    <span class="co">// (x) is lvalue, decltype((x)) = int&amp; (!)</span></a>
<a class="sourceLine" id="cb4-11" title="11">    Elicit&lt;<span class="kw">decltype</span>((x))&gt; t2;</a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="co">// std::move(x) is xvalue, decltype((x)) = int&amp;&amp;</span></a>
<a class="sourceLine" id="cb4-13" title="13">    Elicit&lt;<span class="kw">decltype</span>(<span class="bu">std::</span>move(x))&gt; t3;</a>
<a class="sourceLine" id="cb4-14" title="14">    <span class="co">// 3 is prvalue, decltype((x)) = int</span></a>
<a class="sourceLine" id="cb4-15" title="15">    Elicit&lt;<span class="kw">decltype</span>(<span class="dv">3</span>)&gt; t4;</a>
<a class="sourceLine" id="cb4-16" title="16"></a>
<a class="sourceLine" id="cb4-17" title="17">    <span class="co">// rvalue reference we&#39;ll learn about later:</span></a>
<a class="sourceLine" id="cb4-18" title="18">    <span class="dt">int</span>&amp;&amp; y = <span class="bu">std::</span>move(x);</a>
<a class="sourceLine" id="cb4-19" title="19"></a>
<a class="sourceLine" id="cb4-20" title="20">    <span class="co">// y is int&amp;&amp;, decltype(x) = int&amp;&amp;</span></a>
<a class="sourceLine" id="cb4-21" title="21">    Elicit&lt;<span class="kw">decltype</span>(y)&gt; t5;</a>
<a class="sourceLine" id="cb4-22" title="22">    <span class="co">// (y) is lvalue, decltype((y)) = int&amp; (!)</span></a>
<a class="sourceLine" id="cb4-23" title="23">    Elicit&lt;<span class="kw">decltype</span>((y))&gt; t6;</a>
<a class="sourceLine" id="cb4-24" title="24">}</a></code></pre></div>
<p>This might not seem too bad since, whenever you see <code>decltype</code>, you can immediately tell what variable or expression it’s being applied to. But it can get into much spookier action-at-a-distance when applied to <code>auto</code>. To steal another example from <cite>Effective Modern C++</cite>, Item 3:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">decltype</span>(<span class="kw">auto</span>) f1() { <span class="co">// deduced as returning int</span></a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="dt">int</span> x;</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="co">// imagine lots of other code here</span></a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="cf">return</span> x;</a>
<a class="sourceLine" id="cb5-5" title="5">}</a>
<a class="sourceLine" id="cb5-6" title="6"><span class="kw">decltype</span>(<span class="kw">auto</span>) f2() { <span class="co">// deduced as returning int&amp; (!)</span></a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="dt">int</span> x;</a>
<a class="sourceLine" id="cb5-8" title="8">    <span class="co">// imagine lots of other code here</span></a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="cf">return</span> (x); <span class="co">// dangling reference (!!)</span></a>
<a class="sourceLine" id="cb5-10" title="10">}</a></code></pre></div>
<a href="#fnref2" class="footnote-back">↩</a></li>
<li id="fn3"><p>Well, you could shoehorn it in with code like</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="dt">int</span>* p = <span class="kw">nullptr</span>;</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="dt">int</span>&amp; x = *p;</a></code></pre></div>
<p>but you really shouldn’t. Don’t take my word for it, the <a href="https://isocpp.org/wiki/faq/references#refs-not-null">C++ FAQ</a> is perfectly adamant about it.<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>Although the full example is contrived, note that if you pass a lvalue to <code>silly</code>, it just returns a reference to the same lvalue; there’s no undefined behavior, and a function with similar parameter and return types could be useful (e.g. producing a const reference to a field in a struct that it also takes by const reference). And, you can write a function that takes a const reference, does computations with it, and returns a non-reference, which also wouldn’t cause any undefined behavior:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" title="1"><span class="dt">int</span> add_one(<span class="at">const</span> <span class="dt">int</span>&amp; x) {</a>
<a class="sourceLine" id="cb13-2" title="2">    <span class="cf">return</span> x + <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb13-3" title="3">}</a></code></pre></div>
<p>So <code>silly</code>’s type and the action of passing an rvalue as an argument to a function with <code>silly</code>’s parameter’s type could both individually make sense (so it’s plausible that compilers don’t warn about the above code), but when combined as in the contrived example above, they don’t.<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>See also this <a href="http://josuttis.com/cpp/c++initialization.pdf">table by Nicolai Josuttis</a> for the plethora of syntaxes C++ has for initialization.<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>Section 5 of Thomas Becker’s explainer is dedicated to the question: <a href="http://thbecker.net/articles/rvalue_references/section_05.html">“Is an Rvalue Reference an Rvalue?”</a>. Jonathan Boccara bolds it twice in <a href="https://www.fluentcpp.com/2018/02/06/understanding-lvalues-rvalues-and-their-references/">“Understanding lvalues, rvalues and their references”</a>. It gets stated explicitly in literally page 3 of <cite>Effective Modern C++</cite> in the first code snippet in the introduction.<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>If you try, you can at least do it with <code>decltype</code> and <a href="https://en.cppreference.com/w/cpp/types">type support utilities</a>. There may be much easier ways; I’m not good enough at C++ to know. But note that, as mentioned in an earlier footnote, this hinges crucially on the fact that <code>decltype</code> may treat the thing you apply it to as a variable rather than an expression. Anything that can’t do that is doomed.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb21-1" title="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb21-2" title="2"></a>
<a class="sourceLine" id="cb21-3" title="3"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb21-4" title="4">    <span class="co">// print booleans as &quot;true&quot; or &quot;false&quot; instead of 1 or 0</span></a>
<a class="sourceLine" id="cb21-5" title="5">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha;</a>
<a class="sourceLine" id="cb21-6" title="6"></a>
<a class="sourceLine" id="cb21-7" title="7">    <span class="dt">int</span> t = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb21-8" title="8">    <span class="at">const</span> <span class="dt">int</span>&amp; x = t;</a>
<a class="sourceLine" id="cb21-9" title="9">    <span class="dt">int</span>&amp;&amp; y = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb21-10" title="10">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Is x an lvalue reference? &quot;</span>;</a>
<a class="sourceLine" id="cb21-11" title="11">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>is_lvalue_reference&lt;<span class="kw">decltype</span>(x)&gt;::value &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb21-12" title="12">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Is x an rvalue reference? &quot;</span>;</a>
<a class="sourceLine" id="cb21-13" title="13">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>is_rvalue_reference&lt;<span class="kw">decltype</span>(x)&gt;::value &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb21-14" title="14"></a>
<a class="sourceLine" id="cb21-15" title="15">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Is y an lvalue reference? &quot;</span>;</a>
<a class="sourceLine" id="cb21-16" title="16">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>is_lvalue_reference&lt;<span class="kw">decltype</span>(y)&gt;::value &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb21-17" title="17">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Is y an rvalue reference? &quot;</span>;</a>
<a class="sourceLine" id="cb21-18" title="18">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>is_rvalue_reference&lt;<span class="kw">decltype</span>(y)&gt;::value &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb21-19" title="19">}</a></code></pre></div>
<a href="#fnref7" class="footnote-back">↩</a></li>
<li id="fn8"><p>Examples include in <a href="https://www.artima.com/cppsource/rvalue.html">A Brief Introduction to Rvalue References</a> and in Item 23 of <cite>Effective Modern C++</cite>.<a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p>The constructor with this exact signature, one parameter of type const lvalue reference to the class the constructor is defined on, is one of a few special methods in that it has a default implementation where it just copies all the fields with each field’s copy constructors. If the class satisfies certain constraints and you don’t opt-out explicitly, the compiler will generate such a constructor automatically. You can also explicitly request this default implementation with <code>= default</code>.</p>
<p>In addition to this constructor, called the copy constructor, the other constructors and methods with default implementations are the default (parameterless) constructor, the move constructor (taking one <code>Thing&amp;&amp;</code> parameter), the copy assignment operator (taking one <code>const Thing&amp;</code> parameter), the move assignment operator (taking one <code>Thing&amp;&amp;</code> parameter), and the destructor. For more details, <a href="https://en.cppreference.com/w/cpp/language/classes">cppreference.com’s classes page</a> links to each of these.<a href="#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p>However, if you actually look it up, <code>vector</code>’s move-constructor — <a href="https://en.cppreference.com/w/cpp/container/vector/vector">constructor overload (8) on cppreference.com</a>, as of time of writing — actually explicitly states that the moved-from vector will be <code>empty()</code>, so this program is guaranteed to print <code>6 0</code>. <code>vector</code>’s move-assignment-operator <a href="https://en.cppreference.com/w/cpp/container/vector/operator%3D">overload (2)</a> might have been a better example: the moved-from vector is “in a valid but unspecified state afterwards.” But the intuitive role that <code>std::move</code> plays is the same.<a href="#fnref10" class="footnote-back">↩</a></p></li>
<li id="fn11"><p>Well, there’s no guarantee this copy will happen — it’s possible the compiler will optimize it away.<a href="#fnref11" class="footnote-back">↩</a></p></li>
<li id="fn12"><p>Okay, fine, this is another lie: if <code>ReturnType</code> is a non-reference, then <code>std::forward&lt;ReturnType&gt;(ret)</code> will be an xvalue, but the call expression will be a prvalue. But they’re either both lvalues or both rvalues, which is good enough.<a href="#fnref12" class="footnote-back">↩</a></p></li>
<li id="fn13"><p>But one reason to have hope anyway is that, as of C++14, <code>auto</code> can also introduce templating in lambdas (“generic lambdas”). Declaring a lambda like this:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb60-1" title="1"><span class="kw">auto</span> f = [](<span class="kw">auto</span> x) { <span class="co">/* ... */</span> };</a></code></pre></div>
<p>roughly declares an implicit class with a templated <code>operator()</code> function like</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb61-1" title="1"><span class="kw">class</span> Imaginary {</a>
<a class="sourceLine" id="cb61-2" title="2">    <span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="kw">operator</span>()(T x) { <span class="co">/* ... */</span> };</a>
<a class="sourceLine" id="cb61-3" title="3">};</a></code></pre></div>
<p>and then initializes <code>f</code> to an instance of this class. This also works if you replace <code>auto</code> with <code>auto&amp;&amp;</code>: <code>T</code> becomes <code>T&amp;&amp;</code>, a universal reference. And then, you can in fact use <code>decltype(x)</code> to dig out the deduced reference-ness of the parameter, which tells you whether the argument is an lvalue or rvalue.</p>
<p>Admittedly, <code>auto</code> already shared a lot of the same type deduction machinery as templates in C++11, so perhaps this is natural. And this doesn’t actually make <code>f</code>’s type itself templated: it’s an instance of a concrete class, just one with a multitude of instantiations of one method. We’re trying to come up with syntax that turns a method declaration into a templated one with many instantiations.<a href="#fnref13" class="footnote-back">↩</a></p></li>
</ol>
</section></article>
	<footer class="post-footer">
		
	</footer>
	<script data-isso="//node.vero.site/isso/" data-isso-css="false" src="//node.vero.site/isso/js/embed.min.js"></script>
	<section id="isso-thread"></section>
	<p class="comments-meta">(note: the commenting setup here is experimental and I may not check my comments often; if you want to tell <em>me</em> something instead of the world, email me!)</p>
	
	
	
	<footer class="post-footer">
		<nav class="pagination">
			
			<a class="pagination-previous" href="//blog.vero.site/post/45">← 45/101</a>
			
			
			<a class="pagination-next" href="//blog.vero.site/post/advent-leaderboard">Advent of Code: How to Leaderboard →</a>
			
		</nav>
	</footer>
</section>
<footer class="site-footer">
	<p>© 2017-2021 betaveros, Bounded-Error Log</p>
	<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />Except where otherwise noted, content on this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
	<p>Powered by <a href="https://gohugo.io/">Hugo</a>, <a href="http://pandoc.org/">pandoc</a>,
	<a href="https://www.goatcounter.com/">GoatCounter</a>,
	<a href="https://posativ.org/isso/">Isso</a>,
	<a href="https://pages.github.com/">GitHub Pages</a>, and
	<a href="https://www.cloudflare.com/">CloudFlare</a>.
	</p>
	<p>Opinions are mine and not of any employer, past or present.</p>
</footer>

<script src="/katex/katex.min.js"></script>
<script src="/katex/contrib/auto-render.min.js"></script>
<script>renderMathInElement(document.body);</script>
<script src="/js/bundle.js"></script>
<script>window.goatcounter = { path: function(p) { return '/blog' + p; } }</script>
<script data-goatcounter="https://node.vero.site:8073/count" async src="https://node.vero.site:8073/count.js"></script>
<script src="/js/jquery-3.2.1.min.js"></script>


</div></body>
</html>
