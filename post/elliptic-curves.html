<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8" />
<title>Just Enough Elliptic Curves to Be Dangerous</title>

<meta name="author" content="betaveros" />
<meta name="description" content="A famous Trail of Bits post says to stop using RSA: it’s simple enough to make people think they can implement it correctly, but full of invisible traps. In contrast, although elliptic curve cryptography (ECC) implementations could also fall into subtle traps, they usually don’t. The post conjectures that this is because ECC intimidates people into using cryptographically sound libraries instead of implementing their own.
If you do want to understand ECC just enough to produce your own trap-ridden implementation, though, this post aims to get you there. (Assuming some mathematical background chosen in a not particularly principled way, approximately what I had before writing this post.) Hence the title. Because I have a cryptographic conscience, I will still point out the traps I know of; but there are probably traps I don’t know about.
This post contains a lot of handwaving and straight-up giving up on proofs. You don’t need to know the proofs to be dangerous. The ethos is sort of like Napkin, but way shoddier and with zero pretense of pedagogical soundness. Still, here are some concrete questions that I learned the answer to while writing this post:
 Why does the group law hold, sort of intuitively? Why do people have to modify Curve25519 before using it to compute digital signatures? What is a “quadratic twist” and why should I care about it to pick a secure elliptic curve? How is it possible that an isogeny can be described surjective but not injective while mapping a finite elliptic curve to another elliptic curve of the same cardinality? How many claws does an alligator have?  Elliptic curves have a lot of complicated algebra. If you ever studied algebra in high school and did exercises where you had to simplify or factor or graph some really complicated algebraic expression, and you learned that algebra is also the name of a field in higher mathematics, you might have assumed that working algebraists just dealt with even more complicated expressions. If you then studied algebra in college, you’d probably have realized that that’s not really what algebra is about at all; the difficulty comes from new abstractions, like a bunch of the terms above.
Well… the study of elliptic curves involves a bunch of complicated expressions like what your high school self might have imagined. Sometimes, notes will just explode into a trainwreck of terms like
\[\begin{align*}\psi_1 &amp;amp;= 1 \\ \psi_2 &amp;amp;= 2y \\ \psi_3 &amp;amp;= 3x^4 &#43; 6Ax^2 &#43; 12Bx - A^2 \\ \psi_4 &amp;amp;= 4y(x^6 &#43; 5Ax^4 &#43; 20Bx^3 - 5A^2x^2 - 4ABx - A^3 - 8B^2).\end{align*}\]
“This is REAL Math, done by REAL Mathematicians,” one is tempted to quip. The Explicit-Formulas Database is a fun place to take a gander through. I will copy formulas into this post from time to time when there’s something about them I want to call attention to, but in general we won’t do any complicated algebraic manipulations in this post. Just be prepared.
Because I’m focusing on conceptual understanding (and am lazy), this post contains almost no code, and definitely no code that’s runnable in any real programming language.
" /><meta name="generator" content="Hugo 0.88.0-DEV" />

<link rel="canonical" href="//blog.vero.site/post/elliptic-curves" />
<link rel="alternative" href="/index.xml" title="Bounded-Error Log" type="application/atom+xml" />

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="format-detection" content="telephone=no,email=no,adress=no" />
<meta http-equiv="Cache-Control" content="no-transform" />

<meta name="robots" content="index,follow" />
<meta name="referrer" content="origin-when-cross-origin" />
<meta name="theme-color" content="#330000" />
<meta name="twitter:creator" content="@betaveros">

<link rel="icon" href="/favicon.ico" />

<link rel="stylesheet" href="/css/bundle.css" />
<link rel="stylesheet" href="/katex/katex.min.css" />

<!--[if lte IE 11]>
    <script src="//cdn.bootcss.com/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

</head>
<body><div id="wrapper">
<header class="site-header"><h2 class="title"><a href="/">Bounded-Error Log</a></h2><p class="subtitle">theoretical and applied randomness by <a href="https://beta.vero.site/">betaveros</a></p>
<button class="menu-toggle" type="button" aria-label="Toggle Menu">
	<span class="icon icon-menu" aria-hidden="true"></span>
</button>
<nav class="site-menu collapsed">
	<h2 class="offscreen">Main Menu</h2>
	<ul class="menu-list"><li class="menu-item "><a href="/about">About</a></li><li class="menu-item "><a href="/category/life">Life</a></li><li class="menu-item "><a href="/category/thoughts">Thoughts</a></li><li class="menu-item "><a href="/category/self-analysis">Self-Analysis</a></li><li class="menu-item "><a href="/category/math">Math</a></li><li class="menu-item "><a href="/category/cs">CS</a></li><li class="menu-item "><a href="/category/puzzles">Puzzles</a></li><li class="menu-item "><a href="/category/meta">Meta</a></li><li class="menu-item "><a href="/util">Utilities</a></li><li class="menu-item "><a href="/all">All Posts</a></li></ul>
</nav>
<nav class="social-menu collapsed">
	<h2 class="offscreen">Social Networks</h2>
	<ul class="social-list"><li class="social-item">
			<a href="//github.com/betaveros" title="GitHub" aria-label="GitHub"><span class="icon icon-github" aria-hidden="true"></span></a>

		</li><li class="social-item">
			<a href="/index.xml" title="RSS" aria-label="RSS"><span class="icon icon-rss" aria-hidden="true"></span></a>
		</li>
	</ul>
</nav>
</header>

<section class="main post-detail">
	<header>
		<h1 class="post-title">Just Enough Elliptic Curves to Be Dangerous</h1>
		
		<p class="post-meta">
		
		2021-11-28
		(15683 words)
		
		<span class="post-categories">
			filed under
			<a href="/category/math">Math</a>
		</span>
		
		</p>
	</header>
	<article><p>A famous Trail of Bits post says to <a href="https://blog.trailofbits.com/2019/07/08/fuck-rsa/">stop using RSA</a>: it’s simple enough to make people think they can implement it correctly, but full of invisible traps. In contrast, although elliptic curve cryptography (ECC) implementations could also fall into subtle traps, they usually don’t. The post conjectures that this is because ECC intimidates people into using cryptographically sound libraries instead of implementing their own.</p>
<p>If you do want to understand ECC just enough to produce your own trap-ridden implementation, though, this post aims to get you there. (Assuming some mathematical background chosen in a not particularly principled way, approximately what I had before writing this post.) Hence the title. Because I have a cryptographic conscience, I will still point out the traps I know of; but there are probably traps I don’t know about.</p>
<p>This post contains a lot of handwaving and straight-up giving up on proofs. You don’t need to know the proofs to be dangerous. The ethos is sort of like <a href="https://web.evanchen.cc/napkin.html">Napkin</a>, but way shoddier and with zero pretense of pedagogical soundness. Still, here are some concrete questions that I learned the answer to while writing this post:</p>
<ul>
<li>Why does the group law hold, sort of intuitively?</li>
<li>Why do people have to modify Curve25519 before using it to compute digital signatures?</li>
<li>What is a “quadratic twist” and why should I care about it to pick a secure elliptic curve?</li>
<li>How is it possible that an isogeny can be described surjective but not injective while mapping a finite elliptic curve to another elliptic curve of the same cardinality?</li>
<li>How many claws does an alligator have?</li>
</ul>
<p>Elliptic curves have a lot of complicated algebra. If you ever studied algebra in high school and did exercises where you had to simplify or factor or graph some really complicated algebraic expression, and you learned that algebra is also the name of a field in higher mathematics, you might have assumed that working algebraists just dealt with even more complicated expressions. If you then studied algebra in college, you’d probably have realized that that’s not really what algebra is about at all; the difficulty comes from <em>new abstractions</em>, like a bunch of the terms above.</p>
<p>Well… the study of elliptic curves involves a bunch of complicated expressions like what your high school self might have imagined. Sometimes, notes will just explode into a trainwreck of terms like</p>
<p><span class="math display">\[\begin{align*}\psi_1 &amp;= 1 \\ \psi_2 &amp;= 2y \\ \psi_3 &amp;= 3x^4 + 6Ax^2 + 12Bx - A^2 \\ \psi_4 &amp;= 4y(x^6 + 5Ax^4 + 20Bx^3 - 5A^2x^2 - 4ABx - A^3 - 8B^2).\end{align*}\]</span></p>
<p>“This is REAL Math, done by REAL Mathematicians,” one is tempted to quip. The <a href="https://hyperelliptic.org/EFD/">Explicit-Formulas Database</a> is a fun place to take a gander through. I will copy formulas into this post from time to time when there’s something about them I want to call attention to, but in general we won’t do any complicated algebraic manipulations in this post. Just be prepared.</p>
<p>Because I’m focusing on conceptual understanding (and am lazy), this post contains almost no code, and definitely no code that’s runnable in any real programming language.</p>
<h3 id="background">Background</h3>
<p>To understand all of this post, you’ll need to be comfortable with quite a few things. The first and most obvious is basic <a href="https://en.wikipedia.org/wiki/Modular_arithmetic">modular arithmetic</a>; if you’re not, I don’t have a resource to suggest offhand, but there’s “not that much” and the Wikipedia article is probably an okay starting point. I go over some of the slightly more advanced facts in the first subsection below.</p>
<p>You’ll also probably want to know basic abstract algebra: groups, rings, fields, and particularly <span class="math inline">\(\mathbb{F}_p\)</span>. Linear algebra is probably required too. (Amusingly, I believe you <em>don’t</em> need to know anything about the rationals <span class="math inline">\(\mathbb{Q}\)</span>, the reals <span class="math inline">\(\mathbb{R}\)</span>, or the complex numbers <span class="math inline">\(\mathbb{C}\)</span>. Everything is finite in our world.) If this is all new to you, you may be able to get some of these prerequisites from <a href="https://web.evanchen.cc/napkin.html">Napkin</a>, but the prerequisites don’t have a neat shape. If you have learned these things before but it’s been a long time, the second subsection below has a speedy recap.</p>
<p>You should also feel free to skip this entire section and come back to it on a need-to-know basis. I know I would.</p>
<h4 id="background-modular-arithmetic-quadratic-residues-and-square-roots">Background: Modular arithmetic, quadratic residues, and square roots</h4>
<p>We will be working in <span class="math inline">\(\mathbb{F}_p\)</span>, that is in the field of integers modulo some prime <span class="math inline">\(p\)</span>, very often, so let’s quickly review some facts. The key things to understand here are (1) what happens to quadratic residues and quadratic nonresidues when they’re multiplied and (2) that square roots can be computed mod <span class="math inline">\(p\)</span>, so if you understand those you can skip this section. In finite fields of the form <span class="math inline">\(\mathbb{F}_p\)</span>,</p>
<ul>
<li>Inverses exist: for every nonzero <span class="math inline">\(a \in \mathbb{F}_p\)</span>, there exists <span class="math inline">\(b\)</span> such that <span class="math inline">\(ab = 1\)</span>.</li>
<li>(Fermat’s little theorem:) for every nonzero <span class="math inline">\(a \in \mathbb{F}_p\)</span>, <span class="math inline">\(a^{p-1} = 1\)</span>. The smallest positive integer <span class="math inline">\(m\)</span> such that <span class="math inline">\(a^m = 1\)</span> is called the <strong>order</strong> of <span class="math inline">\(a\)</span>; it follows that <span class="math inline">\(m\)</span> divides <span class="math inline">\(p - 1\)</span>.</li>
<li>The multiplicative group <span class="math inline">\(\mathbb{F}_p^\times\)</span> is <em>cyclic</em>; that is, there exists an element <span class="math inline">\(g\)</span> (sometimes called a <em>primitive root</em>) such that <span class="math inline">\(\{g^x \mid x \in \{0, \ldots, p-1\}\}\)</span> is the set of all nonzero elements of <span class="math inline">\(\mathbb{F}_p\)</span>.</li>
<li>If an element <span class="math inline">\(x \in \mathbb{F}_p\)</span> is a square of some element, it is called a <em>quadratic residue</em>; otherwise, it is a <em>quadratic nonresidue</em>.</li>
<li>If <span class="math inline">\(p &gt; 2\)</span>, then for every nonzero <span class="math inline">\(a \in \mathbb{F}_p\)</span>, we have <span class="math inline">\(a^{\frac{p-1}{2}} \in \{-1, 1\}\)</span>. Furthermore, <span class="math inline">\(a^{\frac{p-1}{2}} = 1\)</span> iff <span class="math inline">\(a\)</span> is a quadratic residue. As corollaries:
<ul>
<li>The product of two quadratic residues is a quadratic residue.</li>
<li>The product of a quadratic residue and a quadratic nonresidue is a quadratic nonresidue.</li>
<li>The product of two quadratic nonresidues is a quadratic residue.</li>
<li>The inverse of a quadratic residue is a quadratic residue; the inverse of a quadratic nonresidue is a quadratic nonresidue.</li>
</ul></li>
<li>If <span class="math inline">\(p &gt; 2\)</span>, exactly half of the <span class="math inline">\(p - 1\)</span> nonzero elements of <span class="math inline">\(\mathbb{F}_p\)</span> are quadratic residues.</li>
</ul>
<p>Now let’s consider how to compute a square root of a quadratic residue modulo a prime <span class="math inline">\(p &gt; 2\)</span>. (I believe what follows is the “Tonelli-Shanks algorithm”. It’s not the most efficient known algorithm, but it’s good enough for our purposes.)</p>
<p>Write <span class="math inline">\(p - 1 = s \cdot 2^r\)</span> where <span class="math inline">\(s\)</span> is odd (we’ll have <span class="math inline">\(r \geq 1\)</span> since <span class="math inline">\(p\)</span> is odd), and say we have <span class="math inline">\(a\)</span> that we know is a quadratic residue mod <span class="math inline">\(p\)</span> and want to compute a square root.</p>
<ul>
<li><p>If <span class="math inline">\(r = 1\)</span> (i.e. <span class="math inline">\(p = 2s + 1\)</span>, <span class="math inline">\(p \equiv 3 \bmod 4\)</span>), this is really easy: <span class="math inline">\(b := a^{\frac{s+1}{2}}\)</span> works.</p></li>
<li><p>If not, it’s still a good candidate because <span class="math inline">\(b^2 = a^{s+1}\)</span> is a factor of <span class="math inline">\(a^s\)</span> off, but <span class="math inline">\(a^{s\cdot 2^r} = 1\)</span>, so <span class="math inline">\(a^s\)</span> has order dividing <span class="math inline">\(2^r\)</span>. In fact, since <span class="math inline">\(a\)</span> is a quadratic residue, <span class="math inline">\(a^s\)</span> is as well, and it has order dividing <span class="math inline">\(2^{r-1}\)</span>. Intuitively that means there’s a <span class="math inline">\(1/2^{r-1}\)</span> “probability” that <span class="math inline">\(b\)</span> is correct anyway, and if not we’ve reduced the problem of finding a square root of <span class="math inline">\(a\)</span> to finding a square root of this low-order element <span class="math inline">\(a^s\)</span>.</p>
<p>To handle this simpler problem, let <span class="math inline">\(u\)</span> be an element with order <span class="math inline">\(2^r\)</span>. (This can be computed from any quadratic nonresidue <span class="math inline">\(t\)</span>: just set <span class="math inline">\(u = t^s\)</span>, and you can find a quadratic nonresidue by just randomly picking elements in <span class="math inline">\(\mathbb{F}_p\)</span> until you find one; half the elements are quadratic nonresidues, so you should find one quickly. Not having reasonable worst-case bounds might still be moderately dissatisfying, but you can also precompute <span class="math inline">\(u\)</span> or <span class="math inline">\(t\)</span> for any given <span class="math inline">\(p\)</span> so it’s not a big deal. There are specific applications where this still isn’t good enough, but they’re rare.)</p>
<p>Then the square root of <span class="math inline">\(a^s\)</span> is a power of <span class="math inline">\(u\)</span>. More explicitly, there is some <span class="math inline">\(k\)</span> such that <span class="math inline">\(u^{2k} = a^s\)</span>, and we want to find <span class="math inline">\(u^k\)</span>. In particular, if <span class="math inline">\(r = 2\)</span>, then <span class="math inline">\(u\)</span> is actually a square root of <span class="math inline">\(a^s\)</span>, and we’re done. Even in the general case, we can determine <span class="math inline">\(k\)</span> bit by bit as follows: multiply <span class="math inline">\(a^s\)</span> by <span class="math inline">\(u^{2^j}\)</span> for increasing <span class="math inline">\(j\)</span> and see if it decreases the order of <span class="math inline">\(a^s\)</span>.</p></li>
</ul>
<h4 id="background-abstract-algebra-speedrun">Background: Abstract algebra speedrun</h4>
<p>This is just a refresher, not an attempt to teach you these things! A lot of this section is written extremely technically imprecisely.</p>
<ul>
<li><p>An <strong>abelian group</strong> is a set where you can add and subtract: that is, a set equipped with an addition operation <span class="math inline">\((+)\)</span> that has an identity (called the <em>zero</em>) and is associative, commutative, and invertible. (Groups, without the “abelian” adjective, differ only in that they lack the commutativity property.)</p>
<ul>
<li>One can prove that all finite abelian groups are products of cyclic groups <span class="math inline">\(\mathbb{Z}/n\mathbb{Z}\)</span> (integers modulo <span class="math inline">\(n\)</span> under addition): that is, each element is a tuple of elements from those groups, and all operations happen componentwise. It’s possible to be even more precise, but that’s not super necessary.</li>
</ul></li>
<li><p>A <strong>ring</strong> is a set where you can add, subtract, and multiply, but where multiplication might be noncommutative: that is, a set equipped with an addition operation <span class="math inline">\((+)\)</span> and zero and a multiplication operation <span class="math inline">\((\cdot)\)</span> and one, such that the field is an abelian group under addition and zero, multiplication is associative and has one as an identity, and the distributive law holds.</p></li>
<li><p>A <strong>field</strong> is a ring where multiplication is commutative and you can divide: that is, a ring where the nonzero elements of the field form an abelian group under multiplication and one.</p></li>
<li><p>In vague terms, a “structure-preserving map” is a function <span class="math inline">\(\phi : A \to B\)</span> between two “things” (e.g. groups, rings, vector spaces) <span class="math inline">\(A, B\)</span> of the same kind, such that any operation (e.g. <span class="math inline">\(+\)</span>) or special elements (e.g. <span class="math inline">\(0\)</span>) are preserved by the map: <span class="math inline">\(\phi(a + b) = \phi(a) + \phi(b)\)</span>, <span class="math inline">\(\phi(0_A) = 0_B\)</span>, and so on. Note that <span class="math inline">\(\phi\)</span> need not be injective or surjective.</p>
<ul>
<li>A structure-preserving map on most algebraic structures, in particular groups, is a <strong>homomorphism</strong>.</li>
<li>A structure-preserving map from a structure to itself is an <strong>endomorphism</strong>.</li>
<li>A structure-preserving map with an inverse that’s also structure-preserving (implying that both are bijections) is an <strong>isomorphism</strong>.</li>
<li>An endomorphism that’s an isomorphism is an <strong>automorphism</strong>.</li>
<li>The <strong>kernel</strong> of a structure-preserving map is the set of things it maps to <span class="math inline">\(0\)</span>.</li>
</ul></li>
<li><p>In vague terms, you can consider an algebraic structure <span class="math inline">\(X\)</span> “modulo” some substructure or operation by considering things related by the substructure or operation as “the same”. More formally, you create a new algebraic structure <span class="math inline">\(X&#39;\)</span> whose elements are equivalence classes of <span class="math inline">\(X\)</span> under some equivalence relation and inherits the same algebraic operations. Of course, a lot of conditions are required for the inherited operation to be well-defined.</p>
<ul>
<li>(Aside: A “normal subgroup” of a group is a subset that’s itself a group and that you can mod by. An “ideal” of a ring is a subset that’s itself a ring and that you can mod by. These terms aren’t defined in any textbook this way, but I think they’re the “morally correct” ways to think about these concepts.)</li>
</ul></li>
<li><p>The substructure <strong>generated</strong> by some set of elements in a structure is the set of elements you can get by repeatedly applying the structure’s operations to only that set. For example, the subgroup generated by <span class="math inline">\(\{3\}\)</span> in <span class="math inline">\(\mathbb{Z}/12\mathbb{Z}\)</span> is <span class="math inline">\(\{0, 3, 6, 9\}\)</span>; those are the numbers you can get by repeatedly adding 3 to itself mod 12.</p></li>
<li><p>The <strong>characteristic</strong> of a field <span class="math inline">\(\text{char}(\mathbb{K})\)</span> is the number of times you add one to itself to get back to zero, or zero if that never happens. You can prove that the characteristic is always zero or a prime.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>Basically, the characteristic of <span class="math inline">\(\mathbb{Q}\)</span>, <span class="math inline">\(\mathbb{R}\)</span>, and <span class="math inline">\(\mathbb{C}\)</span> are all 0, and the characteristic of <span class="math inline">\(\mathbb{F}_p\)</span>, <span class="math inline">\(\mathbb{F}_{p^k}\)</span>, <span class="math inline">\(\overline{\mathbb{F}_p}\)</span> are all <span class="math inline">\(p\)</span>. In full generality, all fields contain either <span class="math inline">\(\mathbb{Q}\)</span> or <span class="math inline">\(\mathbb{F}_p\)</span> (just look at the subfield generated by 1) and that determines the characteristic.</p></li>
<li><p>The <strong>algebraic closure</strong> of a field <span class="math inline">\(\mathbb{K}\)</span>, denoted <span class="math inline">\(\overline{\mathbb{K}}\)</span>, is the field extension (basically just a larger field) you get by adding all the roots of every (nontrivial) polynomial with coefficients in <span class="math inline">\(\mathbb{K}\)</span>. (It is unique up to isomorphism.) The most familiar example is that <span class="math inline">\(\mathbb{C}\)</span> is the algebraic closure of <span class="math inline">\(\mathbb{R}\)</span>.</p></li>
<li><p>Finally, one important algorithm: the <strong>repeated doubling</strong> algorithm lets you “multiply” a “thing” <span class="math inline">\(x\)</span> by a positive integer <span class="math inline">\(n\)</span> if you only know how to add, in <span class="math inline">\(O(\log n)\)</span> additions. In a nutshell, you compute it recursively as <span class="math inline">\(A(x, 2n) = A(x, n) + A(x, n)\)</span> and <span class="math inline">\(A(x, 2n+1) = A(x, 2n) + x\)</span>. You’ve probably done this if you’ve ever implemented modular exponentiation in a programming competition. We will use this in a few places for other kinds of “multiplication”. (There are ways to optimize the constant factors in this algorithm even more, but we won’t concern ourselves with them.)</p></li>
</ul>
<h3 id="definition-of-an-elliptic-curve">Definition of an elliptic curve</h3>
<p>With all that out of the way, let’s get started!</p>
<p>An <strong>elliptic curve</strong> over a field <span class="math inline">\(\mathbb{K}\)</span> is a smooth projective curve of genus 1 with a distinguished (<span class="math inline">\(\mathbb{K}\)</span>-rational) point.</p>
<p>This is a lot of words. Let’s break it down.</p>
<ul>
<li>The <strong>projective plane</strong> <span class="math inline">\(\mathbb{P}^2(\mathbb{K})\)</span> over a field <span class="math inline">\(\mathbb{K}\)</span> can be tersely defined as the set of nonzero three-dimensional points <span class="math inline">\((x : y : z)\)</span> (where <span class="math inline">\(x, y, z \in \mathbb{K}\)</span>) modulo scaling (i.e. for any <span class="math inline">\(\lambda \neq 0\)</span>, <span class="math inline">\((x : y : z)\)</span> is the same point as <span class="math inline">\((\lambda x : \lambda y : \lambda z)\)</span>. The next section is about ways to view it.</li>
<li>A <strong>curve</strong> is given by a homogeneous polynomial function <span class="math inline">\(f(x, y, z)\)</span> that is <em>irreducible</em> (can’t be factored) <em>even over <span class="math inline">\(\overline{\mathbb{K}}\)</span></em> (!), and can be viewed as the set of points where that polynomial evaluates to 0. The polynomial is required to be homogeneous (all terms are the same degree, where the degree of a term is the total of the degrees of <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, and <span class="math inline">\(z\)</span>) so that this evaluation is well-defined on points modulo scaling, and is required to be irreducible so that the curve doesn’t turn out to be secretly two curves in a trenchcoat. (As an example, <span class="math inline">\(x^2 + 2y^2\)</span> (the equation <span class="math inline">\(x^2 + 2y^2 = 0\)</span>) is not a curve over <span class="math inline">\(\mathbb{R}\)</span> even though it’s irreducible there, because it is reducible in <span class="math inline">\(\mathbb{C}\)</span>.)</li>
<li>A curve is <strong>smooth</strong> if its three partial derivatives are never all zero. This matches the intuitive geometric meaning of the word “smooth” if the field is <span class="math inline">\(\mathbb{R}\)</span>; we just generalize it naively to all fields.</li>
<li><strong>Genus one</strong> means… honestly, I’m not really sure. I’m told it matches the topological definition of “number of holes in a sphere” (a sphere has genus 0, a torus has genus 1…) but I don’t know how many holes anything has in four dimensions (two complex dimensions). I’m going to leave this as “we’ll handwave it when we see it”.</li>
<li>A <strong>distinguished point</strong> just means the point is part of the definition. If you have two copies of the same curve or polynomial, but distinguish different points on them, you get two different elliptic curves.</li>
</ul>
<h3 id="the-projective-plane">The projective plane</h3>
<blockquote>
<p>“Lines that are parallel<br />
meet at Infinity!”<br />
Euclid repeatedly,<br />
heatedly,<br />
    urged.<br />
Until he died,<br />
and so reached that vicinity:<br />
in it he<br />
found that the damned things diverged.<br />
</p>
<p>— Piet Hein, Grooks VI</p>
</blockquote>
<p>In terms of why the projective plane <span class="math inline">\(\mathbb{P}^2(\mathbb{K})\)</span> is worth studying, its most defining property is that every pair of lines intersects at exactly one point. (The dual, through every pair of points there is exactly one line, is still true, just like it is in Euclidean spaces.) In other words, there are no “parallel” lines. There are a few equivalent ways to understand or visualize the projective plane (in contrast to the Euclidean plane <span class="math inline">\(\mathbb{K}^2\)</span>, which may also be called the <em>affine plane</em> when directly contrasting the two):</p>
<ul>
<li>One can view it as an extension of the Euclidean plane: to such a plane, add a <strong>point at infinity</strong> for every “direction” (a direction is an equivalence class of parallel lines, so directions are the same as their opposites) and a single <strong>line at infinity</strong> that passes through precisely the set of points at infinity. A line in the Euclidean plane passes through exactly one point at infinity, the one matching its direction. Although the special cases are sort of inelegant, this view is nice in that it lets us think about (and compute!) two coordinates instead of three.</li>
<li>Another way to view it is as the (two-dimensional) surface of a (three-dimensional) sphere, where lines are great circles (which are in fact the shortest paths between two points) and antipodes are considered the same point.</li>
</ul>
<p>The terse definition we gave earlier turns out to be the easiest way to talk about the projective plane concretely with coordinates, though, which is important to analyze it algebraically. To repeat a bit, a projective point is a triplet of coordinates <span class="math inline">\((x : y : z)\)</span>, not all zero, modulo scaling: that is, if <span class="math inline">\(\lambda \neq 0\)</span>, then <span class="math inline">\((x : y : z)\)</span> is the same point as <span class="math inline">\((\lambda x : \lambda y : \lambda z)\)</span>. One can visualize a projective “point” as a line in three-dimensional Euclidean space that passes through the origin, and a projective line as a plane that also passes through the origin. It’s also easy to relate this visualization back to the two earlier perspectives:</p>
<ul>
<li>To recover the Euclidean-plane-and-things-at-infinity view, just take the intersection of each line with the plane <span class="math inline">\(z = 1\)</span>; lines that intersect that plane correspond to that point on the plane; lines in the plane <span class="math inline">\(z = 0\)</span> correspond to points at infinity, and the plane <span class="math inline">\(z = 0\)</span> is the line at infinity. We will use this view extensively; when we write a projective point as <span class="math inline">\((x, y)\)</span>, it will be shorthand for <span class="math inline">\((x : y : 1)\)</span>, with the understanding that points at infinity cannot be represented this way.</li>
<li>To recover the sphere view, just take the intersection of each line with a sphere centered at the origin.</li>
</ul>
<h3 id="elliptic-curves-the-weierstrass-equation">Elliptic curves: the Weierstrass equation</h3>
<p>Let <span class="math inline">\(\mathbb{K}\)</span> be a field. It could be <span class="math inline">\(\mathbb{Q}\)</span>, <span class="math inline">\(\mathbb{R}\)</span>, <span class="math inline">\(\mathbb{C}\)</span>, a finite field <span class="math inline">\(\mathbb{F}_p\)</span> or even <span class="math inline">\(\mathbb{F}_{p^k}\)</span>, and so on; but for our cryptographic purposes, <span class="math inline">\(\mathbb{K}\)</span> will probably be <span class="math inline">\(\mathbb{F}_p\)</span> for a large prime <span class="math inline">\(p\)</span>, typically close to <span class="math inline">\(2^{256}\)</span>. However, we will still have to care about the algebraic closure of <span class="math inline">\(\mathbb{F}_p\)</span>. (Occasionally, cryptography is done on a large characteristic-2 finite field <span class="math inline">\(\mathbb{F}_{2^k}\)</span>, but this is outside the scope of this post.)</p>
<p>Let <span class="math inline">\(\text{char}(\mathbb{K}) \neq 2, 3\)</span> and let <span class="math inline">\(A, B \in \mathbb{K}\)</span> with <span class="math inline">\(4A^3 + 27B^2 \neq 0\)</span>. (This is to avoid degenerate cases. A lot of theory still applies if <span class="math inline">\(\mathbb{K}\)</span> is characteristic 2 or 3, but you sometimes end up with your hands tied unable to do some algebraic simplifications you really want to. It seems like a fair assumption for my motivations.) Then the <strong>(short) Weierstrass equation</strong> <span class="math inline">\(y^2 = x^3 + Ax + B\)</span> with the distinguished projective point <span class="math inline">\((0 : 1 : 0)\)</span> defines an elliptic curve.</p>
<p>(Beware! We will extensively write equations like this and pretend that the points on this elliptic curve are the pairs <span class="math inline">\((x, y)\)</span> satisfying the equation in addition to that distinguished point, the point at infinity in the <span class="math inline">\(x = 0\)</span> direction, which will sometimes just be denoted <span class="math inline">\(\infty\)</span>. However, the equation is “really” the homogeneous cubic <span class="math inline">\(y^2z = x^3 + Axz^2 + Bz^3\)</span>.)</p>
<p>Up to isomorphism, every elliptic curve can be defined this way! (This is not obvious. We haven’t even defined what an isomorphism is for our purposes.) For example, if you have an elliptic curve defined by <span class="math inline">\(y^2 = x^3 + Cx^2 + Ax + B\)</span>, you can substitute <span class="math inline">\(x = x&#39; - C/3\)</span> and get something absurd like:</p>
<p><span class="math display">\[y^2 = x&#39;^3 + (A - C^2/3)x&#39; + (B + 2C^3/27 - AC^3/3).\]</span></p>
<p>I don’t know if I got the later terms right, but the point is that this is a curve in Weierstrass form, and the simple bijection <span class="math inline">\((x, y) \mapsto (x + C/3, y)\)</span> maps every point in the original curve to a point in this one. You can make similar substitutions to curve equations with more coefficients to get them into Weierstrass form. However, note that in the above example, we assume you can divide by 3; if you can’t because <span class="math inline">\(\text{char}(\mathbb{K})\)</span> is 3, this doesn’t work, and similar problems arise if <span class="math inline">\(\text{char}(\mathbb{K})\)</span> is 2, which is why we ban those cases above.</p>
<p>If you permit a few extra terms, you get a “general Weierstrass equation” that works for all fields, but I won’t bother here.</p>
<h4 id="other-equations">Other equations</h4>
<p>Although short Weierstrass form is probably the most canonical way to write equations for elliptic curves to study them abstractly, there are other forms popular in cryptography. Particularly notable are <em>Montgomery curves</em>, which take the form <span class="math display">\[By^2 = x^3 + Ax^2 + x.\]</span></p>
<p>Two also important alternative models of elliptic curves are <em>Edwards curves</em> of the form <span class="math display">\[x^2 + y^2 = 1 + Dx^2y^2\]</span> and slightly generalized <em>twisted Edwards curves</em> of the form <span class="math display">\[Ax^2 + y^2 = 1 + Dx^2y^2.\]</span> Which, just to be clear, is technically the homogeneous quartic <span class="math display">\[Ax^2z^2 + y^2z^2 = z^4 + Dx^2y^2\]</span> over the projective plane.</p>
<p><strong>WARNING:</strong> Many sources gloss over this point, but Edwards curves and twisted Edwards curves are “not technically elliptic curves” because they are not smooth at their points at infinity (namely, <span class="math inline">\((1 : 0 : 0)\)</span> and <span class="math inline">\((0 : 1 : 0)\)</span>)! They can be <em>desingularized</em> into the “curve” <span class="math display">\[Ax^2 + y^2 = z^2 + Dt^2,\; xy = tz\]</span> in the “projective space” <span class="math inline">\(\mathbb{P}^3(\mathbb{K})\)</span> of 4-tuples <span class="math inline">\((x : y : z : t)\)</span>, not all zero, modulo scaling.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> Tuples with <span class="math inline">\(z \neq 0\)</span> can be scaled to affine points <span class="math inline">\((x : y : 1 : xy)\)</span>, which are in one-to-one correspondence with affine points <span class="math inline">\((x : y : 1)\)</span> on the Edwards curve. However, this new curve has four points at infinity, <span class="math inline">\((\pm\sqrt{D/A} : 0 : 0 : 1)\)</span> and <span class="math inline">\((0 : \pm\sqrt{D} : 0 : 1)\)</span>, instead of two. Note that <span class="math inline">\(\sqrt{D/A}\)</span> and <span class="math inline">\(\sqrt{D}\)</span> may not exist in whatever field <span class="math inline">\(\mathbb{K}\)</span> we’re working over — in fact, we’ll later see that we <em>prefer</em> they don’t exist — but they definitely exist in the algebraic closure <span class="math inline">\(\overline{\mathbb{K}}\)</span>. Our definition doesn’t have any carve-out for curves specified by projective spaces with two equations, but most sources just handwave over this, so I will too.</p>
<h4 id="a-few-famous-curves">A few famous curves</h4>
<p>This section contains quite a few terms I haven’t defined yet, but I thought that getting to see the concrete objects we care about would be somewhat illuminating.</p>
<ul>
<li><strong>NIST P-256</strong> (<a href="https://csrc.nist.gov/publications/detail/fips/186/2/archive/2000-01-27">NIST, 2000</a>): One of several curves in that standard. <span class="math display">\[y^2 = x^3-3x+B \bmod 2^{256} - 2^{224} + 2^{192} + 2^{96} - 1\]</span> where <span class="math inline">\(B\)</span> equals <small>41058363725152142129326129780047268409114441015993725554835256314039467401291</small>. One of the earliest curves to be heavily standardized, but looked upon with some suspicion due to the unexplained large constant coefficient that might be a backdoor. It also predates modern EC cryptographic demands like Montgomery ladder support and twist security.</li>
<li><strong>secp256k1</strong> (<a href="https://www.secg.org/SEC2-Ver-1.0.pdf">Certicom Research, 2000 (PDF)</a>; <a href="https://safecurves.cr.yp.to/refs.html#2000/certicom-sec2">cr.yp.to ref</a>): <span class="math display">\[y^2 = x^3+7 \bmod {2^{256} - 2^{32} - 977}.\]</span> One of several curves in that publication. Its claim to fame is probably being the curve used for signatures in Bitcoin. Although cryptographers aren’t concerned about a backdoor on this curve, it still fails some modern demands like P-256.</li>
<li><strong>Curve25519</strong> (<a href="https://cr.yp.to/papers.html#curve25519">Bernstein, 2006</a>): <span class="math display">\[y^2 = x^3 + 486662x^2 + x \bmod {2^{255} - 19}.\]</span> Chosen very carefully for efficiency, but without sacrificing any safety guarantees, including many discovered after 2000. Probably the vanguard of “modern curves”. Quite popular, although the original paper focuses on the Kummer variety of the curve rather than the curve itself, making it excellent for Diffie-Hellman but not a direct fit for more advanced algorithms. As a result, this is also often used in the form of its twisted Edwards curve, <span class="math display">\[-x^2 + y^2 = 1 - \frac{121665}{121666}x^2y^2 \bmod {2^{255} - 19}.\]</span></li>
</ul>
<!--
- **Curve1174** ([Bernstein, Hamburg, Krasnova, Lange, 2013](https://eprint.iacr.org/2013/325)): $$x^2+y^2 = 1-1174x^2y^2 \bmod {2^{251} - 9}.$$ Designed to support Elligator 1, an algorithm about converting strings to points; otherwise, has some advantages and some disadvantages compared to Curve25519.
- **Ed448-Goldilocks** ([Hamburg 2015? (PDF)](https://eprint.iacr.org/2015/625.pdf)): $$x^2+y^2 = 1-39081x^2y^2 \bmod 2^{448} - 2^{224} - 1.$$ One of quite a few modern curves over larger fields, for those with conservative security demands.
-->
<h3 id="the-group-operation-and-group-law">The group operation and group law</h3>
<p>I think most pop science explainers of elliptic curves already have nice pictures of this, so I’ll take it a bit more slowly.</p>
<p>Interesting fact: Over any given fixed field, <strong>a line that intersects an elliptic curve at least twice always intersects it at exactly three points,</strong> where points of tangency count double.</p>
<ul>
<li>Geometrically, this might be a bit surprising or hard to visualize. One simpler case that helped me be intuitively less surprised: a unit circle is a curve such that a line that intersects it once must intersect it twice, again counting points of tangency double.</li>
<li>However, it’s very easy to prove algebraically: to find the intersections of an elliptic curve <span class="math inline">\(E\)</span> and a line <span class="math inline">\(\ell\)</span>, you substitute the line’s equation into the elliptic curve’s equation to get a cubic in <span class="math inline">\(x\)</span> and then count how many roots it has. If that cubic has two solutions in any given field, it has a third, because you can factor out the first two roots as linear factors to get a final linear factor.</li>
</ul>
<p>We will now define <strong>addition of two points on the elliptic curve</strong> (a commutative group operation) to satisfy this short, punchy “functional equation”: <strong>three points on a line sum to zero.</strong> Wait, but what is zero? We <em>define</em> zero to be the <em>distinguished point</em>, usually called <span class="math inline">\(O\)</span>, our elliptic curve comes with. Maybe a less sequence-breaking way to say it is that we define group inverses to be such that the distinguished point is zero, i.e., the inverse of a point <span class="math inline">\(P\)</span> is the third point that the line through <span class="math inline">\(P\)</span> and <span class="math inline">\(O\)</span> intersects the elliptic curve at, and then define addition so that the functional equation works out. (It’s not obvious that these definitions are coherent, but that’s what we’ll explore in the rest of this section.)</p>
<p>So, although the functional equation is punchy, the explicit group operation is a little more work to describe and goes like this: Let <span class="math inline">\(O\)</span> be the distinguished point. To add two points <span class="math inline">\(P, Q\)</span> on an elliptic curve:</p>
<ul>
<li>Draw the line through <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> and let <span class="math inline">\(R\)</span> be the third point where the line intersects the curve (which could equal <span class="math inline">\(P\)</span> or <span class="math inline">\(Q\)</span> in case of tangency, and could be the point at infinity).</li>
<li>Draw the line through <span class="math inline">\(R\)</span> and <span class="math inline">\(O\)</span> and let <span class="math inline">\(R&#39;\)</span> be the third point where the line intersects the curve (same caveats).</li>
<li>Then <span class="math inline">\(P + Q = R&#39;\)</span>.</li>
</ul>
<p>When the curve is in Weierstrass form, we will just about always choose the unique point at infinity on the elliptic curve, <span class="math inline">\((0 : 1 : 0)\)</span>, as our distinguished point. In that case, the middle part of the above description becomes a bit simpler: <span class="math inline">\(R&#39;\)</span>, the negation of <span class="math inline">\(R\)</span>, is just the reflection of <span class="math inline">\(R\)</span> about the <span class="math inline">\(x\)</span>-axis. To actually implement this, you could work out all the algebra in the above description to produce formulas that you can put into your program, but in practice, you can just get them from the <a href="https://hyperelliptic.org/EFD/">Explicit-Formulas Database</a>. But I think it’s worth saying this explicitly: you <em>could</em> choose a random other distinguished point that isn’t the point at infinity and define addition and inverses around it, and the theory still works. Computation just gets waaaay more complicated.</p>
<p>Defined as such, it’s pretty obvious that addition is commutative and that inverses “work”. However, it is extremely nonobvious that addition is associative.</p>
<h4 id="proof-the-group-operation-is-associative">Proof the group operation is associative</h4>
<p><em>Proof.</em> (Playing fast and loose; a small variant ripped from 18.783 with a phantom point instead of a proof by contradiction)</p>
<p>Suppose we want to prove that <span class="math inline">\(P + (Q + R) = (P + Q) + R\)</span>. Consider the following diagram, where all labeled points are points on the elliptic curve.</p>
<p><a href="/img/ec-group-law.png"><img src="/img/ec-group-law.png" alt="Three mostly horizontal lines (h1, h2, h3) and three roughly vertical lines (v1, v2, v3) intersecting at nine points. The center point is unlabeled; the other intersections are labeled, clockwise from top left, Q, R, −(Q+R), Q+R, O, P+Q, −(P+Q), and P. On h2 right of the unlabeled intersection is the point S' = −(P+(Q+R)); on v2 below the unlabeled intersection is the point S = −((P+Q)+R)." /></a></p>
<p>We want to prove that <span class="math inline">\(S = S&#39;\)</span>. However, we will use a slight detour: we will define <span class="math inline">\(T\)</span> to be the intersection of <span class="math inline">\(h_2\)</span> and <span class="math inline">\(v_2\)</span>, and prove that <span class="math inline">\(T\)</span> lies on the elliptic curve, from which we will have <span class="math inline">\(S = T = S&#39;\)</span>.</p>
<p>Intuitively we’ll find that, because these nine points are the intersections of two triplets of lines, evaluating to zero at them are “linearly dependent” events, and that <span class="math inline">\(f\)</span> being zero at eight of them will imply that it’s also zero at the ninth.</p>
<p>More rigorously:</p>
<ul>
<li><p>Consider the vector space of degree-3 homogeneous polynomials in <span class="math inline">\(x, y, z\)</span>. One can count that there are 10 distinct cubic terms in three variables:</p>
<pre><code>x³  x²y xy²  y³
  x²z xyz y²z
    xz² yz²
      z³</code></pre>
<p>Every such polynomial is a linear combination of these terms and only these terms, so this vector space has dimension 10.</p></li>
<li>Consider the subspace <span class="math inline">\(V\)</span> of degree-3 homogeneous polynomials that are zero at the eight labeled points other than <span class="math inline">\(S\)</span> and <span class="math inline">\(S&#39;\)</span>. Each restriction reduces the dimension by 1, so this subspace has dimension 2. (This is not true in general, but it’s “usually” true. In particular, it’s true if we assume the points are in general position and there are no “weird collinearities”. You can prove it if you can construct, for each of the eight points, a polynomial that’s nonzero at that point and zero at the seven others.)</li>
<li>The elliptic curve <span class="math inline">\(f\)</span> is in <span class="math inline">\(V\)</span>.</li>
<li>Multiply the “horizontal lines” <span class="math inline">\(h_1, h_2, h_3\)</span> to get a polynomial <span class="math inline">\(g(x, y, z)\)</span>: this is a degree-3 homogeneous polynomial that is zero at the eight points above, so it’s in <span class="math inline">\(V\)</span>. Also, <span class="math inline">\(g(T) = 0\)</span>.</li>
<li>Multiply the “vertical lines” <span class="math inline">\(v_1, v_2, v_3\)</span> to get a polynomial <span class="math inline">\(h(x, y, z)\)</span>: this is a degree-3 homogeneous polynomial that is zero at the eight points above, so it’s in <span class="math inline">\(V\)</span>. Also, <span class="math inline">\(h(T) = 0\)</span>.</li>
<li><p>Because the three polynomials <span class="math inline">\(f, g, h\)</span> are all in this dimension-2 subspace, they must be linearly dependent. <span class="math inline">\(g\)</span> and <span class="math inline">\(h\)</span> are not multiples of each other (they have different factors), so <span class="math inline">\(f\)</span> must participate in this linear dependence. By evaluating this linear dependence at <span class="math inline">\(T\)</span>, we conclude that <span class="math inline">\(f(T) = 0\)</span>, i.e., <span class="math inline">\(T\)</span> is on the elliptic curve. Therefore, <span class="math inline">\(S = T = S&#39;\)</span>, and we’re done.</p></li>
</ul>
<p>This proves the addition we defined is associative in the general case, where there are no “weird collinearities”. I feel like you should be able to generalize it to arbitrary points just by handwaving it as: you can expand out associativity as a massive equation that’s still purely algebraic and finite degree; the above proof shows that this equation is true almost everywhere, so it must be true everywhere, because polynomials can’t have that many zeros. But nobody seems to be willing to do this, so maybe this doesn’t work or is more annoying than bashing it from other angles. Regardless, I think this gets the intuition across pretty well.</p>
<h3 id="entering-the-danger-zone-elliptic-curve-diffie-hellman">Entering the danger zone: Elliptic Curve Diffie-Hellman</h3>
<p>Understanding the group operation is basically all you need to do to do elliptic curve cryptography dangerously. Here’s the simplest ECC protocol, an <a href="https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman">elliptic-curve Diffie-Hellman exchange</a>, between Alice and Bob:</p>
<ul>
<li>They agree on an elliptic curve <span class="math inline">\(E\)</span> and a point <span class="math inline">\(P\)</span> that generates a subgroup <span class="math inline">\(G\)</span>. This can be done completely publicly and predictably, most likely hardcoded into the software Alice and Bob are using, using parameters plucked off an RFC (a kind of Internet standard). Suppose <span class="math inline">\(G\)</span> has size <span class="math inline">\(n\)</span>.</li>
<li>Alice and Bob each generate a secret integer, respectively <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, in the range <span class="math inline">\(0 &lt; a, b &lt; n\)</span>.</li>
<li>Alice and Bob compute and publish the result of <em>scalar multiplication</em> of <span class="math inline">\(P\)</span> with their integers; that is, Alice computes <span class="math inline">\(P + P + \cdots + P\)</span>, applying the group operation to <span class="math inline">\(a\)</span> copies of <span class="math inline">\(P\)</span> (but actually computing it with repeated doubling so it runs in a reasonable time), and similarly for Bob. The whimsical but standard notation we’ll use for scalar multiplication is <span class="math inline">\([a](P) = P + \cdots + P\)</span>, where there are <span class="math inline">\(a\)</span> copies of <span class="math inline">\(P\)</span> (or <span class="math inline">\(|n|\)</span> copies of <span class="math inline">\(-P\)</span> if <span class="math inline">\(n &lt; 0\)</span>); so Alice publiches <span class="math inline">\([a](P)\)</span> and Bob publishes <span class="math inline">\([b](P)\)</span>.</li>
<li>Alice computes <span class="math inline">\([a]([b](P))\)</span> and Bob computes <span class="math inline">\([b]([a](P))\)</span>. Both equal <span class="math inline">\([ab](P)\)</span>, and they can use that as their shared secret.</li>
<li>However, an adversary sees only <span class="math inline">\([a](P)\)</span> and <span class="math inline">\([b](P)\)</span> (and <span class="math inline">\(P\)</span> itself). As far as we know, there is no general practical algorithm to compute <span class="math inline">\([ab](P)\)</span> from this information. (This is called the <a href="https://en.wikipedia.org/wiki/Computational_Diffie%E2%80%93Hellman_assumption"><em>computational Diffie-Hellman assumption</em></a> for an elliptic curve group; many cryptosystems are proven secure under it. Sometimes the stronger <a href="https://en.wikipedia.org/wiki/Decisional_Diffie%E2%80%93Hellman_assumption"><em>decisional Diffie-Hellman assumption</em></a> is also invoked.)</li>
<li>Alice and Bob can now communicate with a much cheaper symmetric encryption system seeded with that shared key, <span class="math inline">\([ab](P)\)</span>, that no eavesdropper can derive.</li>
</ul>
<p>Of course, to implement even this simple protocol, you have to actually write down formulas for point addition, which can be quite painful. You can get them from — wait for it — the <a href="https://hyperelliptic.org/EFD/">Explicit-Formulas Database</a>, so I won’t go into them here.</p>
<p>Although this cryptosystem is secure at a high level, there’s already (at least) three broad categories of traps and vulnerabilities one can fall prey to when trying to implement it.</p>
<ol type="1">
<li>The theoretical trap: small subgroup attacks</li>
<li>The implementation trap: timing side channels</li>
<li>The hybrid trap: invalid curve attacks</li>
</ol>
<p>So here’s the cryptographic conscience part of this post.</p>
<p>(I mostly just ripped this from <a href="https://safecurves.cr.yp.to/">SafeCurves</a>. One attack I won’t delve into is the <a href="https://safecurves.cr.yp.to/transfer.html">transfer</a>, both because I don’t understand it and because, unlike these other traps, it seems to be difficult to make your curve vulnerable to a transfer unless you’re explicitly trying. I believe transfers might be useful for <em>carrying out</em> an invalid curve attack, but I won’t go into that.)</p>
<h4 id="theoretical-trap-small-subgroup-attacks">Theoretical trap: small subgroup attacks</h4>
<p>The theoretical trap is that we really want <span class="math inline">\(n\)</span>, the size of the group <span class="math inline">\(G\)</span>, to be a large prime. If <span class="math inline">\(n\)</span> is the product of small primes, then you can practically compute <span class="math inline">\(a\)</span> from <span class="math inline">\([a](P)\)</span> by computing it modulo each small prime and then combining the results with the Chinese Remainder Theorem. Even if <span class="math inline">\(n\)</span> is, say, 2 times a large prime, <span class="math inline">\([a](G)\)</span> still leaks the lower bit of <span class="math inline">\(a\)</span>, which we’d rather avoid.</p>
<p>However, for other reasons we’ll mention later, there are other properties we want <span class="math inline">\(E\)</span> to have that, as a side effect, make it impossible for the size of <span class="math inline">\(E\)</span> to be a large prime. So we typically compromise by choosing <span class="math inline">\(E\)</span> such that its size is a small integer <span class="math inline">\(h\)</span> times a large prime <span class="math inline">\(\ell\)</span>, and then take <span class="math inline">\(G\)</span> to be a proper subgroup of size <span class="math inline">\(\ell\)</span> (well, <em>the</em> proper subgroup). The integer <span class="math inline">\(h\)</span> is called the <strong>cofactor</strong>. As an example, Curve25519 (the Montgomery curve <span class="math inline">\(y^2 = x^3 + 486662x^2 + x\)</span> over <span class="math inline">\(\mathbb{F}_{2^{255} - 19}\)</span>) has size <span class="math inline">\(8\ell\)</span>, where <span class="math display">\[\ell = 2^{252} + 27742317777372353535851937790883648493\]</span> is prime; its cofactor is <span class="math inline">\(8\)</span>.</p>
<p>While you can avoid leaking the lower bits of private keys on such a curve by choosing <span class="math inline">\(P\)</span> to be a generator of <span class="math inline">\(G\)</span> instead of the entirety of <span class="math inline">\(E\)</span>, this is risky. If Alice is doing a DH key exchange with Bob, Bob could maliciously send Alice a point outside <span class="math inline">\(G\)</span> (i.e. that isn’t a multiple of <span class="math inline">\(P\)</span>) in the second step to leak Alice’s private key’s lower bits. Alice can check that Bob’s point is in <span class="math inline">\(G\)</span> before responding, but this is both computationally expensive and an extra implementation footgun. (You might say that leaking a few bits of a secret key isn’t a big deal since you still have about 250 remaining bits of entropy, and you might be right for the simple Diffie-Hellman exchanges we’re considering, but this leak can actually be catastrophic for other protocols.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>) Curve25519 sidesteps this issue more deeply by keeping <span class="math inline">\(P\)</span> as a generator of the full group <span class="math inline">\(E\)</span>, but tweaking the protocol by asserting that private keys must be chosen to be multiples of 8, so there are no lower bits to leak.</p>
<p>There are more complicated use cases for elliptic curves where this compromise still isn’t good enough, and cryptographers have developed more advanced techniques for getting a prime-order group out of an elliptic curve with a small cofactor. That is, they’ve designed an abstraction of elements, built atop the elliptic curve, that behave and can be manipulated exactly like “elements of a prime-order group”, while keeping comparable efficiency and obviating any validity checks. <a href="https://eprint.iacr.org/2015/673">Decaf (Hamburg 2015)</a> is a technique for getting a prime-order group out of an elliptic curve with cofactor 4; <a href="https://ristretto.group/">Ristretto</a> is a similar technique for elliptic curves with cofactor 8. Both links also discuss the pitfalls of using elliptic curves with cofactors or trying to hack around the cofactor with simple fixes in more depth. Unfortunately, exactly how they work is beyond the scope of this post.</p>
<h4 id="implementation-trap-timing-side-channels">Implementation trap: timing side channels</h4>
<p>The implementation trap is that naïve repeated doubling leaks information about <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> through timing. The “repeated doubling” algorithm I described way at the start of this post might be written something like:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">def</span> repeated_doubling(n, P):</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="dv">0</span> <span class="co"># as an EC point</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="cf">if</span> n <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb2-4" title="4">        Q <span class="op">=</span> repeated_doubling(n <span class="op">//</span> <span class="dv">2</span>, P)</a>
<a class="sourceLine" id="cb2-5" title="5">        <span class="cf">return</span> Q <span class="op">+</span> Q <span class="co"># in the EC group</span></a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb2-7" title="7">        <span class="cf">return</span> repeated_doubling(n <span class="op">-</span> <span class="dv">1</span>, P) <span class="op">+</span> P <span class="co"># in the EC group</span></a></code></pre></div>
<p>This takes longer when <span class="math inline">\(n\)</span> is larger or has more 1’s in their binary representations, which is undesirable. A standard constant-time algorithm to compute <span class="math inline">\([n](P)\)</span>, where <span class="math inline">\(0 \leq n &lt; 2^m\)</span> for some fixed public <span class="math inline">\(m\)</span>, is the <strong>Montgomery ladder</strong>, which runs as follows in pseudo-Python:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">def</span> montgomery_ladder(n, P):</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="co">&quot;Computes [n](P) in constant time, given that 0 &lt;= n &lt; 2^m&quot;</span></a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4">    r0 <span class="op">=</span> <span class="dv">0</span> <span class="co"># as an EC point</span></a>
<a class="sourceLine" id="cb3-5" title="5">    r1 <span class="op">=</span> P <span class="co"># as an EC point</span></a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">-</span> <span class="dv">1</span>, <span class="dv">-1</span>, <span class="dv">-1</span>): <span class="co"># m - 1 to 0 inclusive</span></a>
<a class="sourceLine" id="cb3-7" title="7">        <span class="cf">if</span> ((n <span class="op">&gt;&gt;</span> i) <span class="op">&amp;</span> <span class="dv">1</span>) <span class="op">!=</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb3-8" title="8">            r1 <span class="op">=</span> r0 <span class="op">+</span> r1 <span class="co"># in the EC group</span></a>
<a class="sourceLine" id="cb3-9" title="9">            r0 <span class="op">=</span> r0 <span class="op">+</span> r0 <span class="co"># in the EC group; doubling</span></a>
<a class="sourceLine" id="cb3-10" title="10">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb3-11" title="11">            r0 <span class="op">=</span> r0 <span class="op">+</span> r1 <span class="co"># in the EC group</span></a>
<a class="sourceLine" id="cb3-12" title="12">            r1 <span class="op">=</span> r1 <span class="op">+</span> r1 <span class="co"># in the EC group; doubling</span></a>
<a class="sourceLine" id="cb3-13" title="13"></a>
<a class="sourceLine" id="cb3-14" title="14">        <span class="co"># Invariant: At this point, r0 = [(n &gt;&gt; i)](P), r1 = [(n &gt;&gt; i)+1](P)</span></a>
<a class="sourceLine" id="cb3-15" title="15">    <span class="cf">return</span> r0</a></code></pre></div>
<p>(The Montgomery ladder may also refer to a more specific version of this algorithm optimized for Montgomery curves, which we’ll talk about in a few sections.)</p>
<p>There are many elliptic curves where doubling a point can be done faster than adding two points, but still in constant time; in those cases you can replace the two doubling lines with that instead without affecting the timing security. Of course, all this assumes that adding two points is a constant-time operation and that the branch on private data doesn’t leak through a side channel more sophisticated than raw timing, but you can avoid those leaks with standard techniques relatively straightforwardly and cheaply; the overhead would still be dwarfed by performing the actual elliptic point additions.</p>
<h4 id="hybrid-trap-invalid-curve-attacks">Hybrid trap: invalid curve attacks</h4>
<p>The last trap I want to talk about falls somewhere in between the above cases. What if, during a DH key exchange, Bob gives Alice a maliciously crafted point <span class="math inline">\(P\)</span> that <em>isn’t on the curve at all</em>?</p>
<p>Of course, Alice can explicitly plug Bob’s point into the elliptic curve equation and error out if it’s not satisfied, but it’s worth thinking about what might go wrong if Alice forgets to do this. This attack can’t really be discussed in full generality because it depends on exactly what algorithm or formula Alice is using to compute scalar multiplications of elliptic curve points, and we’ll revisit it in later sections; but for now, let’s pretend this DH key exchange is taking place on a short Weierstrass form elliptic curve with the formulas taken directly <a href="https://hyperelliptic.org/EFD/g1p/auto-shortw.html">from the Explicit-Formulas database</a>.</p>
<p>Well, I copied over the formulas: for the curve <span class="math inline">\(y^2 = x^3 + Ax + B\)</span>, the addition of two affine points <span class="math inline">\((x_1, y_1) + (x_2, y_2)\)</span> is <span class="math display">\[\left( \frac{(y_2 - y_1)^2}{(x_2 - x_1)^2} - x_1 - x_2, \frac{(2x_1 + x_2)(y_2 - y_1)}{x_2 - x_1} - \frac{(y^2 - y_1)^3}{(x_2 - x_1)^3} - y_1 \right),\]</span> while the doubling of an affine point <span class="math inline">\((x, y)\)</span> is <span class="math display">\[\left( \frac{(3x^2 + A)^2}{4y^2} - 2x, \frac{3x(3x^2 + A)}{2y} - \frac{(3x^2+A)^3}{8y^3} - y \right).\]</span> You do not need to understand these formulas. There’s only one thing you need to observe about them: <strong>they don’t depend on <span class="math inline">\(B\)</span>.</strong> This means that, if Bob gives Alice a malicious point <span class="math inline">\((x, y)\)</span> lying on another curve of the form <span class="math inline">\(y^2 = x^3 + Ax + B&#39;\)</span> for some <span class="math inline">\(B&#39;\)</span> (and in fact it’s easy to see that <em>every</em> point <span class="math inline">\((x, y)\)</span> lies on exactly one curve of that form), and if Alice blithely shoves them into the above formulas, then Alice will unwittingly be computing scalar multiplication on that curve instead! And if Bob picks <span class="math inline">\((x, y)\)</span> such that it generates a subgroup with small or smooth order of its curve, which typically isn’t hard since he has so much freedom, he can leak Alice’s private key by examining the result.</p>
<p>The obvious takeaway is that, when Alice performs a Diffie-Hellman key exchange, she needs to validate that the point she gets is on the curve she expects it to be. However, we’ll soon see other ways to choose and implement elliptic curves that prevent this attack more fundamentally. Letting implementors skip this check is not just good in that it removes a footgun, it can also make implementations more efficient.</p>
<h4 id="the-x-only-optimization-and-the-montgomery-ladder">The x-only optimization and the Montgomery ladder</h4>
<p>There are a variety of ways to optimize elliptic curve optimizations beyond just plugging <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> coordinates into formulas and performing modular arithmetic. For example, you might represent <span class="math inline">\(x\)</span> with two numbers <span class="math inline">\(x&#39;\)</span> and <span class="math inline">\(z&#39;\)</span>, where <span class="math inline">\(x = x&#39;/z&#39; \bmod{p}\)</span>, so that when you want to divide <span class="math inline">\(x\)</span> by a number, instead multiply <span class="math inline">\(z&#39;\)</span> by it. This lets you minimize the number of division operations (which are computationally much more expensive than multiplications). Occasionally, a more complicated representation like <span class="math inline">\(x = x&#39;/z&#39;^2\)</span> is better. There are many variants depending on the curve type, so I won’t go into details (I don’t understand all of them anyway).</p>
<p>However, I will just focus on one of the most interesting optimizations, which doubles as a partial mitigation of invalid curve attacks: <strong>tracking only the <span class="math inline">\(x\)</span>-coordinate of a point on the elliptic curve</strong>. This makes sense since, given that a point is on the elliptic curve and you know its <span class="math inline">\(x\)</span>-coordinate, its <span class="math inline">\(y\)</span>-coordinate is almost entirely redundant, but not quite: from a theoretical standpoint, dropping it is equivalent to taking points of the elliptic curve modulo negation. (The resulting mathematical object is apparently called the <em>Kummer variety</em> of the elliptic curve, although not a lot of sources bother to name it as such.) It should be surprising that this works because it isn’t a traditionally valid kind of “modulo”, since it causes the group operation to no longer be well-defined: <span class="math inline">\(P + Q\)</span> and <span class="math inline">\(P + (-Q)\)</span> do not have the same <span class="math inline">\(x\)</span>-coordinate in general, even though their operands do. However, scalar multiplication is still well-defined, and that is enough for Diffie-Hellman.</p>
<p>What’s more, Montgomery curves (those of the form <span class="math inline">\(By^2 = x^3 + Ax^2 + x\)</span>) in particular have the following property: if you have the <span class="math inline">\(x\)</span>-coordinate of the three points <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, and <span class="math inline">\(A - B\)</span>, you can quickly compute the <span class="math inline">\(x\)</span>-coordinate of <span class="math inline">\(A + B\)</span>. And this assumption is true for every addition in the Montgomery ladder above! As a result, scalar multiplications can be computed particularly quickly on Montgomery curves.</p>
<p>(Every Montgomery curve’s order is even, which you can see just from the fact that <span class="math inline">\((0, 0)\)</span> is on every such curve, and that point doubles to <span class="math inline">\(\infty\)</span>. In fact, every Montgomery curve’s order is divisible by <span class="math inline">\(4\)</span>. The computational advantages are so great that they outweigh our earlier desire for <span class="math inline">\(E\)</span> to be of prime order and motivate us to settle for a cofactor.)</p>
<p>You can find derivations of the formulas in <a href="https://eprint.iacr.org/2017/293">Montgomery curves and the Montgomery ladder (Bernstein and Lange, 2017)</a>. One particular caveat to be aware of is that these ladders conflate the <span class="math inline">\((0, 0)\)</span> point with the point at infinity, and assigns the <span class="math inline">\(x\)</span> coordinate of 0 to both. This optimization is very much enshrined in the definition of <a href="https://cr.yp.to/ecdh/curve25519-20060209.pdf">Curve25519 (PDF)</a>. Public keys represent equivalence classes of a point and its negation; the “base point” <span class="math inline">\(P\)</span> is the pair of points that have <span class="math inline">\(x = 9\)</span>.</p>
<p>As I mentioned briefly, this also greatly reduces the attack surface for invalid curve attacks. The formulas in the Montgomery ladder also don’t depend on <span class="math inline">\(B\)</span>; however, for fixed <span class="math inline">\(A\)</span> in the Montgomery equation <span class="math inline">\(By^2 = x^3 + Ax^2 + x\)</span>, there are only two Montgomery curves up to isomorphism.</p>
<ul>
<li>If <span class="math inline">\(B&#39;/B\)</span> is a quadratic residue, then there is an obvious isomorphism between <span class="math inline">\(By^2 = x^3 + Ax^2 + x\)</span> and <span class="math inline">\(B&#39;y^2 = x^3 + Ax^2 + x\)</span>, namely <span class="math inline">\((x, y) \mapsto (x, y/\sqrt{B/B&#39;})\)</span>.</li>
<li>Otherwise (since <span class="math inline">\(B&#39; = 0\)</span> obviously doesn’t produce a curve) exactly one of <span class="math inline">\(B\)</span> and <span class="math inline">\(B&#39;\)</span> is a quadratic residue, and all such values <span class="math inline">\(B&#39;\)</span> produce curves are isomorphic to each other. Any such curve is called the <strong>quadratic twist</strong> of the original curve.</li>
</ul>
<p>(Note that, if you consider these curves over the field <span class="math inline">\(\overline{\mathbb{K}}\)</span>, in which <span class="math inline">\(\sqrt{B/B&#39;}\)</span> exists, then this distinction does not exist: any curves with the same <span class="math inline">\(A\)</span> are isomorphic, which include any curve and its quadratic twist as we defined them above. In this way, you can view the curve and its quadratic twist as subgroups of a larger group, which have only the identity and a few other low-order points in common.)</p>
<p>Every <span class="math inline">\(x\)</span>-coordinate that doesn’t represent a pair of points on a Montgomery curve represents a pair of points on its quadratic twist, and Curve25519 was chosen such that its quadratic twist’s order is 4 times a large prime. This means that if a malicious Bob sends Alice a number that isn’t the <span class="math inline">\(x\)</span>-coordinate of any point on Curve25519, and Alice dutifully performs a scalar multiplication and reports the result to Bob, Bob still can’t make meaningful progress towards determining Alice’s private key. Either his point will be on the quadratic twist, on which the discrete log problem is just as hard, or it will be an extra useless point like 0.</p>
<p>While all this makes for really performant and secure DH, it also implies that <em>you cannot directly perform group addition on two strings</em> representing “points on Curve25519”; they actually represent points on the Kummer variety, or equivalence classes of two points on the elliptic curve; and addition on them isn’t well-defined. This is why (or, at least, it’s one of the reasons) Curve25519 as defined above is not directly used in other cryptographic protocols that require you to be able to add points, such as the <a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm">Digital Signature Algorithm</a> (DSA, or ECDSA if specifically instantiated with an elliptic curve). (This hasn’t stopped cryptographers from figuring out how to use Curve25519 to make signatures anyway, see e.g. <a href="https://arxiv.org/abs/1709.03358">qDSA</a>, but it’s a bit trickier and beyond the scope of this post.)</p>
<h4 id="group-operations-on-twisted-edwards-curves">Group operations on twisted Edwards curves</h4>
<p>Fortunately, if we want to implement other protocols that require being able to add unrelated points, we can still take advantage of the work put into choosing the parameters of Curve25519 as follows. Every Montgomery form curve is <em>birationally equivalent</em> to a twisted Edwards curve (one of the form <span class="math inline">\(Ax^2 + y^2 = 1 + Dx^2y^2\)</span>), which has very nice general group addition formulas. (Two curves are <strong>birationally equivalent</strong> if there are rational maps that bijectively send them to each other. We’ll define “rational maps” in the next section.) Specifically, Curve25519 is birationally equivalent to <span class="math display">\[-x^2 + y^2 = 1 - \frac{121665}{121666}x^2y^2.\]</span> To a pure mathematician, they might as well be “the same” mathematical object, but computationally they of course have quite different point representations and formulas.</p>
<p>One mapping from Curve25519 to this curve is <span class="math display">\[(x, y) \mapsto \left(\sqrt{-486664}\frac{x}{y}, \frac{x-1}{x+1}\right).\]</span> (You can pick either sign for <span class="math inline">\(\sqrt{-486664}\)</span>. To be clear, we could evaluate both <span class="math inline">\(121665/121666\)</span> and <span class="math inline">\(\sqrt{-486664}\)</span> to integers in <span class="math inline">\(\mathbb{F}_{2^{255}-19}\)</span>, but they would be huge and not illuminating.)</p>
<p><strong>WARNING</strong>: You <em>cannot</em> plug every point <span class="math inline">\((x, y)\)</span> on the Curve25519 Montgomery curve into this formula to map it onto the twisted Edwards curve given above. Some points will obviously lead to division by zero; there’s some discussion on StackExchange, <a href="https://crypto.stackexchange.com/questions/43013/what-does-birational-equivalence-mean-in-a-cryptographic-context">What does “birational equivalence” mean in a cryptographic context?</a>; this confusion has <a href="https://monocypher.org/quality-assurance/disclosures">caused real crytographic bugs</a>. Despite that, the rational map <em>is</em> defined everywhere and <em>is</em> a perfect bijection of the Curve25519 Montgomery curve and the twisted Edwards curve (well, its desingularization). This should be surprising, but it’s consistent for a rational map to be defined everywhere even though one particular way of writing it down as formulas isn’t.</p>
<p>To see what’s going on, let’s go back to explicitly writing projective points as triplets for a moment. This is the mapping given above written out as such: <span class="math display">\[(x : y : z) \mapsto \left(\sqrt{-486664}\frac{x}{y} : \frac{x - z}{x + z} : 1\right).\]</span> Evaluating this at <span class="math inline">\((0 : 0 : 1)\)</span> leads to division by zero when computing <span class="math inline">\(x/y\)</span>. However, we know that <span class="math inline">\(x, y, z\)</span> satisfy <span class="math inline">\(y^2z = x^3 + 486662x^2z + xz^2\)</span>, which can be formally rearranged as <span class="math display">\[\frac{x}{y} = \frac{yz}{x^2 + 486662xyz + z^2}.\]</span> Therefore, the rational map is the <em>same</em> rational map as <span class="math display">\[(x, y, z) \mapsto \left(\sqrt{-486664}\frac{yz}{x^2 + 486662xyz + z^2}, \frac{x - z}{x + z}, 1\right),\]</span> and this way of writing it down <em>can</em> be evaluated at <span class="math inline">\((0 : 0 : 1)\)</span> to get <span class="math inline">\((0 : -1 : 1)\)</span>, which is the affine point <span class="math inline">\((0, -1)\)</span>, on the twisted Edwards curve.</p>
<p>Evaluating the mapping at the point at infinity <span class="math inline">\((0 : 1 : 0)\)</span> is a little more work. This time we can formally rearrange the Curve25519 equation as <span class="math display">\[\begin{align*}
y^2z - 486660x^2z &amp;= x^3 + 2x^2z + zx^2 \\
(y^2 - 486660x^2)z &amp;= x(x + z)^2 \\
\frac{z}{x + z} &amp;= \frac{x(x+z)}{y^2 - 486660x^2} \\
\frac{x - z}{x + z} &amp;= 1 - 2\frac{z}{x+z} \\ &amp;= 1 - 2\frac{x(x+z)}{y^2 - 486660x^2}. \\
\end{align*}\]</span> Our rational map is thus the same rational map as <span class="math display">\[(x : y : z) \mapsto \left(\sqrt{-486664}\frac{x}{y} : 1 - 2\frac{x(x+z)}{y^2 - 486660x^2} : 1\right),\]</span> and this can be evaluated at <span class="math inline">\((0 : 1 : 0)\)</span> to get <span class="math inline">\((0 : 1 : 1)\)</span>, the affine point <span class="math inline">\((0, 1)\)</span> on the twisted Edwards curve.</p>
<p>The inverse mapping, from the Edwards curve to the Montgomery curve, is <span class="math display">\[(x, y) \mapsto \left(\frac{1+y}{1-y}, \frac{\sqrt{486664}(1+y)}{x(1-y)}\right).\]</span> This is similarly not defined everywhere.</p>
<p>Of course, in both cases it’s probably simplest if the code picks a simple representation of the mapping and handles the special cases separately.</p>
<h4 id="point-representations-and-invalid-curve-attacks-on-twisted-edwards-curves">Point representations and invalid curve attacks on twisted Edwards curves</h4>
<p>Since twisted Edwards curves are so important, let’s take a little time to make sure we understand how to represent points and perform group operations on them. Unlike Weierstrass and Montgomery curves, where there’s a special point at infinity and where you might have discovered that the Explicit-Formulas Database lists some special cases you must check for when adding two points, Edwards curves have <strong>complete</strong> formulas, which are formulas that don’t have special cases of “if statements”. They also don’t have points at infinity, so you can always represent every point as a pair of coordinates <span class="math inline">\((x, y)\)</span> from whatever finite field you’re working over. The group identity is <span class="math inline">\((0, 1)\)</span>. This makes group operations on Edwards curves particularly easy to implement correctly without timing side channel leaks.</p>
<p>If you remember when I introduced twisted Edwards curves, you might have objected to the claim that Edwards curves don’t have points at infinity, so let me be more precise. If considered over the algebraic closure <span class="math inline">\(\overline{\mathbb{F}_{2^{255}-19}}\)</span>, the twisted Edwards curve we said was isomorphic to Curve25519 has the points at infinity <span class="math inline">\((\pm\sqrt{-121665/121666} : 0 : 0 : 1)\)</span> and <span class="math inline">\((0 : \pm\sqrt{121665/121666} : 0 : 1)\)</span>. However, both numbers <span class="math inline">\(\pm 121665/121666\)</span> are not quadratic residues in <span class="math inline">\(\mathbb{F}_{2^{255}-19}\)</span>, so these points at infinity don’t exist over <span class="math inline">\(\mathbb{F}_{2^{255}-19}\)</span>.</p>
<p>So what about invalid curve attacks in this new setting? The formulas for point addition on Edwards curves are that <span class="math inline">\((x_1, y_1) + (x_2, y_2)\)</span> are <span class="math display">\[\left(\frac{x_1y_2 + y_1x_2}{1 + dx_1x_2y_1y_2}, \frac{y_1y_2 - Ax_1x_2}{1 - dx_1x_2y_1y_2}\right).\]</span> They use all of its coefficients, so it’s not obvious what happens if you try to carry out an invalid curve attack with two random coordinates that aren’t on the curve. But <a href="https://eprint.iacr.org/2015/1233">Neves and Tibouchi, 2015</a> point out that if you naively plug in points <span class="math inline">\((0, y_1)\)</span> and <span class="math inline">\((0, y_2)\)</span> into the above formulas, you get <span class="math inline">\((0, y_1y_2)\)</span>, which means your group operation degenerates into multiplication in <span class="math inline">\(\mathbb{F}_p\)</span>. The discrete log problem is much easier in that group, though not obviously so (I believe no general polynomial-time algorithm is known; the constants and rates of growth in the best expoential algorithms are just much smaller).</p>
<p>In a nutshell, invalid curve attacks are still a concern. This time, I am not aware of a cleverer fix than just validating that untrusted points are on the curves you expect them to be on.</p>
<h3 id="finding-points-on-curves">Finding points on curves</h3>
<p>This is a detour that’s only relevant for EC cryptographic algorithms that are even more complicated than ECDH or ECDSA, but it’s related to stuff that came up at work and I think it’s interesting.</p>
<p>Here is a surprisingly nontrivial problem: Given an elliptic curve — let’s say it’s provided in Weierstrass form <span class="math inline">\(y^2 = x^3 + Ax + B\)</span> — construct a nontrivial point on it.</p>
<p>The easiest strategy is probably the following <em>rejection sampling</em> strategy: Choose random <span class="math inline">\(x\)</span>, check if <span class="math inline">\(x^3 + Ax + B\)</span> is a quadratic residue, and if so, compute one of its square roots <span class="math inline">\(y\)</span> and output <span class="math inline">\((x, y)\)</span>; otherwise, repeat. Sometimes, we want a deterministic strategy that generates a point from a seed, in which case we might modify the above strategy by deterministically deriving each candidate <span class="math inline">\(x\)</span> from the seed, say by concatenating a positive integer and cryptographically hashing.</p>
<p>While this strategy is simple, for some cryptographic applications it has a fatal flaw: it isn’t constant time. So to refine our search criteria a little, we want a deterministic function <span class="math inline">\(f\)</span> from a large domain <span class="math inline">\(D\)</span> to an elliptic curve <span class="math inline">\(E\)</span> satisfying these criteria:</p>
<ol type="1">
<li>It should be efficiently computable in constant time. We can modify the rejection sampling strategy into a function that’s efficient on average and can be made effectively constant time by just always sampling a high number of points, enough that the probability of all of them failing is negligible, and taking the first point that succeeds; but this makes it quite inefficient.</li>
<li>It should have large range. We don’t want a function that just maps every input to the same precomputed point.</li>
<li>Its output should not reveal its discrete logarithm with respect to any other point, because many protocols’ security depend on that being secret or unknown. This eliminates the simple strategy of precomputing a generator <span class="math inline">\(G\)</span> of the elliptic curve and mapping <span class="math inline">\(n \mapsto G^n\)</span>, which is otherwise actually quite nice.</li>
<li>Preferably, it should be somewhat evenly distributed across the curve. Note that we won’t give a strict definition of what “evenly distributed” is.</li>
<li>Preferably, it should be efficiently invertible on its range: if we know that a point <span class="math inline">\(P\)</span> is in the image of <span class="math inline">\(f\)</span>, we may want to be able to efficiently compute <span class="math inline">\(d \in D\)</span> such that <span class="math inline">\(f(d) = P\)</span>. Sometimes we will use this property by repeatedly generating random <span class="math inline">\(P \in E\)</span> until we find one in <span class="math inline">\(f\)</span>’s image, and then outputting its inverse. This is also nonconstant time rejection sampling, but it turns out that in some use cases, this timing leak doesn’t leak anything we care about whereas the original timing leak does.</li>
</ol>
<p>There are two applications I know of such a function:</p>
<ol style="list-style-type:lower-alpha">
<li>
<strong>Indistinguishability</strong>: Represent a point on an elliptic curve in a way such that an adversary can’t distinguish it from random data. I think the idea is that if your protocol sends undisguised points on elliptic curves, a censor who doesn’t want you to use public-key cryptography can notice that by checking that the data you’re sending satisfies an elliptic curve equation and punish you.
</li>
<li>
<strong>Hashing to curves</strong>: Given a string, hash it to produce a point on the elliptic curve in a way that has all the usual properties you’d want from a cryptographic hash. I won’t justify this in detail, but there are several protocols where this is a useful primitive.
</li>
</ol>
<p>Stated thus, the problem turns out to be important and difficult enough that it has led to multiple solutions with multiple names attached. Most of them are “convert the seed into an element of <span class="math inline">\(\mathbb{F_p}\)</span> and plug it into these huge algebraic formulas”, but instead of telling you the formulas, I’ll just leave references to them and try to leave you with the motivation for coming up with those formulas, enough that you can reconstruct them. Reverse engineering these motivations from the formulae was an interesting exercise.</p>
<h4 id="shallue-woestijne-ulas-swu-2007">Shallue-Woestijne-Ulas (SWU) (2007)</h4>
<p>This mapping was developed by the first two authors in 2006<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a> and simplified by the third in 2007.<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a></p>
<p>Let <span class="math inline">\(g(x) = x^3 + Ax + B\)</span>; we want to find <span class="math inline">\(x\)</span> such that <span class="math inline">\(g(x)\)</span> is a quadratic residue. Key insight: For a fixed <span class="math inline">\(m\)</span>, the equation <span class="math inline">\(g(mx) = m^3g(x)\)</span> simplifies to a linear equation in <span class="math inline">\(x\)</span>, and so can easily be solved for <span class="math inline">\(x\)</span>.</p>
<p>With that in mind, pick arbitrary <span class="math inline">\(x_0\)</span> and evaluate <span class="math inline">\(m := g(x_0)\)</span>. If it’s a quadratic residue, we’re done. Otherwise, let <span class="math inline">\(x^*\)</span> be the solution to <span class="math inline">\(g(mx) = m^3g(x)\)</span>, which is easy to compute as we observed above. It immediately follows that exactly one of <span class="math inline">\(g(x^*)\)</span> and <span class="math inline">\(g(mx^*)\)</span> is a quadratic residue, so output that one.</p>
<p>The above can be considered a mapping from <span class="math inline">\(x_0\)</span> to a point on the elliptic curve; we can even let <span class="math inline">\(m = g(x_0)t^2\)</span> for random <span class="math inline">\(t\)</span> to spread out the range more. It is difficult to understand the distribution of its outputs and relatively expensive to compute compared to some later strategies, but it passably satisfies all our criteria.</p>
<h4 id="icart-2009">Icart (2009)</h4>
<p>First published in 2009<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>, it was developed into an evenly distributed function in 2010<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>. That paper also produces an adaptation for the SWU algorithm above with a similar property. I won’t go into the latter developments here, though.</p>
<p>Suppose cube roots are easy to compute in <span class="math inline">\(\mathbb{F}_p\)</span>; this is true if <span class="math inline">\(p \equiv 2 \bmod 3\)</span>.</p>
<p>Key insight: We can solve equations of the form <span class="math inline">\((x - k)^3 = \ell\)</span> easily, so if we can cause our elliptic curve to take on that form, we’re done. To that end, plug <span class="math inline">\(y = ux + v\)</span> into our equation and rearrange to get <span class="math display">\[x^3 - u^2x^2 + (a - 2uv)x + (b - v^2) = 0.\]</span> The cube can be completed if <span class="math inline">\(a - 2uv = 3(u^2/3)^2\)</span>, which can be solved for <span class="math inline">\(v\)</span> in terms of <span class="math inline">\(u\)</span>. Thus, for every nonzero value of <span class="math inline">\(u\)</span>, we can compute <span class="math inline">\(v\)</span> and then a point <span class="math inline">\((x, y)\)</span> on our elliptic curve.</p>
<h4 id="elligator-and-elligator-2-2013">Elligator and Elligator 2 (2013)</h4>
<p>These techniques target the indistinguishability use case and have a <a href="https://elligator.cr.yp.to/">nice website</a>, which admittedly features a <a href="https://elligator.cr.yp.to/elligator-5.png">rather mystifying diagram</a>.</p>
<figure>
<a href="/img/elligator.svg"><img src="/img/elligator.svg" alt="An alligator consuming a point (X, Y) from an Edwards curve shaped like a four-pointed star and producing a string of 0's and 1's" /></a>
<figcaption>
Original Fan Art™ of the Elligator alligator
</figcaption>
</figure>
<p>I will just cover Elligator 2, however, as Elligator 1 has some moderately tricky restrictions on the elliptic curves it’s compatible with, so much so that the Elligator authors propose a new specific curve for it (that also satisfies all the other common requirements). It assumes our curve is in Montgomery form. Let <span class="math inline">\(g(x) = x^3 + Ax^2 + x\)</span>.</p>
<p>Consider pairs of distinct <span class="math inline">\(\mathbb{F}_p\)</span> elements <span class="math inline">\(x_0, x_1\)</span> such that <span class="math inline">\(x_0^2 + Ax_0 = x_1^2 + Ax_1\)</span>. Trivial cases aside, that means they are the two roots of the quadratic <span class="math inline">\(x^2 + Ax + C\)</span> for some <span class="math inline">\(C\)</span>, so they satisfy <span class="math inline">\(x_0 + x_1 = -A\)</span>, and this is a sufficient condition; you can also see this by completing the square. These pairs are interesting because <span class="math inline">\(g(x_0)/g(x_1) = x_0/x_1\)</span>. Thus, if we choose <span class="math inline">\(x_0/x_1 = u\)</span> to be a quadratic nonresidue, we know that exactly one of <span class="math inline">\(g(x_0)\)</span> and <span class="math inline">\(g(x_1)\)</span> will be a quadratic residue.</p>
<p>Given almost any <span class="math inline">\(u\)</span>, we can in fact solve the two equations <span class="math inline">\(x_0 + x_1 = -A\)</span> and <span class="math inline">\(x_0/x_1 = u\)</span> fairly easily. Furthermore, this mapping is injective from <span class="math inline">\(u\)</span> to <span class="math inline">\(\{x_0, x_1\}\)</span>. Finally, as long as we can precompute one quadratic nonresidue <span class="math inline">\(u_0\)</span> ahead of time, there is a very simple almost-injective map from <span class="math inline">\(r \in \mathbb{F}_p\)</span> to all quadratic nonresidues: just pick <span class="math inline">\(u = u_0r^2\)</span> for a random. This is exactly two-to-one, so if you pick <span class="math inline">\(r\)</span> in the range <span class="math inline">\(0 &lt; r &lt; p/2\)</span> you’re done.</p>
<h3 id="the-road-forward">The road forward</h3>
<p>I think we’ve already covered enough to let you implement the vast majority of elliptic curve protocols from scratch based on its standard. We’ve also examined a lot of footguns you might encounter when trying to do so. However, if you were stranded on a desert island with a programmable computer but no other resources, and you wanted to implement elliptic-curve cryptography from scratch, there is one more thing you’ll need to know how to do (because you won’t be able to copy the coefficients and parameters for any pre-existing secure elliptic curve). It’s surprising to me that it’s so theoretically difficult. That task is <strong>counting the number of points</strong> on an elliptic curve.</p>
<p>It’s not clear what the marginal utility of this knowledge is for cryptographic purposes, but it lets us see a bunch more features of elliptic curves and provides a nice goal to look forward to. So let’s dive in.</p>
<h3 id="isogenies">Isogenies</h3>
<p>An <em>isogeny</em> is approximately a structure-preserving map for elliptic curves, like a homomorphism for groups or a linear transformation for vector spaces. Almost.</p>
<p>A warning for myself and possibly nobody else: An isogeny is not necessarily bijective or even invertible, like the “iso” prefix might lead you to think! “Isogeny” literally means “equal origins”: it preserves the zero, and we’ll see (but not prove) that that’s surprisingly powerful, but not so powerful as to imply injectivity. (It’s more like the “iso” in a geometric “isometry”. Unfortunately for my point, isometries also happen to be invertible, but that’s a red herring.)</p>
<p>Let’s try to be precise:</p>
<ul>
<li><p>An <strong>isogeny</strong> <span class="math inline">\(\phi : E_1 \to E_2\)</span> of elliptic curves <span class="math inline">\(E_1, E_2\)</span> defined over <span class="math inline">\(\mathbb{K}\)</span> is a non-constant <em>rational map</em> that sends the distinguished point of <span class="math inline">\(E_1\)</span> to the distinguished point of <span class="math inline">\(E_2\)</span>.</p>
<p>We’ve already seen rational maps informally, but what exactly are they? There are several surprising catches here:</p>
<ul>
<li>A rational map can be defined as a triplet of rational functions (i.e. polynomials divided by other polynomials), each in three variables, subject to the other restrictions in this list. It’s a function that maps points in the projective plane to other points in the projective plane.</li>
<li>Because we’re in the projective plane, rational maps are equivalent up to scaling <em>by other rational functions</em>. The rational map <span class="math inline">\((x : y : z)\)</span> is the same as the rational map <span class="math inline">\((1 : y/x : z/x)\)</span> or <span class="math inline">\((x(y+z)/(x+1) : y(y+z)/(x+1) : z(y+z)/(x+1))\)</span>. (So, by clearing denominators, any rational map can be defined by a triplet of polynomials, no division required.)</li>
<li>The fact that a rational map maps a curve to a curve is part of the definition, and the rational map must send each point in <span class="math inline">\(E_1/\overline{\mathbb{K}}\)</span> to a point in <span class="math inline">\(E_2/\overline{\mathbb{K}}\)</span>. <strong>Note the overline</strong>: we’re working with the algebraic closures of the fields! The curves <span class="math inline">\(E_i/\overline{\mathbb{K}}\)</span> are “base changes” of the curves we were originally considering, arguably two new elliptic curves defined over different fields that just happens to have the “same” equation and distinguished point. Mapping <span class="math inline">\(E_1/\mathbb{K}\)</span> to <span class="math inline">\(E_2/\mathbb{K}\)</span> is <em>not sufficient</em>. (If <span class="math inline">\(\mathbb{K}\)</span> is finite, the projective plane is finite and you can cobble together literally any function you want by adding lots of polynomials, including ones that map <span class="math inline">\(E_1/\mathbb{K}\)</span> to <span class="math inline">\(E_2/\mathbb{K}\)</span>, but almost all of them will not be rational maps.)</li>
<li>You might worry about the rational functions not being defined everywhere — note that there are two ways for this to happen, either division by zero or the map outputting all zeroes, because <span class="math inline">\((0 : 0 : 0)\)</span> isn’t a projective point. However, it turns out that if <span class="math inline">\(E_1\)</span> is smooth (which it is if it’s an elliptic curve), this is never a concern; forcing the rational map to send each point in <span class="math inline">\(E_1/\overline{\mathbb{K}}\)</span> to a point in <span class="math inline">\(E_2/\overline{\mathbb{K}}\)</span> whenever it’s defined also forces it to be defined on that curve. (There might not be one specific way to write three rational functions down such that they’re defined everywhere and never all zero! But given a point, there will be a way to scale the rational function to make it defined. I won’t prove this rigorously, but given a list of nice rational functions, you can rigorously measure how many “factors of zero” the numerators/denominators have when evaluated at P (it’s a discrete valuation ring!) and then multiply/divide out the minimum, which leaves all functions with nonnegatively many factors and at least one with none; then, all functions are defined and at least one function is nonzero.)</li>
<li>We require isogenies to be nonconstant, i.e. we exclude the trivial map sending everything to the second curve’s distinguished point. This is a somewhat strange choice that’s not analogous to most other definitions of structure-preserving maps. We’ll find that it makes a bunch of properties and theorem statements nicer, but it does also makes a few worse, so this isn’t a universal convention.</li>
</ul></li>
</ul>
<p>This is a weak definition of an isogeny. Surprisingly, this definition suffices to imply that isogenies induce group homomorphisms with respect to the group structure we defined in the previous section, and that they’re surjective onto <span class="math inline">\(E_2/\overline{\mathbb{K}}\)</span>. This is pretty nuts and I don’t really understand how. (And note that this does not imply isogenies are surjective onto <span class="math inline">\(E_2/\mathbb{K}\)</span>, the curve over the original field, which is the stuff you’ll be writing your crypto code to manipulate!)</p>
<p>We will also have use for the term <strong>morphism</strong>. A morphism is a rational map that’s defined everywhere and that preserves the distinguished point (but because of the last point, when a morphism’s domain and codomain are both elliptic curves, the “defined everywhere” requirement is extraneous). Note that morphisms can be constant. Some sources drop the requirement that morphisms preserve distinguished points; I’m actually a bit confused about this, but I think we want it for our purposes.</p>
<p>A morphism from an elliptic curve to itself is an <strong>endomorphism</strong> (which is an isogeny unless it’s the zero morphism). An invertible endomorphism is an <strong>automorphism</strong>.</p>
<p>I spent a lot of time emphasizing that isogenies aren’t isomorphisms earlier, but they in fact do behave like weaker versions in a few ways:</p>
<ul>
<li>Even though isogenies aren’t isomorphisms, the condition that “there exists an isogeny from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>” between pairs of curves <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is an equivalence relation! If that statement is true, we say <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are <em>isogenous</em>. We’ll see later that there’s a “dual isogeny” that’s sort of like an inverse and implies this fact.</li>
<li>Two elliptic curves over a finite field are isogenous iff they have the same size (<a href="https://link.springer.com/book/10.1007/978-0-387-09494-6">Silverman</a> exercise V.5.4). Remember, this is a statement about the points on the curve over a finite field, and doesn’t contradict the earlier assertion that isogenies can be surjective but not injective, which concerns the points on the curve over the field’s algebraic closure. This fact is true even though any isogeny between these curves will not, and cannot, biject the (finitely many) points on the curves over the finite fields. I think this fact is sort of crazy.</li>
</ul>
<p>Isogenies are central to a fancy modern cryptographic system called <em>supersingular isogeny Diffie-Hellman key exchange</em>, or SIDH, but this is way beyond my pay grade. The extremely high-level and inaccurate idea: On a really big curve, Two people each secretly pick an isogeny, publish its image, and apply their (secret) isogeny to the other person’s image to get a shared secret. The reason SIDH is interesting is that it’s (believed to be) post-quantum secure. <a href="https://eprint.iacr.org/2019/1321">Costello 2019</a> is a more in-depth but still informal tutorial, and these <a href="https://yx7.cc/docs/misc/isog_aim_slides.pdf">slides (Panny 2019)</a> are another resource with nice pictures.</p>
<h4 id="examples-of-isogenies">Examples of Isogenies</h4>
<p>There are three broad classes of isogenies we can give as easy examples.</p>
<ol type="1">
<li>First, there are a bunch of relatively uninteresting isogenies that are just linear substitutions. For example, the mapping <span class="math inline">\((x, y) \mapsto (x + C/3, y)\)</span> we gave in a very early section, to demonstrate getting a curve into Weierstrass form, is certainly an isogeny between two curves. These are isomorphisms and are boring from a theoretical standpoint (though there are more interesting isomorphisms that convert curves to forms other than Weierstrass, which are sometimes useful in computational contexts).</li>
<li>There are <em>scalar multiplication</em> maps defined by repeatedly applying the group operation or inverse a fixed number of times. We already saw this earlier; the map denoted <span class="math inline">\([n]\)</span> for <span class="math inline">\(n \in \mathbb{Z}\)</span> sends <span class="math inline">\(P\)</span> to <span class="math inline">\(P + \cdots + P\)</span> with <span class="math inline">\(n\)</span> copies of <span class="math inline">\(P\)</span> (or <span class="math inline">\(|n|\)</span> copies of <span class="math inline">\(-P\)</span> if <span class="math inline">\(n &lt; 0\)</span>), and is an isogeny unless <span class="math inline">\(n = 0\)</span>. In particular, <span class="math inline">\([1]\)</span> is just the identity map, and <span class="math inline">\([-1]\)</span> is just the group inverse operation.</li>
<li>There is the <em>Frobenius endomorphism</em> in the field <span class="math inline">\(\mathbb{F}_p\)</span> (or other characteristic-<span class="math inline">\(p\)</span> field), which sends <span class="math inline">\((x, y) \mapsto (x^p, y^p)\)</span>. (This is another place where we must emphasize that the morphism must be considered as acting in the algebraic closure <span class="math inline">\(\overline{\mathbb{F}_p}\)</span>: the Frobenius map <span class="math inline">\(x \mapsto x^p\)</span> is the identity on <span class="math inline">\(\mathbb{F}_p\)</span>, but not in its algebraic closure; hence, even though the Frobenius endomorphism preserves every point with coordinates in <span class="math inline">\(\mathbb{F}_p\)</span>, it is distinct from the trivial identity morphism.)</li>
</ol>
<p>It’s not hard to see that the composition of two isogenies is an isogeny, so you can also compose isogenies of the above types to get new ones. There are also (many) isogenies that are not of any of the above types, but it’s surprisingly difficult to find any examples that are simple to describe. A small, hand-checkable example is the endomorphism on the curve <span class="math inline">\(y^2 = x^3 + x\)</span> over <span class="math inline">\(\mathbb{F}_5\)</span> given by:</p>
<p><span class="math display">\[(x, y) \mapsto \left(-x - \frac{1}{x}, 2\left(\frac{1}{x^2} - 1\right)y\right).\]</span></p>
<p>(This is the first equation from Silverman, “Advanced Topics in the Arithmetic of Elliptic Curves”, II.2.3.1, shoved into <span class="math inline">\(\mathbb{F}_5\)</span>. It has degree 2.)</p>
<p>An even more nontrivial example, also over <span class="math inline">\(\mathbb{F}_5\)</span>, is the isogeny from <span class="math inline">\(y^2 = x^3 - x + 1\)</span> to <span class="math inline">\(y^2 = x^3 - x\)</span> given by</p>
<p><span class="math display">\[(x, y) \mapsto \left(x + \frac{1}{x+2}, \left(1 - \frac{1}{(x+2)^2}\right)y\right).\]</span></p>
<p>Its kernel is <span class="math inline">\(\{(3, 0), \infty\}\)</span>. (I got this by plugging values into the Vélu formulas below.) As groups, these two elliptic curves are not even isomorphic. But they <em>do</em> have the same order (as they must, since they’re isogenous), which is 8. (Explicitly, the first one is isomorphic to <span class="math inline">\(\mathbb{Z}/8\mathbb{Z}\)</span>; the second, <span class="math inline">\(\mathbb{Z}/2\mathbb{Z} \times \mathbb{Z}/4\mathbb{Z}\)</span>. You can find the order by just brute-force checking how many pairs in <span class="math inline">\(\mathbb{F}_5 \times \mathbb{F}_5\)</span> satisfy the equations, and then find the group structure without actually computing any group operations by counting how many elements other than the identity are self-inverses, i.e. have <span class="math inline">\(x\)</span>-coordinate 0.)</p>
<p>A tangent: It is truly bizarre to look at the example isogenies provided by various sources. The slides on isogeny-based crypto I linked earlier suggest the following map <span class="math inline">\(y^2 = x^3 + x \to y^2 = x^3 - 3x + 3\)</span> over <span class="math inline">\(\mathbb{F}_{71}\)</span>: <span class="math display">\[(x, y) \mapsto \left(\frac{x^3 - 4x^2 + 30x - 12}{(x-2)^2}, \frac{x^3 - 6x^2 - 14x + 35}{(x-2)^3}\cdot y\right)\]</span> This <a href="https://www.johndcook.com/blog/2019/04/21/what-is-an-isogeny/">blog post</a> produces the absurd example <span class="math inline">\(y^2 = x^3 + 1132x + 278 \to y^2 = x^3 + 500x + 1005\)</span> over <span class="math inline">\(\mathbb{F}_{2003}\)</span>: <span class="math display">\[(x, y) \mapsto \left(\frac{x^2 + 301x + 527}{x + 301}, \frac{yx^2 + 602yx + 1942y}{x^2 + 602x + 466}\right)\]</span></p>
<p>Isogenies might be kind of scary, but they’re not <em>that</em> scary and don’t have to be as complicated as those examples suggest.</p>
<h4 id="isogenies-from-kernels">Isogenies from kernels</h4>
<p>It follows quickly from the group homomorphism property of isogenies that the kernel of any isogeny (the set of points it maps to zero, i.e. its codomain’s distinguished point) is a subgroup of the domain elliptic curve. A surprising but important fact is that this is a bijection between kernels and subgroups:</p>
<p><strong>Theorem.</strong> Let <span class="math inline">\(G\)</span> be a finite subgroup of an elliptic curve <span class="math inline">\(E\)</span> over a field <span class="math inline">\(\mathbb{K}\)</span>. There exists an elliptic curve <span class="math inline">\(E&#39;\)</span> over a finite extension of <span class="math inline">\(\mathbb{K}\)</span> and a separable isogeny <span class="math inline">\(\phi : E \to E&#39;\)</span>, both unique up to isomorphism, such that the kernel of <span class="math inline">\(\phi\)</span> is exactly <span class="math inline">\(G\)</span>.</p>
<p>It’s difficult to prove, so I’m going to skip the proof and just informally show you the formulas, due to Vélu, that you can use to explicitly construct an isogeny given a subgroup. (This isn’t an alternate proof strategy because it’s still pretty hard to see that the formulas satisfy all the desired conditions.)</p>
<p>Temporarily, let <span class="math inline">\(\oplus\)</span> and <span class="math inline">\(\ominus\)</span> denote coordinate-wise subtraction (<span class="math inline">\((x_1, y_1) \oplus (x_2, y_2) = (x_1 + x_2, y_1 + y_2)\)</span> and analogously for <span class="math inline">\(\ominus\)</span>), and consider the map <span class="math inline">\(\phi : E \to \mathbb{P}^2(\mathbb{K})\)</span>, defined as thus: if <span class="math inline">\(P \in G\)</span>, then <span class="math inline">\(\phi(P) = \infty\)</span>, and otherwise</p>
<p><span class="math display">\[\phi(P) := \bigoplus_{Q \in G} (P + Q) \ominus \bigoplus_{Q \in G \setminus \{\infty\}} Q.\]</span></p>
<p>We have to work around the point at infinity since it doesn’t have <span class="math inline">\(x\)</span> or <span class="math inline">\(y\)</span> coordinates. Because group addition can be expanded into a rational function of the coordinates of the points being added, this is a (possibly extremely complicated) rational map. Intuitively, if you try to extend the above equation to <span class="math inline">\(P \in G\)</span>, you can see the sum ends up equalling the point at infinity plus a bunch of other terms that exactly cancel out, which means it’s reasonable to say that the formula maps the point at infinity to itself. As a result, it’s a reasonable rational map whose kernel is exactly <span class="math inline">\(G\)</span> (we wrote down coordinates for every other point, so they’re not the point at infinity). Finally, its range is an elliptic curve and it’s a group homomorphism onto said curve — I won’t prove this because I don’t know how, but you can see that, for any fixed curve and subgroup, this is a brute algebraic fact you could theoretically prove with lots of algebraic manipulation. From this we conclude that <span class="math inline">\(\phi\)</span> is an isogeny.</p>
<p>Here is another <a href="https://mariascrs.github.io/2020/11/07/velus-formulas.html">resource on Vélu’s formulas</a>.</p>
<h3 id="standard-form-isogenies">Standard form isogenies</h3>
<p>Every isogeny can be written in the form <span class="math inline">\(\phi(x, y) = (\frac{u(x)}{v(x)}, \frac{s(x)}{t(x)}y)\)</span> for polynomials <span class="math inline">\(u, v, s, t\)</span>. The proof of this is basically:</p>
<ol type="1">
<li>Write an isogeny down in any reasonable way (as a pair of rational functions of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>) and expand everything.</li>
<li>Repeatedly replace <span class="math inline">\(y^2\)</span> with <span class="math inline">\(x^3 + Ax + B\)</span> and do “rationalizing the denominator” techniques until there are no factors of <span class="math inline">\(y\)</span> left in the denominators, and only linear factors of <span class="math inline">\(y\)</span> left in the numerators.</li>
<li>From the fact that <span class="math inline">\(\phi\)</span> maps group inverses to group inverses, observe that negating <span class="math inline">\(y\)</span> preserves the image’s <span class="math inline">\(x\)</span>-coordinate and flips the image’s <span class="math inline">\(y\)</span>-coordinate. This implies that a bunch of coefficients are zero.</li>
</ol>
<p>One can also prove the following:</p>
<ul>
<li><span class="math inline">\(v\)</span> and <span class="math inline">\(t\)</span> have the same roots. The affine points (i.e. those that aren’t the point at infinity) in the kernel of <span class="math inline">\(\phi\)</span> are precisely those where <span class="math inline">\(x\)</span> is one of those roots.</li>
<li><span class="math inline">\(v^3\)</span> divides <span class="math inline">\(t^2\)</span>.</li>
</ul>
<p>We can read off two important properties of the isogeny from the standard form:</p>
<ul>
<li>The <strong>degree</strong> of the isogeny <span class="math inline">\(\phi\)</span> is the maximum of the degree of <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>. (Why is this the right number, instead of the sum or difference of the degrees? It’s because it’s the degree of the polynomial equation in <span class="math inline">\(x\)</span> you’d get by expanding <span class="math inline">\(\frac{u(x)}{v(x)} = a\)</span> for an indeterminate <span class="math inline">\(a\)</span>.)</li>
<li><span class="math inline">\(\phi\)</span> is <strong>separable</strong> if <span class="math inline">\((u/v)&#39;\)</span> (the derivative<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a> with respect to <span class="math inline">\(x\)</span>) is not zero (as a polynomial). This is a really weird condition that can only happen in fields with nonzero characteristic: The Frobenius endomorphism is inseparable, and it turns out to be the “only way” to get an inseparable isogeny. Every inseparable isogeny can be written as the composition of a separable isogeny and some number of copies of the Frobenius endomorphism. The proof is not too hard, you just basically expand out <span class="math inline">\((u/v)&#39;\)</span> and figure out how it could possibly be zero, which involves differentiating <span class="math inline">\(x^p\)</span> to get <span class="math inline">\(px^{p-1} = 0\)</span> in characteristic <span class="math inline">\(p\)</span>.</li>
</ul>
<p>We can see that the Frobenius endomorphism has degree <span class="math inline">\(p\)</span>, but has trivial kernel. It’s easy to understand all other endomorphisms’ kernels’ sizes, in fact:</p>
<p><strong>Theorem.</strong> If <span class="math inline">\(\phi\)</span> is separable, then its degree equals the size of its kernel (over the algebraic closure!) The proof is something like, pick a “random” point <span class="math inline">\((a, b)\)</span> in the image of <span class="math inline">\(\phi\)</span> and solve <span class="math inline">\(\phi(x, y) = (a, b)\)</span>.</p>
<p>(Corollary: <span class="math inline">\(\phi\)</span> is an isomorphism iff it is degree 1.)</p>
<h3 id="a-lot-of-polynomials">A lot of polynomials</h3>
<p>Are you ready for a lot of (high-school term-pushing) algebra? Me neither.</p>
<p><strong>Fact.</strong> On a short Weierstrass equation <span class="math inline">\(y^2 = x^3 + Ax + B\)</span>, <span class="math display">\[[n](x, y) = \left(\frac{\phi_n(x, y)}{\psi_n^2(x, y)}, \frac{\omega_n(x, y)}{\psi_n^3(x, y)}\right)\]</span> where the polynomials <span class="math inline">\(\phi_n, \psi_n, \omega_n \in \mathbb{Z}[x, y]\)</span> are defined by <span class="math display">\[\begin{align*}\psi_0 &amp;= 0 \\ \psi_1 &amp;= 1 \\ \psi_2 &amp;= 2y \\ \psi_3 &amp;= 3x^4 + 6Ax^2 + 12Bx - A^2 \\ \psi_4 &amp;= 4y(x^6 + 5Ax^4 + 20Bx^3 - 5A^2x^2 - 4ABx - A^3 - 8B^2)\\
\psi_{2n+1} &amp;= \psi_{n+2}\psi_{n}^3 - \psi_{n-1}\psi_{n+1}^3 \text{ when } n \geq 2 \\
\psi_{2n} &amp;= \frac{1}{2y}\psi_n(\psi_{n+2}\psi_{n-1}^2 - \psi_{n-2}\psi_{n+1}^2) \text{ when } n \geq 3 \\
\psi_{-n} &amp;= \psi_n \\
\phi_n &amp;= x\psi_n^2 - \psi_{n+1}\psi_{n-1} \\
\omega_n &amp;= \frac{1}{4y}(\psi_{n+2}\psi_{n-1}^2 - \psi_{n-2}\psi_{n+1}^2).\end{align*}\]</span></p>
<p>You can simplify these polynomials to get an at-most-linear factor of <span class="math inline">\(y\)</span> by substituting the elliptic curve equation; if you do so, you arrive at the canonical form. Because we do divide by <span class="math inline">\(y\)</span> in two places, it takes some staring to see that these are polynomials and not rational functions, but it’s not a difficult induction. The polynomials <span class="math inline">\(\psi_i\)</span> in particular are called the <strong>division polynomials</strong>. These polynomials are well known and that’s all I’ll say about them for now.</p>
<p>From the above section, if <span class="math inline">\((x, y)\)</span> is an affine point on the elliptic curve, <span class="math inline">\(\psi_n(x, y) = 0\)</span> iff <span class="math inline">\((x, y)\)</span> is in the kernel of <span class="math inline">\([n]\)</span>.</p>
<h3 id="dual-isogenies">Dual isogenies</h3>
<p>Each isogeny <span class="math inline">\(\phi : E_1 \to E_2\)</span> has a <em>dual</em> isogeny, denoted with a hat: <span class="math inline">\(\widehat{\phi} : E_2 \to E_1\)</span>. If <span class="math inline">\(\phi\)</span> is degree 1, <span class="math inline">\(\widehat{\phi}\)</span> is an inverse, but of course this is not true in general because the isogeny may not even be invertible as a function. However, <span class="math inline">\(\widehat{\phi}\)</span> does always have the same degree as <span class="math inline">\(\phi\)</span>. Precisely, if <span class="math inline">\(\deg \phi = n\)</span> then <span class="math inline">\(\widehat{\phi}\)</span> is defined to be the unique isogeny such that <span class="math display">\[\widehat{\phi} \circ \phi = [n^2].\]</span></p>
<p>Here are some facts I won’t prove:</p>
<ul>
<li>True to its name, the dual of the dual of an isogeny is itself: <span class="math inline">\(\widehat{\widehat{\phi}} = \phi\)</span>.</li>
<li>The “dual” operation commutes with addition (on an elliptic curve, the way we defined it): <span class="math inline">\(\widehat{\phi + \psi} = \widehat{\phi} + \widehat{\psi}\)</span>.</li>
<li>The “dual” operation anticommutes with composition: <span class="math inline">\(\widehat{\phi \circ \psi} = \widehat{\psi} \circ \widehat{\phi}\)</span>. This is how inverses work too.</li>
<li><span class="math inline">\([n]\)</span> has degree <span class="math inline">\(n^2\)</span>. This is actually a statement you can prove through ugly algebraic bashing and induction. Thus, <span class="math inline">\([n]\)</span> is its own dual.
<ul>
<li>From this, you can induct on <span class="math inline">\(n\)</span> to prove that, when <span class="math inline">\([n]\)</span> is separable, its kernel is isomorphic to the direct sum <span class="math inline">\(\mathbb{Z}/\ell\mathbb{Z} \oplus \mathbb{Z}/\ell\mathbb{Z}\)</span> (that’s the abelian group whose elements are pairs of elements of <span class="math inline">\(\mathbb{Z}/\ell\mathbb{Z}\)</span> and all operations are the componentwise versions of what they are in <span class="math inline">\(\mathbb{Z}/\ell\mathbb{Z}\)</span>). The proof isn’t too hard: by the definition of <span class="math inline">\([n]\)</span> you know that every element of this group has order divisible by <span class="math inline">\(n\)</span>, and furthermore if <span class="math inline">\(m\)</span> divides <span class="math inline">\(n\)</span> then the kernel of <span class="math inline">\([m]\)</span> is a subset of the kernel of <span class="math inline">\([n]\)</span>, and there just aren’t that many possible finite group structures.</li>
</ul></li>
<li><p>When <span class="math inline">\(\phi\)</span> is an endomorphism, <span class="math inline">\(\phi + \widehat{\phi}\)</span> is well-defined, and it’s always a scalar multiplication map! (It may help your intuition to note that the above facts already imply it’s self-dual.) In fact it equals <span class="math inline">\([1 + \deg \phi - \deg (1 - \phi)]\)</span>. That integer is the <em>trace</em> of <span class="math inline">\(\phi\)</span>:</p>
<p><span class="math display">\[\text{tr}\,\phi = 1 + \deg \phi - \deg (1 - \phi)\]</span></p></li>
</ul>
<p>Finally, i wish to mention this fact, the <em>characteristic equation</em>:</p>
<p><span class="math display">\[\phi \circ \phi - [\text{tr}\,\phi] \circ \phi + [\deg \phi] = \widehat{\phi} \circ \widehat{\phi} - [\text{tr}\,\widehat{\phi}] \circ \widehat{\phi} + [\deg \widehat{\phi}] = 0.\]</span></p>
<p>You can prove it just by expanding things. Like Mickey Mouse says, it’s a surprise tool that will help us later.</p>
<h3 id="counting-points">Counting points</h3>
<p>Okay! Given the coordinates of a curve defined over <span class="math inline">\(\mathbb{F}_p\)</span>, how shall we figure out how big the group is, i.e. count how many points are on it?</p>
<p>Let’s first consider the following extremely stupid algorithm: For every pair of points <span class="math inline">\((x, y)\)</span>, evaluate the Weierstrass equation <span class="math inline">\(y^2 = x^3 + Ax + B\)</span> and see if it’s true. (Finally, add one for the point at infinity.) This is <span class="math inline">\(2^{512}\)</span> checks. If every particle in the universe checked one pair every Planck unit of time for the age of the universe, that’d still be 12 orders of magnitude off.</p>
<p>A smarter algorithm: For every field element <span class="math inline">\(x\)</span>, evaluate <span class="math inline">\(x^3 + Ax + B\)</span> and see if it’s a quadratic residue mod <span class="math inline">\(p\)</span>. If it is, there will be two solutions for <span class="math inline">\(y\)</span>, and if not, there will be zero. As a special case, if <span class="math inline">\(x^3 + Ax + B = 0\)</span>, there will be exactly one. This result tells us how many points on the elliptic curve have that <span class="math inline">\(x\)</span>-coordinate, so you just sum that across all <span class="math inline">\(x\)</span>-coordinates (and, again, add one for the point at infinity). This is <span class="math inline">\(2^{256}\)</span> checks, although checking whether a number is a quadratic residue is not trivial. (But if you’re checking <span class="math inline">\(2^{256}\)</span> operations anyway, you’re already in fantasyland and could just precompute every square and throw them into a <span class="math inline">\(2^{256}\)</span>-sized hash table.)</p>
<p>Although this algorithm is still completely unreasonable, it gives us an interesting insight, that the curve should have <span class="math inline">\(p + 1\)</span> points “on average”: there are equally many quadratic residues as nonresidues, so for each value of <span class="math inline">\(x\)</span>, there should be one point on average with that <span class="math inline">\(x\)</span>-coordinate. In fact, if you know about <a href="https://en.wikipedia.org/wiki/Random_walk#One-dimensional_random_walk">one-dimensional random walks</a>, you might surmise that the curve’s size should be in the range <span class="math inline">\(p + 1 \pm O(\sqrt{p})\)</span>.</p>
<p>The first intuition can be made almost fully rigorous surprisingly easily: if we let <span class="math inline">\(s\)</span> be a quadratic nonresidue, then the <em>quadratic twist</em> <span class="math inline">\(sy^2 = x^3 + Ax + B\)</span> (which you can rearrange into Weierstrass form with some scaling and whatever) is a different elliptic curve with the property that, for a given <span class="math inline">\(x\)</span>-coordinate, the original elliptic curve and the quadratic twist always have a total of exactly two points. So the two curves always have exactly <span class="math inline">\(2p + 2\)</span> points in total, and you can pair off elliptic curves this way. (Any quadratic nonresidue gives an isomorphic curve, which is why we say <em>the</em> quadratic twist and can cavalierly pair off curves. This is not true in other fields.)</p>
<p>Surprisingly, the second intuition can also be made rigorous and always true: the size of every curve lies in the interval <span class="math inline">\(p + 1 \pm 2\sqrt{p}\)</span>. This is much less obvious and comes from a named theorem.</p>
<h4 id="hasses-theorem">Hasse’s Theorem</h4>
<p><strong>Theorem</strong>: <span class="math inline">\(\#E(\mathbb{F}_p) = p + 1 - t\)</span>, where <span class="math inline">\(t = \text{tr}\,\pi_E\)</span> is the trace of the Frobenius endomorphism. Furthermore, <span class="math inline">\(|t| \leq 2\sqrt{p}\)</span>.</p>
<p>I am not sure if the proof is illuminating, but it’s not that long, and I think it helps to know where the square root comes from.</p>
<p>Proof: <span class="math inline">\(E(\mathbb{F}_p)\)</span> is precisely the kernel of <span class="math inline">\(\pi_E - 1\)</span>, which is a separable isogeny; therefore, its size equals <span class="math inline">\(\deg (\pi_E - 1)\)</span>, which we can also write as <span class="math display">\[\begin{align*}\deg (\pi_E - 1) &amp;= \widehat{(\pi_E - 1)}(\pi_E - 1) \\ &amp;= \widehat{\pi_E}\pi_E - \pi_E - \widehat{\pi_E} + 1 \\ &amp;= \deg \pi_E - \text{tr}\,\pi_E + 1.\end{align*}\]</span></p>
<p>Let <span class="math inline">\(r, s \in \mathbb{Z}\)</span> with <span class="math inline">\(s \neq 0\)</span>. Below, integers mean the corresponding scalar multiplication map, and juxtaposing two isogenies means composing them. Then <span class="math display">\[\begin{align*}\deg (r\pi_E - s) &amp;= \widehat{(r\pi_E - s)}(r\pi_E - s) \\ &amp;= r^2\widehat{\pi_E}\pi_E - rs(\widehat{\pi_E} + \pi_E) + s \\ &amp;= r^2 \deg \pi_E - rs (\text{tr}\,\pi_E) + s^2 \\ &amp;= r^2p - rs (\text{tr}\,\pi_E) + s^2 \end{align*}\]</span> Note that we used a lot of highly nonobvious distributing and commuting of multiplications, but each can be justified using the facts we know about duals. What’s interesting about this is that the degree of an isogeny must be nonnegative regardless of <span class="math inline">\(r\)</span> and <span class="math inline">\(s\)</span>, so if you view the final RHS as a quadratic of <span class="math inline">\(r/s\)</span>, its discriminant <span class="math inline">\((\text{tr}\,\pi_E)^2 - 4\deg \pi_E\)</span> must be nonpositive. We can easily rearrange that to get <span class="math display">\[|\text{tr}\,\pi_E| \leq 2\sqrt{\deg \pi_E} = 2\sqrt{p}.\]</span></p>
<p><span class="math inline">\(\square\)</span></p>
<p>There are ways to use this to optimize point-counting to less drastically exponential, but we’ll skip them and go straight to the polynomial time algorithm, because that’s the only way to get something practical for the elliptic curves over cryptograhpically large fields that we care about.</p>
<h3 id="schoofs-algorithm">Schoof’s algorithm</h3>
<p>This is the first polynomial time algorithm for counting points on an elliptic curve, published in 1985.</p>
<p>The high level idea is simple: Hasse’s theorem tells us we just need to compute <span class="math inline">\(t = \text{tr}\,\pi_E\)</span> and we have bounds on it, so if we can compute <span class="math inline">\(t \bmod q\)</span> for many small primes <span class="math inline">\(q\)</span>, we’ll eventually narrow down the possibilities for <span class="math inline">\(t\)</span> in that range to one, by the Chinese Remainder Theorem.</p>
<p>When we do this, we examine the cases where <span class="math inline">\(q = 2\)</span> and <span class="math inline">\(q &gt; 2\)</span> separately.</p>
<h4 id="schoofs-algorithm-q-2">Schoof’s algorithm: q = 2</h4>
<p>This case is different from the others and is almost not worth explaining, since it’s “just a constant factor optimization”, but it is very easy (relatively speaking) and also educational. We will actually just compute <span class="math inline">\(\#E(\mathbb{F}_p) \bmod 2\)</span> directly.</p>
<p>The key observation is just that most affine points <span class="math inline">\(E(\mathbb{F}_p)\)</span> pair off: <span class="math inline">\((x, y)\)</span> and <span class="math inline">\((x, -y)\)</span>. The exceptions are points where <span class="math inline">\(y = 0\)</span>. So we just need to count the number of solutions to <span class="math inline">\(x^3 + Ax + B = 0\)</span> (of which there are at most three), and then add one for the point at infinity, to get the parity of <span class="math inline">\(\#E(\mathbb{F}_p)\)</span>.</p>
<p>We can do that by computing <span class="math inline">\(\gcd(x^3 + Ax + B, x^q - x)\)</span>. (Note that, in <span class="math inline">\(\mathbb{F}_q[x]\)</span>, <span class="math inline">\(x^q - x = \prod_{r=0}^{q-1} (x-r)\)</span>. I don’t know if this fact has a name but it’s just a Frobenius Fact that follows from Fermat’s little theorem, <span class="math inline">\(r^q - r = 0\)</span> for all <span class="math inline">\(r \in \mathbb{F}_q\)</span>, so all <span class="math inline">\(r\)</span> are roots, and the degree matches.) But how? You can’t just directly do long division of <span class="math inline">\(x^q - x\)</span> by <span class="math inline">\(x^3 + Ax + B\)</span> like you would in the Eucliedan algorithm; <span class="math inline">\(q\)</span> is massive and that would take time linear in <span class="math inline">\(q\)</span>.</p>
<p>Instead, you can compute <span class="math inline">\(x^q \bmod x^3 + Ax + B\)</span> by repeated doubling, and then subtract <span class="math inline">\(x\)</span>; this step is logarithmic in <span class="math inline">\(q\)</span>, and the Euclidean algorithm is tractable afterwards. The degree of this GCD will give you the parity you seek.</p>
<h4 id="schoofs-algorithm-q-2-1">Schoof’s algorithm: q &gt; 2</h4>
<p>Let <span class="math inline">\(E[q]\)</span> be the kernel of <span class="math inline">\([q]\)</span>, a finite subgroup of <span class="math inline">\(E/\overline{\mathbb{K}}\)</span> that we saw earlier is isomorphic to <span class="math inline">\(\mathbb{Z}/q\mathbb{Z} \oplus \mathbb{Z}/q\mathbb{Z}\)</span> (unless <span class="math inline">\(q = p\)</span> and <span class="math inline">\([q]\)</span> is inseparable, but this won’t happen because <span class="math inline">\(q \ll p\)</span>). We know from earlier that the division polynomial <span class="math inline">\(\psi_q\)</span> (which is purely a polynomial in <span class="math inline">\(x\)</span>, since <span class="math inline">\(q\)</span> is odd) is zero for precisely the affine points in <span class="math inline">\(E[q]\)</span>.</p>
<p>We’re going to work in the endomorphism ring <span class="math inline">\(\text{End}(E[q])\)</span>, the ring of endomorphisms <span class="math inline">\(E[q] \to E[q]\)</span>, where multiplication is composition. All endomorphisms of <span class="math inline">\(E\)</span> map <span class="math inline">\(E[q] \to E[q]\)</span> (every endomorphism commutes with group addition, so every endomorphism commutes with <span class="math inline">\([q]\)</span> and thus preserves its kernel), but note that we are dropping the perspective that maps are morphisms of elliptic curves here: two maps in this endomorphism ring <span class="math inline">\(\text{End}(E[q])\)</span> are <em>the same if they’re the same as functions</em> <span class="math inline">\(E[q] \to E[q]\)</span>! This “perspective dropping” is denoted with a subscript: if <span class="math inline">\(\alpha\)</span> is an isogeny, the endomorphism it’s viewed as in <span class="math inline">\(\text{End}(E[q])\)</span> is <span class="math inline">\(\alpha_q\)</span>. Viewing things this way can sort of be thought of like “taking equations of isogenies mod <span class="math inline">\(q\)</span>”, because in the ring, <span class="math inline">\([n] = [n&#39;]\)</span> iff <span class="math inline">\(n \equiv n&#39; \bmod{q}\)</span>.</p>
<p>Since we only care about the finite group <span class="math inline">\(E[q]\)</span>, we can think of each endomorphism as essentially a linear transformation <span class="math inline">\((\mathbb{Z}/q\mathbb{Z})^2 \to (\mathbb{Z}/q\mathbb{Z})^2\)</span>, i.e. as a <span class="math inline">\(2 \times 2\)</span> matrix with <span class="math inline">\(\mathbb{Z}/q\mathbb{Z}\)</span> entries. Note, however, that if we want to do explicit computations with endomorphisms (which we do), we will still represent them as rational functions; we don’t know the structure of the underlying group or linear transformations well enough. It’s just that we’ll get to mod out more stuff from those rational functions.</p>
<p>What we’re going to do now is plug the Frobenius endomorphism into the characteristic equation (Mickey Mouse says hello) and view it this way. <span class="math display">\[\pi_q^2 - [\text{tr}\,\pi \bmod q] \pi_q + [\deg \pi \bmod q] = 0.\]</span> This equation has the value we care about! The next step is the time-honored tradition of brute force: for <span class="math inline">\(c = 0, 1, \ldots, q - 1\)</span>, we’re going to evaluate <span class="math display">\[\pi_q^2 - [c]\pi_q + [\deg \pi \bmod q]\]</span> and see if it’s zero.</p>
<p>To make this algorithm actually executable, though, we need to nail down our representation of elements of <span class="math inline">\(\text{End}(E[q])\)</span> and how we manipulate and simplify them. We know we can already think of such elements as rational maps. In each such map, we can plug in the equation of <span class="math inline">\(E\)</span> to convert every such map to standard form, as we already know how to do. But we can also plug in <span class="math inline">\(\psi_q = 0\)</span> because we know it’s true for all the points in <span class="math inline">\(E[q]\)</span>, which is all the points we care about. We can multiply (i.e. compose) rational maps as, well, rational maps, and we can add them by just plugging them wholesale into point-addition formulae.</p>
<p>However, doing the entire computation with rational maps isn’t great. We would really like to use the fact that we’re working modulo <span class="math inline">\(\psi_q(x)\)</span> to convert division to multiplication, so every value can be represented as just a polynomial. And we would be able to do so if <span class="math inline">\(\psi_q(x)\)</span> were irreducible in <span class="math inline">\(\mathbb{F}_q[x]\)</span>, which means all nonzero polynomials just be inverted <span class="math inline">\(\bmod \psi_q(x)\)</span> with the Euclidean algorithm. Unfortunately, this isn’t always the case; <span class="math inline">\(\psi_q(x)\)</span> could have factors.</p>
<p>Nevertheless, we can actually pretend <span class="math inline">\(\psi_q(x)\)</span> is irreducible and forge ahead with representing every rational map as a polynomial anyway, with the following fallback: if inverting something fails, that means we found a factor <span class="math inline">\(h&#39;\)</span>, we can actually just redo the whole algorithm mod <span class="math inline">\(h&#39;\)</span> instead!</p>
<p>The only way this would fail is if it introduced a false positive, where <span class="math display">\[\pi_q^2 - [c]\pi_q + [\deg \pi \bmod q] \equiv \pi_q^2 - [\text{tr}\,\pi \bmod q] \pi_q + [\deg \pi \bmod q] \bmod h&#39;\]</span> even though <span class="math inline">\(c \not\equiv \text{tr}\,\pi \bmod q\)</span>. That implies <span class="math display">\[[c - \text{tr}\,\pi \bmod q] \equiv 0 \bmod h&#39;\]</span> even though it’s not the 0 endomorphism. Let <span class="math inline">\(x_0\)</span> be a root of <span class="math inline">\(h&#39;\)</span> (in <span class="math inline">\(\overline{\mathbb{F}_p}\)</span>, but possibly outside <span class="math inline">\(\mathbb{F}_p\)</span>), and solve <span class="math inline">\(E\)</span> to get points <span class="math inline">\((x_0, \pm y_0)\)</span>; since <span class="math inline">\(h&#39;\)</span> divides <span class="math inline">\(h\)</span>, we have <span class="math inline">\((x_0, \pm y_0) \in E[q]\)</span> while not being the identity, but also <span class="math inline">\([c - \text{tr}\,\pi \bmod q](x_0, \pm y_0) = 0\)</span>. This contradicts the group structure of <span class="math inline">\(E[q]\)</span>.</p>
<p>Great! Now we can write down Schoof’s algorithm for <span class="math inline">\(q &gt; 2\)</span>.</p>
<ol type="1">
<li>Compute the division polynomial <span class="math inline">\(\psi_q\)</span>. Let it be <span class="math inline">\(h\)</span>.</li>
<li>Compute the Frobenius endomorphism <span class="math inline">\(\pi_q(x, y) = (x^p, y^p) \bmod (E, h)\)</span>.</li>
<li><p>Using scalar multiplication and the addition formula, compute <span class="math inline">\(\pi_q^2 + p_q \bmod (E, h)\)</span>.</p>
<ul>
<li>If a non-invertible denominator arises, use it to derive a nontrivial factor of <span class="math inline">\(h\)</span>, then replace <span class="math inline">\(h\)</span> with it and go back to step 2.</li>
</ul></li>
<li><p>For increasing <span class="math inline">\(c\)</span>, compute <span class="math inline">\(c\pi_q \bmod (E, h)\)</span> until it equals <span class="math inline">\(\pi_q^2 + p_q\)</span>.</p>
<ul>
<li>If a non-invertible denominator arises, use it to derive a nontrivial factor of <span class="math inline">\(h\)</span>, then replace <span class="math inline">\(h\)</span> with it and go back to step 2.</li>
</ul></li>
<li><p>Output <span class="math inline">\(c\)</span>.</p></li>
</ol>
<p>And we’re done!</p>
<h3 id="general-references-and-further-reading">General references and further reading</h3>
<p>I cobbled together most of the more theoretical material on elliptic curves from the first third of the <a href="https://math.mit.edu/classes/18.783/2021/lectures.html">18.783 lecture notes</a>, with occasional forays into its references, <a href="https://www.taylorfrancis.com/books/mono/10.1201/9781420071474/elliptic-curves-lawrence-washington"><cite>Elliptic Curves</cite> by Washington</a> and <a href="https://link.springer.com/book/10.1007/978-0-387-09494-6"><cite>The Arithmetic of Elliptic Curves</cite> by Silverman</a> (note that Silverman has a second book called <cite>Advanced Topics in the Arithmetic of Elliptic Curves</cite>). The stuff about cryptographic vulnerabilities was lots of googling from <a href="https://safecurves.cr.yp.to/">SafeCurves</a>. I don’t think I have any other overall resources, but one of the more fun blog posts I found that I couldn’t fit in is about <a href="http://blog.bjrn.se/2015/07/lets-construct-elliptic-curve.html">constructing an elliptic curve, Crackpot2065</a>, from scratch; and of course there are a lot of links sprinkled through the above post.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>To be extremely technically cautious, I might clarify that I mean “rational prime” — that is, a prime in <span class="math inline">\(\mathbb{Z}\)</span>, one of those numbers 2, 3, 5, 7… You know them. The weird name is so there’s no confusion with “primes” in other rings; for example, 2 is not a prime in the ring of Eisenstein integers <span class="math inline">\(\mathbb{Z}[i]\)</span> because <span class="math inline">\(2 = (1+i)(1-i)\)</span> (or to be absolutely precise, <span class="math inline">\(2\)</span> divides <span class="math inline">\((1+i)(1-i)\)</span> even though 2 divides neither factor).<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>See <a href="https://www.degruyter.com/document/doi/10.1515/jmc.2011.005/html">An exploration of affine group laws for elliptic curves</a>. I don’t fully understand this but apparently it’s just applying standard techniques.<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>See e.g. <a href="https://eprint.iacr.org/2013/058">Cryptanalysis of the Dragonfly Key Exchange Protocol</a>, Clarke and Hao, 2013. Via the Decaf paper linked shortly.<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>A. Shallue and C. van de Woestijne, <a href="https://digitalcommons.iwu.edu/math_scholarship/72/">“Construction of Rational Points on Elliptic Curves over Finite Fields”</a>, 2006.<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>M. Ulas, <a href="https://arxiv.org/abs/0706.1448">“Rational points on certain hyperelliptic curves over finite fields”</a>, 2007.<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>T. Icart, <a href="https://www.iacr.org/archive/crypto2009/56770300/56770300.pdf">“How to Hash into Elliptic Curves”</a>, 2009.<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>E. Brier, J.-S. Coron, T. Icart, D. Madore, H. Randriam, and M. Tibouchi, <a href="https://www.iacr.org/archive/crypto2010/62230238/62230238.pdf">“Efficient Indifferentiable Hashing into Ordinary Elliptic Curves”</a>, 2010.<a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p>Technically the <a href="https://en.wikipedia.org/wiki/Formal_derivative">formal derivative</a>, since we are most likely working over a field where limits don’t make sense. But you can just pretend you are and differentiate any polynomial in the same way, replacing each term <span class="math inline">\(ax^n\)</span> with <span class="math inline">\(anx^{n-1}\)</span>.<a href="#fnref8" class="footnote-back">↩</a></p></li>
</ol>
</section></article>
	<footer class="post-footer">
		
		<ul class="post-tags">
			
		</ul>
		
	</footer>
	<script data-isso="//node.vero.site/isso/" data-isso-css="false" src="//node.vero.site/isso/js/embed.min.js"></script>
	<section id="isso-thread"></section>
	<p class="comments-meta">(note: the commenting setup here is experimental and I may not check my comments often; if you want to tell <em>me</em> something instead of the world, email me!)</p>
	
	
	
	<footer class="post-footer">
		<nav class="pagination">
			
			<a class="pagination-previous" href="//blog.vero.site/post/anki-trick">← One Weird Anki Trick</a>
			
			
		</nav>
	</footer>
</section>
<footer class="site-footer">
	<p>© 2017-2021 betaveros, Bounded-Error Log</p>
	<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />Except where otherwise noted, content on this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
	<p>Powered by <a href="https://gohugo.io/">Hugo</a>, <a href="http://pandoc.org/">pandoc</a>,
	<a href="https://www.goatcounter.com/">GoatCounter</a>,
	<a href="https://posativ.org/isso/">Isso</a>,
	<a href="https://pages.github.com/">GitHub Pages</a>, and
	<a href="https://www.cloudflare.com/">CloudFlare</a>.
	</p>
	<p>Opinions are mine and not of any employer, past or present.</p>
</footer>

<script src="/katex/katex.min.js"></script>
<script src="/katex/contrib/auto-render.min.js"></script>
<script>renderMathInElement(document.body);</script>
<script src="/js/bundle.js"></script>
<script>window.goatcounter = { path: function(p) { return '/blog' + p; } }</script>
<script data-goatcounter="https://node.vero.site:8073/count" async src="https://node.vero.site:8073/count.js"></script>
<script src="/js/jquery-3.2.1.min.js"></script>


</div></body>
</html>
